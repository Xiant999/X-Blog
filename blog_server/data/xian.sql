/*
 Navicat MySQL Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50728
 Source Host           : localhost:3306
 Source Schema         : xian

 Target Server Type    : MySQL
 Target Server Version : 50728
 File Encoding         : 65001

 Date: 09/01/2020 15:34:36
*/

create database xian;
use xian;

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标题',
  `title_pic` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '封面图片',
  `author` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '作者',
  `content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '摘要',
  `content_md` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容-Markdown',
  `origin` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '来源',
  `state` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '状态',
  `eye_count` bigint(20) NULL DEFAULT 0 COMMENT '浏览量',
  `publish_time` timestamp(0) NOT NULL DEFAULT '1970-02-01 00:00:01' COMMENT '发布时间',
  `edit_time` timestamp(0) NOT NULL DEFAULT '1970-02-01 00:00:01' COMMENT '上次修改时间',
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `content_html` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容-HTML',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 320 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文章表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (273, 'A-simple-story', 'http://47.100.57.39/static/uploads/c5/25a4dbacc072dbc5db67555c8a86c4.jpg', 'Colborne', '关于简单的故事', '# 关于简单的故事\n\n* 作者提到一台打印机复杂的流程，大概经过几个小时安装和调试（查看安装手册、部件组装、检测硬件设置、调试设置开关、安装驱动）才能正常使用，\n甚至需要专业的技术支持人员才能够让一台打印机可以正常使用\n\n* 本来应该给我们带来便利的技术，经常又好像是和我们作对一样。\n现在在使用一台打印机就方便很多，基本上就和使用新的一台新的电视一样。\n\n* **为什么安装打印机不能像插电源插座那么简单？**  ', '', '2', 0, '2020-01-08 17:33:07', '2020-01-08 17:33:07', '2020-01-06 22:17:33', '<h1>关于简单的故事</h1>\n<ul>\n<li>\n<p>作者提到一台打印机复杂的流程，大概经过几个小时安装和调试（查看安装手册、部件组装、检测硬件设置、调试设置开关、安装驱动）才能正常使用，<br>\n甚至需要专业的技术支持人员才能够让一台打印机可以正常使用</p>\n</li>\n<li>\n<p>本来应该给我们带来便利的技术，经常又好像是和我们作对一样。<br>\n现在在使用一台打印机就方便很多，基本上就和使用新的一台新的电视一样。</p>\n</li>\n<li>\n<p><strong>为什么安装打印机不能像插电源插座那么简单？</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (274, 'Features', 'http://47.100.57.39/static/uploads/29/24a04e1a2500e47d0a881722b7d665.jpg', 'Colborne', '特征：简单并不意味着欠缺或低劣', '# 特征\n\n```text\n简单并不意味着欠缺或低劣，也不意味着不注重装饰或者完全赤裸裸。\n而是说装饰应该紧密贴近设计本身，任何无关紧要的要素都应该给予以剔除。  \n             ——— Paul Jacques Grillo ( Form, Function and Design)\n```\n\n* 简单的特征和个性应该源自使用的方法、要表现的产品，以及用户执行的任务。\n* 简单并不意味最少，朴素的设计仍然具有自身的特征和个性。\n用料、对关键要素的强调，甚至组合几个要素的方式，都会直接影响到最终设计。人们能够识别出差异，并为这些差异赋予相应的价值。  \n\n* 这两把椅子都很简单，但是各有各的独一无二的特征。  \n![](http://xcoding.com:8080/static/uploads/19/afff98b37e6bac3bbb197e82b566a4.jpeg)![](http://xcoding.com:8080/static/uploads/2e/590a96d842b7977f03fe29ea4352d5.jpeg)', '', '2', 0, '2020-01-08 17:33:13', '2020-01-08 17:33:13', '2020-01-06 23:57:36', '<h1>特征</h1>\n<pre><code data-language=\"text\" class=\"lang-text\">简单并不意味着欠缺或低劣，也不意味着不注重装饰或者完全赤裸裸。\n而是说装饰应该紧密贴近设计本身，任何无关紧要的要素都应该给予以剔除。  \n             ——— Paul Jacques Grillo ( Form, Function and Design)\n</code></pre>\n<ul>\n<li>\n<p>简单的特征和个性应该源自使用的方法、要表现的产品，以及用户执行的任务。</p>\n</li>\n<li>\n<p>简单并不意味最少，朴素的设计仍然具有自身的特征和个性。<br>\n用料、对关键要素的强调，甚至组合几个要素的方式，都会直接影响到最终设计。人们能够识别出差异，并为这些差异赋予相应的价值。</p>\n</li>\n<li>\n<p>这两把椅子都很简单，但是各有各的独一无二的特征。</p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (275, 'know-yourself', 'http://47.100.57.39/static/uploads/d2/5a259cc418815a3c60e97875d547a8.jpg', 'Colborne', '了解自己', '# 了解自己\n\n大多数的公司都是按照一个方程式进行运作的。例如： \n```text\n（销量）x （单价） - （成本） = （利润）\n```\n    \n* 要明白用户体验将会如何影响方程式中的每一项。到底是能够增加销量，还是能够提高价格，还是能够降低成本。\n而且还需要将这些改变排出先后次序（比较好的做法是对每项改变的重要性和可行性进行评估）。', '', '2', 0, '2020-01-08 17:33:17', '2020-01-08 17:33:17', '2020-01-07 00:01:27', '<h1>了解自己</h1>\n<p>大多数的公司都是按照一个方程式进行运作的。例如：</p>\n<pre><code data-language=\"text\" class=\"lang-text\">（销量）x （单价） - （成本） = （利润）\n</code></pre>\n<ul>\n<li>要明白用户体验将会如何影响方程式中的每一项。到底是能够增加销量，还是能够提高价格，还是能够降低成本。<br>\n而且还需要将这些改变排出先后次序（比较好的做法是对每项改变的重要性和可行性进行评估）。</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (276, 'not-that-simple-method', 'http://47.100.57.39/static/uploads/15/7814b7d1ed76cbcc8038098a0c0910.jpg', 'Colborne', '不是那种简单法', '# 不是那种简单法\n\n* 有些时候，我们设计产品功能的所谓简单，通常是将复杂的压力转嫁到这个产品的另外一部分人的身上。\n例如，有些内部管理系统的设计人员，为了给管理者便利，为普通员工设计了非常复杂的表单和流程。所以，我们在做技术产品设计时，至少要有3个角度：管理人员、工程师和用户。\n\n* 一个人在一种情况下觉得简单的事物，换一个人或者一种情况，可能就不会觉得简单了。\n例如，\n\n* 虽然为富有经验的用户设计复杂系统是一个有趣的话题，但是只有为广大用户考虑，技术才会真正落实到用户（特别是对于面向大众用户的产品），才能更好的推广和传播产品。\n\n', '', '2', 0, '2020-01-08 17:33:23', '2020-01-08 17:33:23', '2020-01-07 00:03:39', '<h1>不是那种简单法</h1>\n<ul>\n<li>\n<p>有些时候，我们设计产品功能的所谓简单，通常是将复杂的压力转嫁到这个产品的另外一部分人的身上。<br>\n例如，有些内部管理系统的设计人员，为了给管理者便利，为普通员工设计了非常复杂的表单和流程。所以，我们在做技术产品设计时，至少要有3个角度：管理人员、工程师和用户。</p>\n</li>\n<li>\n<p>一个人在一种情况下觉得简单的事物，换一个人或者一种情况，可能就不会觉得简单了。<br>\n例如，</p>\n</li>\n<li>\n<p>虽然为富有经验的用户设计复杂系统是一个有趣的话题，但是只有为广大用户考虑，技术才会真正落实到用户（特别是对于面向大众用户的产品），才能更好的推广和传播产品。</p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (277, 'seemingly-simple', 'http://47.100.57.39/static/uploads/f2/4929659b5472b48e90e0132e7c2973.jpg', 'Colborne', '貌似简单', '# 貌似简单\n\n* 貌似简单的例子随处可见。“减肥药”、“高尔夫俱乐部的激光瞄准镜”以及“足不出户发大财”的方案等。这些貌似简单的东西没有一个应验的。\n相反，它们的存在反而让事情变得更复杂，效果更差。\n\n* 热衷于做表面文章的人，永远不会创造出简单的用户体验来。\n\n* **简单可不是这种能够粘在用户界面上的装饰。**', '', '2', 0, '2020-01-08 17:33:28', '2020-01-08 17:33:28', '2020-01-07 00:04:03', '<h1>貌似简单</h1>\n<ul>\n<li>\n<p>貌似简单的例子随处可见。“减肥药”、“高尔夫俱乐部的激光瞄准镜”以及“足不出户发大财”的方案等。这些貌似简单的东西没有一个应验的。<br>\n相反，它们的存在反而让事情变得更复杂，效果更差。</p>\n</li>\n<li>\n<p>热衷于做表面文章的人，永远不会创造出简单的用户体验来。</p>\n</li>\n<li>\n<p><strong>简单可不是这种能够粘在用户界面上的装饰。</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (278, 'simple-force', 'http://47.100.57.39/static/uploads/bc/5d292e108f3e78c38f646e6fae1bc9.jpg', 'Colborne', '简单的力量', '# 简单的力量\n\n```text\n2007年，乔纳森.卡普兰(Jonathan Kaplan)和艾瑞.布朗斯坦(Ariel Braunstein)敏锐的意识到当时的便携式摄像机已经变得复杂难用，\n大家可能只想拍一些视频花絮传到视频网站分享给亲朋好友。\n于是设计了一款叫Flip的简单的便携式摄像机，一年左右占领了美国的1/6的摄像机市场。\nFlip的目标就是尽可能的简单，甩开一切不必要的功能。没有连接线，只有一个弹出式的USB接口，整个机身只有9个操作键，其中还包括一个大大的红色录像键。\n像File、早期的大众甲壳虫汽车以及Twitter这样简单的产品，都会对市场产生深远的影响。它们简单应用，因此能够为大众所接受；它们值得信赖，因此会赢得用户；它们适应性强，因此总会发展处别具一格的应用方式。\n```\n\n* **人们喜欢简单、值得信赖、适应性强的产品。**', '', '2', 0, '2020-01-07 13:49:34', '2020-01-07 13:49:34', '2020-01-07 00:04:21', '<h1>简单的力量</h1>\n<pre><code data-language=\"text\" class=\"lang-text\">2007年，乔纳森.卡普兰(Jonathan Kaplan)和艾瑞.布朗斯坦(Ariel Braunstein)敏锐的意识到当时的便携式摄像机已经变得复杂难用，\n大家可能只想拍一些视频花絮传到视频网站分享给亲朋好友。\n于是设计了一款叫Flip的简单的便携式摄像机，一年左右占领了美国的1/6的摄像机市场。\nFlip的目标就是尽可能的简单，甩开一切不必要的功能。没有连接线，只有一个弹出式的USB接口，整个机身只有9个操作键，其中还包括一个大大的红色录像键。\n像File、早期的大众甲壳虫汽车以及Twitter这样简单的产品，都会对市场产生深远的影响。它们简单应用，因此能够为大众所接受；它们值得信赖，因此会赢得用户；它们适应性强，因此总会发展处别具一格的应用方式。\n</code></pre>\n<ul>\n<li><strong>人们喜欢简单、值得信赖、适应性强的产品。</strong></li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (279, 'a-clear-understanding-of', 'http://47.100.57.39/static/uploads/e2/0abaf19f9b9697fe01a66a14941141.jpg', 'Colborne', '明确认识', '# 明确认识\n```text\n乍一看到某个问题，你会觉得很简单，其实你并没有理解其复杂性。\n当你把问题搞清楚之后，优惠发现真的很复杂，于是你就拿出一套复杂的方案来。\n实际上，你的工作只做了一般，大多数人也都会到此为止......\n但是真正伟大的人还会继续向前，知道找到问题的关键和深层次原因，然后再拿出一个优雅的、堪称完美的有效方案。\n    -- 史蒂夫.乔布斯(摘自Steven Levy的Insanely Great:The Life and Times of Macintosh,the Computer that Changed Everything)\n```\n* 写出自己的认识，比自己想象的时间要长。\n\n* 太早开始设计意味着会遗漏重要的见解，甚至意味着设计思路完全错误。  \n\n* 花点时间理解问题，可以帮你想出更好、更简单的方案。 \n \n* 不要匆忙着手设计，理解核心问题需要时间。\n', '', '2', 0, '2020-01-07 13:49:40', '2020-01-07 13:49:40', '2020-01-07 00:05:38', '<h1>明确认识</h1>\n<pre><code data-language=\"text\" class=\"lang-text\">乍一看到某个问题，你会觉得很简单，其实你并没有理解其复杂性。\n当你把问题搞清楚之后，优惠发现真的很复杂，于是你就拿出一套复杂的方案来。\n实际上，你的工作只做了一般，大多数人也都会到此为止......\n但是真正伟大的人还会继续向前，知道找到问题的关键和深层次原因，然后再拿出一个优雅的、堪称完美的有效方案。\n    -- 史蒂夫.乔布斯(摘自Steven Levy的Insanely Great:The Life and Times of Macintosh,the Computer that Changed Everything)\n</code></pre>\n<ul>\n<li>\n<p>写出自己的认识，比自己想象的时间要长。</p>\n</li>\n<li>\n<p>太早开始设计意味着会遗漏重要的见解，甚至意味着设计思路完全错误。</p>\n</li>\n<li>\n<p>花点时间理解问题，可以帮你想出更好、更简单的方案。</p>\n</li>\n<li>\n<p>不要匆忙着手设计，理解核心问题需要时间。</p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (280, 'describe-the-user-experience', 'http://47.100.57.39/static/uploads/d2/5a259cc418815a3c60e97875d547a8.jpg', 'Colborne', '描述用户体验', '# 描述用户体验\n\n* 在研究某个问题的时候，你需要把它转换成一种认识。故事是描述认识的一种好方式。与一堆需求描述相比，故事可以让读者更容易明白什么重要和为什么重要。\n\n* 故事的一些核心要点：\n  1. 应该是用三言两语把核心体验表达出来。  \n  2. 故事可以把大量信息浓缩到寥寥数语之中，效率极高，而且，故事很容易记住，很方便与人分享。  \n  3. 有必要多花点时间把故事的每一个细节都想清楚，如果你想让自己的时间简单。每个细节都至关重要。\n\n* 故事例子：对于之前提到的Flip这样的摄像机\n```text\n你站在城市街头，突然一阵骚乱；帕里斯.希尔顿(Paris Hilton)正向你走来。\n你迅速从口袋里掏出你的Flip摄像机，把它交给一位路人，请他帮忙拍一段视频，帕里斯就在你身后，\n之后，你赶紧敲开附近朋友家的门，不需要任何安装配置，就通过他的电脑将这段视频传到网上。\n```\n    \n* 这个故事告诉你如下重要事项：\n  1. 这个摄像机很小，可以方便带到任何地方。\n  2. 开机速度快（因为帕里斯不会等你），并且拍摄简单，即使第一次，见到它的人都能够拿在手里就拍。\n  3. 要上传视频不需要特殊的软件或数据线。\n  4. 最后，拍摄视频的目的是为了和朋友分享。\n\n\n* **讲故事是一个产品设计者的重要能力。“想象一下，你正在做xx事情，突然......”**\n', '', '2', 0, '2020-01-07 13:49:46', '2020-01-07 13:49:46', '2020-01-07 00:05:55', '<h1>描述用户体验</h1>\n<ul>\n<li>\n<p>在研究某个问题的时候，你需要把它转换成一种认识。故事是描述认识的一种好方式。与一堆需求描述相比，故事可以让读者更容易明白什么重要和为什么重要。</p>\n</li>\n<li>\n<p>故事的一些核心要点：</p>\n<ol>\n<li>应该是用三言两语把核心体验表达出来。</li>\n<li>故事可以把大量信息浓缩到寥寥数语之中，效率极高，而且，故事很容易记住，很方便与人分享。</li>\n<li>有必要多花点时间把故事的每一个细节都想清楚，如果你想让自己的时间简单。每个细节都至关重要。</li>\n</ol>\n</li>\n<li>\n<p>故事例子：对于之前提到的Flip这样的摄像机</p>\n</li>\n</ul>\n<pre><code data-language=\"text\" class=\"lang-text\">你站在城市街头，突然一阵骚乱；帕里斯.希尔顿(Paris Hilton)正向你走来。\n你迅速从口袋里掏出你的Flip摄像机，把它交给一位路人，请他帮忙拍一段视频，帕里斯就在你身后，\n之后，你赶紧敲开附近朋友家的门，不需要任何安装配置，就通过他的电脑将这段视频传到网上。\n</code></pre>\n<ul>\n<li>\n<p>这个故事告诉你如下重要事项：</p>\n<ol>\n<li>这个摄像机很小，可以方便带到任何地方。</li>\n<li>开机速度快（因为帕里斯不会等你），并且拍摄简单，即使第一次，见到它的人都能够拿在手里就拍。</li>\n<li>要上传视频不需要特殊的软件或数据线。</li>\n<li>最后，拍摄视频的目的是为了和朋友分享。</li>\n</ol>\n</li>\n<li>\n<p><strong>讲故事是一个产品设计者的重要能力。“想象一下，你正在做xx事情，突然......”</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (281, 'describe-two-ways', 'http://47.100.57.39/static/uploads/29/24a04e1a2500e47d0a881722b7d665.jpg', 'Colborne', '描述要点的两种方式', '# 描述要点的两种方式\n\n* 每个设计都是在考虑诸多限制之后给出的方案。最好是在设计之初就搞清楚都存在哪些限制。\n然后才能保证自己的设计能够与用户的需求紧密贴合。\n\n* **先理解用户，再思考合适的设计。**\n', '', '2', 0, '2020-01-07 13:49:53', '2020-01-07 13:49:53', '2020-01-07 00:06:08', '<h1>描述要点的两种方式</h1>\n<ul>\n<li>\n<p>每个设计都是在考虑诸多限制之后给出的方案。最好是在设计之初就搞清楚都存在哪些限制。<br>\n然后才能保证自己的设计能够与用户的需求紧密贴合。</p>\n</li>\n<li>\n<p><strong>先理解用户，再思考合适的设计。</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (282, 'designed-for-mainstream-users', 'http://47.100.57.39/static/uploads/b4/d6396ac9a72920fc80be05269529f8.jpg', 'Colborne', '为主流用户而设计', '# 为主流用户而设计\n\n\n* 福特的T型车并不是市场上第一辆汽车，但确实第一辆为平民大众制造的汽车。\n福特所有的创新（他的生产流水线、汽车定价以及容易维修的引擎设计）都源自他为主流用户制造一部简单实用的汽车的愿望。\n```text\n我们要为大多数人制造一辆汽车。这辆车......足够小，哪怕一个人也可以驾驶它、修理它。\n我们要为它设计出最简单、最先进的引擎，然后再投入生产。但这辆车的售价却非常低，不会有人因为工资不高而买不起它。\n ----亨利.福特谈T型车\n```\n\n\n* **想吸引大众，必须要关注主流。**', '', '2', 0, '2020-01-07 13:50:02', '2020-01-07 13:50:02', '2020-01-07 00:06:23', '<h1>为主流用户而设计</h1>\n<ul>\n<li>福特的T型车并不是市场上第一辆汽车，但确实第一辆为平民大众制造的汽车。<br>\n福特所有的创新（他的生产流水线、汽车定价以及容易维修的引擎设计）都源自他为主流用户制造一部简单实用的汽车的愿望。</li>\n</ul>\n<pre><code data-language=\"text\" class=\"lang-text\">我们要为大多数人制造一辆汽车。这辆车......足够小，哪怕一个人也可以驾驶它、修理它。\n我们要为它设计出最简单、最先进的引擎，然后再投入生产。但这辆车的售价却非常低，不会有人因为工资不高而买不起它。\n ----亨利.福特谈T型车\n</code></pre>\n<ul>\n<li><strong>想吸引大众，必须要关注主流。</strong></li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (283, 'easy-way', 'http://47.100.57.39/static/uploads/27/141aa83bf42f43afa9b0d8fb5cdde0.jpg', 'Colborne', '简便的方式', '# 简便的方式\n\n\n* 用简单的语言把正在设计的东西描述出来。如果自己感觉听起来不正常，或者听众们不理解我在说什么，我就知道应该修改措辞重新来过。\n\n* 目标是拿出一个简洁、清晰、完整的描述。\n\n* 如果能够只用一句简短的话来表述。如果这句话既能忽略细节而概况出主要活动，又能不让听众失去兴趣，那么就说明它一句达到简洁的标准。\n比如，对于Flip来说，就是“瞬间开始拍摄，不费吹灰之力分享”。\n\n* 想想白居易给老妪念自己写的诗的例子。\n\n* **尽可能用最简单的词汇描述你的想法**', '', '2', 0, '2020-01-07 13:50:09', '2020-01-07 13:50:09', '2020-01-07 00:06:40', '<h1>简便的方式</h1>\n<ul>\n<li>\n<p>用简单的语言把正在设计的东西描述出来。如果自己感觉听起来不正常，或者听众们不理解我在说什么，我就知道应该修改措辞重新来过。</p>\n</li>\n<li>\n<p>目标是拿出一个简洁、清晰、完整的描述。</p>\n</li>\n<li>\n<p>如果能够只用一句简短的话来表述。如果这句话既能忽略细节而概况出主要活动，又能不让听众失去兴趣，那么就说明它一句达到简洁的标准。<br>\n比如，对于Flip来说，就是“瞬间开始拍摄，不费吹灰之力分享”。</p>\n</li>\n<li>\n<p>想想白居易给老妪念自己写的诗的例子。</p>\n</li>\n<li>\n<p><strong>尽可能用最简单的词汇描述你的想法</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (284, 'emotional-needs', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'Colborne', '感情需求', '# 感情需求\n\n\n```text\n在思考为什么人们会用我们的软件这个问题时，我们意识到他们的工作日程通常都慢慢的。他们希望自己能够完成很多的工作，感觉一切尽在掌握。\n他们需要一个能够囊括上千条任务，但翻阅起来又不费事的工资表。因此，我们尽最大努力确保他们能够看到的始终都是少数重要的工作，同事也能方便找到其他的提醒或备忘。\n      ----获得2009年度最佳苹果应用奖的Things开发人员尤尔根.施魏策尔(Jvrgen Schweizer)\n```\n\n* 一个真正有用的应用不可能只是一个记事本。它还必须让用户感觉井然有序、轻松自在。\n\n* 人是有感情的动物。即使是工作表这样直观的应用，他们都希望找到一个使用它的理由。\n\n* **即使是任务列表，也要满足感情需求。**', '', '2', 0, '2020-01-07 13:50:14', '2020-01-07 13:50:14', '2020-01-07 00:06:53', '<h1>感情需求</h1>\n<pre><code data-language=\"text\" class=\"lang-text\">在思考为什么人们会用我们的软件这个问题时，我们意识到他们的工作日程通常都慢慢的。他们希望自己能够完成很多的工作，感觉一切尽在掌握。\n他们需要一个能够囊括上千条任务，但翻阅起来又不费事的工资表。因此，我们尽最大努力确保他们能够看到的始终都是少数重要的工作，同事也能方便找到其他的提醒或备忘。\n      ----获得2009年度最佳苹果应用奖的Things开发人员尤尔根.施魏策尔(Jvrgen Schweizer)\n</code></pre>\n<ul>\n<li>\n<p>一个真正有用的应用不可能只是一个记事本。它还必须让用户感觉井然有序、轻松自在。</p>\n</li>\n<li>\n<p>人是有感情的动物。即使是工作表这样直观的应用，他们都希望找到一个使用它的理由。</p>\n</li>\n<li>\n<p><strong>即使是任务列表，也要满足感情需求。</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (285, 'environments-characters-and-plot', 'http://47.100.57.39/static/uploads/16/36231773f6704edcf1f68fdd38ee49.jpg', 'Colborne', '环境、角色、情节', '# 环境、角色、情节\n\n\n >1. 可信的环境（故事中的“时间”和“地点”）\n>2. 可信的角色（“谁”和“为什么”）\n>3. 流畅的情节（“什么”和“怎么样”）\n\n* 很多复杂的设计都是因为没有考虑到线上世界的压力而导致的，或是因为设计者希望用户能够自己应付一切，或是因为他们不小心漏掉了某个重要的环境。\n\n* 你的设计应该与你讲的故事完美契合。 把你的设计放在一个情节中，情节中有可信的角色，发生在可信的环境中。\n', '', '2', 0, '2020-01-07 13:50:20', '2020-01-07 13:50:20', '2020-01-07 00:08:04', '<h1>环境、角色、情节</h1>\n<blockquote>\n<ol>\n<li>可信的环境（故事中的“时间”和“地点”）</li>\n<li>可信的角色（“谁”和“为什么”）</li>\n<li>流畅的情节（“什么”和“怎么样”）</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>很多复杂的设计都是因为没有考虑到线上世界的压力而导致的，或是因为设计者希望用户能够自己应付一切，或是因为他们不小心漏掉了某个重要的环境。</p>\n</li>\n<li>\n<p>你的设计应该与你讲的故事完美契合。 把你的设计放在一个情节中，情节中有可信的角色，发生在可信的环境中。</p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (286, 'extreme-availability', 'http://47.100.57.39/static/uploads/84/493ef6312d7fd03326c135db87b0d2.jpg', 'Colborne', '极端的可用性', '# 极端的可用性\n\n* 想要简单，务必把目标定得高些高些再高些，不要使用常规的可用性目标。 \n\n| *常规的可用性目标* | *简单性的目标* |\n| :---:| :---: |\n| 特殊人群可以使用 | 任何人都可以使用 |\n| 容易使用 | 毫不费力的使用 |\n| 快速响应 | 瞬间响应 |\n| 快速理解 | 一目了然 |\n| 工作可靠 | 始终工作 |\n| 直观的错误信息 | 不出错 |\n| 完整的信息 | 恰好够用的信息 |\n| 用户测试时工作 | 在混乱无序的环境中工作 |\n\n\n* 目标中“瞬间”和“毫不费力”听起来有点夸张，因为事实上这是做不到的。然而，争取你不可能达到的目标有一个重要的好吃：保持正确的方向。\n\n* 很多开始时简单的产品到最后都变得越来越复杂，很难使用。但是，如果你设定了一个极端的目标，你的产品就能随着时间推移越变越好（至少能够实现真正重要的目标）。\n\n* 瞄准极端的目标，即使是哪些无法完全实现的目标，也能够帮你保持产品简单。\n\n* **设计简单的体验意味着要追求极端的目标**\n# 第二段\n# 第三段', '', '2', 0, '2020-01-07 13:50:26', '2020-01-07 13:50:26', '2020-01-07 00:21:07', '<h1>极端的可用性</h1>\n<ul>\n<li>想要简单，务必把目标定得高些高些再高些，不要使用常规的可用性目标。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><em>常规的可用性目标</em></th>\n<th align=\"center\"><em>简单性的目标</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">特殊人群可以使用</td>\n<td align=\"center\">任何人都可以使用</td>\n</tr>\n<tr>\n<td align=\"center\">容易使用</td>\n<td align=\"center\">毫不费力的使用</td>\n</tr>\n<tr>\n<td align=\"center\">快速响应</td>\n<td align=\"center\">瞬间响应</td>\n</tr>\n<tr>\n<td align=\"center\">快速理解</td>\n<td align=\"center\">一目了然</td>\n</tr>\n<tr>\n<td align=\"center\">工作可靠</td>\n<td align=\"center\">始终工作</td>\n</tr>\n<tr>\n<td align=\"center\">直观的错误信息</td>\n<td align=\"center\">不出错</td>\n</tr>\n<tr>\n<td align=\"center\">完整的信息</td>\n<td align=\"center\">恰好够用的信息</td>\n</tr>\n<tr>\n<td align=\"center\">用户测试时工作</td>\n<td align=\"center\">在混乱无序的环境中工作</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>目标中“瞬间”和“毫不费力”听起来有点夸张，因为事实上这是做不到的。然而，争取你不可能达到的目标有一个重要的好吃：保持正确的方向。</p>\n</li>\n<li>\n<p>很多开始时简单的产品到最后都变得越来越复杂，很难使用。但是，如果你设定了一个极端的目标，你的产品就能随着时间推移越变越好（至少能够实现真正重要的目标）。</p>\n</li>\n<li>\n<p>瞄准极端的目标，即使是哪些无法完全实现的目标，也能够帮你保持产品简单。</p>\n</li>\n<li>\n<p><strong>设计简单的体验意味着要追求极端的目标</strong></p>\n</li>\n</ul>\n<h1>第二段</h1>\n<h1>第三段</h1>\n');
INSERT INTO `tb_article` VALUES (287, 'why-you-should-ignore-the-expert-user', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'Colborne', '为什么应该忽略专家型用户', '# 为什么应该忽略专家型用户\n\n* 专家并不是典型用户，他们不会体验到主流用户遇到的问题。他们追求主流用户根本不在乎的功能。\n\n**专家想要的功能往往会吓到主流用户。**', '', '2', 0, '2020-01-07 13:50:29', '2020-01-07 13:50:29', '2020-01-07 11:51:57', '<h1>为什么应该忽略专家型用户</h1>\n<ul>\n<li>专家并不是典型用户，他们不会体验到主流用户遇到的问题。他们追求主流用户根本不在乎的功能。</li>\n</ul>\n<p><strong>专家想要的功能往往会吓到主流用户。</strong></p>\n');
INSERT INTO `tb_article` VALUES (288, 'alita is beautiful', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'caai', 'appale is real goog', '![](http://xcoding.com:8080/static/uploads/f2/4929659b5472b48e90e0132e7c2973.jpg)\n# part1\n![tooopen_sy_210757891631.jpg](data:image/jpeg;base64,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ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoHWigdaAA0UGigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACgdaKB1oADRQaKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiux+F3w18ReOJi2nQiG0Q4e5kB259B61lWr0qEHOrKyR04TB4jGVlRw8HKT6I46ivqfwP+zNYWdqLnVrpr6ZuQrR4RfwzVzxL+zJZ6rDmyP9nyDo0Uec/UdK8N8TYBVOW7t3t/TPqlwLmvseduKl/LzK/37HyZRX0fcfsn6ogymvM5/u/Z8Efjms7UP2YdWtYCf7YaWTsEgxj6gmt1xDlr/wCXn4P/ACOT/U3OulJP/t6P+Z4DRX1z8Jf2VdOmtlbxAZLyY/f2kqo9gK9Hb9lHwZZW/nW2iK7kdZGZ8fgTXHV4qwMJNRTfnbT8zohwZi1yqvWhBvo2219ya/E/P+ivsfxr+yfZ6iSbOT+zZgeGgi+Vh7rnFcwf2PNQCn/ipXJ9fsowPrzW1PibLpRvKTT7Wf6GVbg7MoTtT5ZLupJfm0fL9FfT6fsdas+AviNuv3vsvB/Wu08IfsiaHbQBdTae/YfeZ8ruPtjpRU4my6CvGTfon+thUuD8ylK1Rxgu7kn+V2fFlFfftr+zB4O0dfNt9EDSHq0hLlfpmsTx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H50h1qL++Pzo9gu4/wCz6nY6c3HvUbz+9c5/bUX/AD0H50061F/fFNUEuo1l9Tsb8k/vUEk/vWHJrUX98VBLrUX98fnVqEFu0bwwFTsbctwfWoGuiP4qwptaix94VTn1qP8Avj86ftaMd2dlPL6j6HSSXh/vVVnu25w1c82tRnjfTW1aM/xVP1uktjqhl810Naa8cH71RC/cH71ZEuoxn+IVXkv0B+8K554xJ7nZDBNq1jovt7n+Kk+2vn71c0NTQfxClOqpj7wqfr67lf2e+x04v2A+9UM185/irmm1dP7wpU1SNv4hUvMIvS41l0lrynRRXkmfvGrKXjbfvVzI1OMfxD86X+14x/HVRx0V1FLAyf2Topr18cNVWS9c/wAVYr6tGR979ajbU0/vCpnjovqVDAyXQ15rxwPvVnXl45z8xqlNqSH+KqU98pzzXFWxia3O2jg2uhamuXyctWfe3zgH5qr3V6oB5rLvLsMTzXk18XZaM9ahhLvVEl3fSFjhjVZ9QkUfeqrNN71TnlzXj1MRLe57NLDR2sWrrVJAPvVnXGpSE/eNQ3DEmqkprzquIqPqejRw9NdB899MTwxqub6YH7xNMlPBqButcM6k77noQpQtsW11KYH7xq1b6lMR941jtTopNppRrzT3HLDwa2OgjvZSc7j+da2kX75ALVy1vMDjmtCzn2MCDXoUMTJSvc87EYaLjax3ljds6j5qvQTMG61yulXowMmt20uVYDmvpcNieZLU+YxOGcW9DoLOckDmr8bk85rBtJ1GOa07a4XA5r2qFVNani1qTTNS3kI4zV2J8isiKdfWrUNyoHWvRp1V3POqUmaQbb3pGl7Zqi92uOtRG7XP3q2ddLqYqhJ9C+xzzTHkxVT7WuPvVDNdL/erOVaK6mkaMmy3JJuqF221V+1L61FNdqR1rCVaPc3jRl2Jppfeqztnmq8t0ufvVC92v96uOdZdzshRa6E80mBVOSUlutMmuVPeq7TKOc1yVKqfU66dFroWvO2r1qrcXR3jnvVe4ugO9UXuQZBz3rkqYi2iZ2UsPfVo8dNFBor8yP1EKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA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)\n## part1-1\n\n| 1 | 1 | 1 | 1 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n\n# part2\n| 1 | 1 | 1 | 1 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n\n## part2-1\n![](http://xcoding.com:8080/static/uploads/bc/5d292e108f3e78c38f646e6fae1bc9.jpg)', 'http://baidu.com', '2', 0, '2020-01-07 22:20:42', '2020-01-07 22:20:42', '2020-01-07 21:44:19', '<p><img src=\"http://xcoding.com:8080/static/uploads/f2/4929659b5472b48e90e0132e7c2973.jpg\" alt=\"\"></p>\n<h1>part1</h1>\n<p><img src=\"data:image/jpeg;base64,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ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoHWigdaAA0UGigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACgdaKB1oADRQaKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiux+F3w18ReOJi2nQiG0Q4e5kB259B61lWr0qEHOrKyR04TB4jGVlRw8HKT6I46ivqfwP+zNYWdqLnVrpr6ZuQrR4RfwzVzxL+zJZ6rDmyP9nyDo0Uec/UdK8N8TYBVOW7t3t/TPqlwLmvseduKl/LzK/37HyZRX0fcfsn6ogymvM5/u/Z8Efjms7UP2YdWtYCf7YaWTsEgxj6gmt1xDlr/wCXn4P/ACOT/U3OulJP/t6P+Z4DRX1z8Jf2VdOmtlbxAZLyY/f2kqo9gK9Hb9lHwZZW/nW2iK7kdZGZ8fgTXHV4qwMJNRTfnbT8zohwZi1yqvWhBvo2219ya/E/P+ivsfxr+yfZ6iSbOT+zZgeGgi+Vh7rnFcwf2PNQCn/ipXJ9fsowPrzW1PibLpRvKTT7Wf6GVbg7MoTtT5ZLupJfm0fL9FfT6fsdas+AviNuv3vsvB/Wu08IfsiaHbQBdTae/YfeZ8ruPtjpRU4my6CvGTfon+thUuD8ylK1Rxgu7kn+V2fFlFfftr+zB4O0dfNt9EDSHq0hLlfpmsTx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H50h1qL++Pzo9gu4/wCz6nY6c3HvUbz+9c5/bUX/AD0H50061F/fFNUEuo1l9Tsb8k/vUEk/vWHJrUX98VBLrUX98fnVqEFu0bwwFTsbctwfWoGuiP4qwptaix94VTn1qP8Avj86ftaMd2dlPL6j6HSSXh/vVVnu25w1c82tRnjfTW1aM/xVP1uktjqhl810Naa8cH71RC/cH71ZEuoxn+IVXkv0B+8K554xJ7nZDBNq1jovt7n+Kk+2vn71c0NTQfxClOqpj7wqfr67lf2e+x04v2A+9UM185/irmm1dP7wpU1SNv4hUvMIvS41l0lrynRRXkmfvGrKXjbfvVzI1OMfxD86X+14x/HVRx0V1FLAyf2Topr18cNVWS9c/wAVYr6tGR979ajbU0/vCpnjovqVDAyXQ15rxwPvVnXl45z8xqlNqSH+KqU98pzzXFWxia3O2jg2uhamuXyctWfe3zgH5qr3V6oB5rLvLsMTzXk18XZaM9ahhLvVEl3fSFjhjVZ9QkUfeqrNN71TnlzXj1MRLe57NLDR2sWrrVJAPvVnXGpSE/eNQ3DEmqkprzquIqPqejRw9NdB899MTwxqub6YH7xNMlPBqButcM6k77noQpQtsW11KYH7xq1b6lMR941jtTopNppRrzT3HLDwa2OgjvZSc7j+da2kX75ALVy1vMDjmtCzn2MCDXoUMTJSvc87EYaLjax3ljds6j5qvQTMG61yulXowMmt20uVYDmvpcNieZLU+YxOGcW9DoLOckDmr8bk85rBtJ1GOa07a4XA5r2qFVNani1qTTNS3kI4zV2J8isiKdfWrUNyoHWvRp1V3POqUmaQbb3pGl7Zqi92uOtRG7XP3q2ddLqYqhJ9C+xzzTHkxVT7WuPvVDNdL/erOVaK6mkaMmy3JJuqF221V+1L61FNdqR1rCVaPc3jRl2Jppfeqztnmq8t0ufvVC92v96uOdZdzshRa6E80mBVOSUlutMmuVPeq7TKOc1yVKqfU66dFroWvO2r1qrcXR3jnvVe4ugO9UXuQZBz3rkqYi2iZ2UsPfVo8dNFBor8yP1EKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApQTSUUASRzOp4NWIr6Re9U6KtTktiJQjLdGkNSf1NL/aso6E1mUVft6ncj2FPsaX9qSnuacurSr0Y1l0Ue3qdw+r0uxtx67Mvc1PH4ikHVjXO0VosZWXUzlgqD+ydQvieQfxGpY/FUn98/nXJUVoswxC+0ZPLcO/snbQeLmXq5/OrsHjPHWQ155k0uT61tHN8VHZmM8nwsuh6bD42H/PX9asR+OFH/LX9a8q3N6mjc39410Rz7Frqc8uH8I+h6yPHSf8APX9aUeO0/wCev615Lub+8aN7f3jV/wCsOL7kf6uYPset/wDCdr/z1/WgeO1/56/rXku9v7x/Oje394/nR/rFjO4v9W8H2PW/+E7X/nr+tH/Cdp/z1/WvJN7f3j+dG9v7xo/1ixfcP9W8H2PW/wDhO1/56/rSf8J2v/PX9a8l3t/eP50b2/vH86P9YsZ3D/VvB9j1r/hO1/56/rSHx2n/AD1/WvJt7f3j+dJvb+8aP9YsX3D/AFbwfY9ZPjpP+ev61G/jdT/y1/WvKt7f3jS72/vGk+IMW+pS4dwi6HpsnjUH/lp+tQP4yB/5afrXnG5vU0bm9TWTzzFPqaLIsKuh6GfF/pJ+tPi8XjvJ+tec7m9TS729alZziV1KeSYZ9D01PFasP9Z+tD+JVI/1g/OvM1lcdGNO+0S/3jWizuv1M3kVC+h6FP4lC/8ALT9apTeLSDjfXENNIerGmkk96ynm9d7M2hk2HW6O2XxTuOd/61Kninb/AMtP1rhAT60bj61CzXELqW8ow76Hff8ACW8ffpp8Vbv+WlcHk+tAYjvT/tfEPqT/AGPhlsjvY/FGD9/9anTxGX6NXn6SEHrVy1uMY5rWGa13uzKplNBbI7hdaZv4j+dDaqxHBrmbacHHNXoZAe9dkMbUl1OKeCpx6Gm98796jM5PeoEwaeBV88nuyPZxWyHM5NRPTyQO9QzOPWok+5cUQzHrVSdsVLcSD1qjcS56VxVZpHbSgwkfJphNRl8HmmmQetcrkdaiOY1Gx5pS2aTGahs0SHRystWobsjqap4NJ0pxm47ClTjI2rXUjG2d1bFjrijALVxjOR3qJp3B4Y1008fUp7HLUy+nV3PS7fXUx9/9auwa+o/j/WvKEv506PUo1WcD7xrup57OJw1MghI9dj8RR4/1g/OlbxKg/wCWg/OvIDqtz2c0DVLnu5rb/WOoYf6tQPXf+EmU/wDLSg+JI8f6wfnXkR1S47Oab/adz/z0P50v9Y6g/wDVqmeuN4nQf8tP1pp8SIesn615N/adxj75pp1G5/vmk+IqhS4bpnq8niRB0k/WoH8SKf4/1ry7+0Lj++aQ385/jNZvP6jNFw9TR6a/iFMff/Wq8niAE/f/AFrzg3s5P3zSi8l/vGsnndRmscipo9D/ALdU9XpkmvJj74/OvPWu5T/GaQXMufvms3nFQtZLTO6l1oN/HVWbWVU53VyBupT/ABGmNK7HljWUszqM3hlVNDMUYooryz1gxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxRiiigAxT1yDwaKKaEyxbyuOhrQtZ5PWiiuui2cdZIvwTSY61MJpMfeoor0Yt2PMklcimmkx1qpNPJk/NRRWNRs2pJFZ5HPU1DIx9aKK5JM7IpEEjN61CWbPWiisJHTFIliYnvUyUUVUTOY8iopCaKKp7Ex3IJCfWojRRWMjpjsJijFFFQUGKMUUUAGKMUUUAGKMUUUAGKMUUUAGKMUUUAGKMUUUAGKAOaKKAP//Z\" alt=\"tooopen_sy_210757891631.jpg\"></p>\n<h2>part1-1</h2>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>1</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<h1>part2</h1>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>1</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>---</td>\n<td>---</td>\n<td>---</td>\n<td>---</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<h2>part2-1</h2>\n<p><img src=\"http://xcoding.com:8080/static/uploads/bc/5d292e108f3e78c38f646e6fae1bc9.jpg\" alt=\"\"></p>\n');
INSERT INTO `tb_article` VALUES (289, '细节决定成败', 'http://47.100.57.39/static/uploads/c5/25a4dbacc072dbc5db67555c8a86c4.jpg', 'Iron Man', '细节决定成败', '* 界面中的各种小细节会增加用户的负担，会像公路上的减速带或坑坑洼洼一样降低用户的效率。\n\n* 去掉分散注意力的视觉元素，可以容用户感觉速度更快，而且更加有安全感。\n\n*  **细节决定成败**\n\n* 界面中的各种小细节会增加用户的负担，会像公路上的减速带或坑坑洼洼一样降低用户的效率。\n\n* 去掉分散注意力的视觉元素，可以容用户感觉速度更快，而且更加有安全感。\n\n*  **细节决定成败**\n', '', '2', 0, '2020-01-07 23:11:27', '2020-01-07 23:11:27', '2020-01-07 22:44:34', '');
INSERT INTO `tb_article` VALUES (290, '避免错删', 'http://47.100.57.39/static/uploads/f2/4929659b5472b48e90e0132e7c2973.jpg', 'Jim', '避免错删', '# 避免错删\n\n* 删除功能时要避免错删，而把一切难于实现的功能统统抹杀就是典型的错误做法。例如:\n    ```\n    有一个帮助人们增强节电意识的网站,核心思想就是让人们能够在线跟踪自己的用电量，让他们知道自己习惯的微小变化会节省可观的电力。\n    \n    在进入项目设计阶段时，项目经理认为这个功能太难实现了,于是决定放弃该功能，改完发表一些有关节电的文章。网站上线后，表面上看内容十分充实，但是实际上却没有任何吸引力和原创性。最终，根本没有打动目标用户。\n    ```\n\n    这其实是一个常见的模式。交工日期迫近，预算资金紧张，都可能导致功能被砍掉。设计团队经常会以提供尽可能多的功能为目标。这些耗时而又不容易实现的功能通常会被砍掉。如果有人强烈反对，得到的答复一般是他们的功能会在“第二阶段”或“第三阶段”实现。\n\n    结果只是得到一个由简单功能叠加起来的毫无特色的产品，与市面上现有的平庸货别无二致。\n\n    这种做法会导致项目发散且没有灵魂，但它确实删除功能和内容的一种通行的做法。\n\n    删除功能和内容是谁都无法避免的。每个团队的资源都是有限的，而我所遇到的任何一个项目都面临过需要消减功能和内容的情况。有时候是因为产品经过多年的发展，功能实在太过庞杂；有时候则是一个全新的设计，但实在是需要清理。\n\n* 作为产品设计者，不要等别人不分青红皂白的、无情的删除最有意思的功能。要总览全局，保证只交付哪些真正有价值的功能和内容。\n\n* **砍掉功能有时候是一个无情的过程。**', '', '2', 0, '2020-01-07 23:11:42', '2020-01-07 23:11:42', '2020-01-07 22:46:49', '');
INSERT INTO `tb_article` VALUES (291, 'Cultured Code', 'http://47.100.57.39/static/uploads/16/36231773f6704edcf1f68fdd38ee49.jpg', 'Colborne', '不要简单地为客户要求就增加功能', '* Cultured Code的尤尔根.施魏策尔告诫我们，不要简单地为客户要求就增加功能：\n\n    > 客户向我们提出了很多功能要求，但他们从来不知道如果想到一个点子就直接放到产品中，很可能导致产品失败。在功能过多的情况下，可能会拿到一些重要功能。因此我们对添加新功能始终保持态度。\n    \n    > 我们的做法是对用户的要求做逆向工程--搞清楚用户到底遇到了什么问题，仔细斟酌这个问题是不是应该由我们的软件来解决。\n\n* 功能多了以后，通常会导致在其他某些方面做出的一些牺牲，而客户则不会考虑这方面的问题。\n\n* 增加功能不一定会让用户体验更简单，反而经常会导致更多的迷惑。\n\n* 很多时候，你都有可能拿出一个能够满足用户真正需求的替代方案。但是，不要害怕对增加产品功能的要求说不。\n\n* **要听从客户的意见，但绝不能盲从。**', '', '2', 0, '2020-01-07 23:09:06', '2020-01-07 23:09:06', '2020-01-07 22:49:15', '<ul>\n<li>\n<p>Cultured Code的尤尔根.施魏策尔告诫我们，不要简单地为客户要求就增加功能：</p>\n<blockquote>\n<p>客户向我们提出了很多功能要求，但他们从来不知道如果想到一个点子就直接放到产品中，很可能导致产品失败。在功能过多的情况下，可能会拿到一些重要功能。因此我们对添加新功能始终保持态度。</p>\n</blockquote>\n<blockquote>\n<p>我们的做法是对用户的要求做逆向工程--搞清楚用户到底遇到了什么问题，仔细斟酌这个问题是不是应该由我们的软件来解决。</p>\n</blockquote>\n</li>\n<li>\n<p>功能多了以后，通常会导致在其他某些方面做出的一些牺牲，而客户则不会考虑这方面的问题。</p>\n</li>\n<li>\n<p>增加功能不一定会让用户体验更简单，反而经常会导致更多的迷惑。</p>\n</li>\n<li>\n<p>很多时候，你都有可能拿出一个能够满足用户真正需求的替代方案。但是，不要害怕对增加产品功能的要求说不。</p>\n</li>\n<li>\n<p><strong>要听从客户的意见，但绝不能盲从。</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (292, '精简句子', 'http://47.100.57.39/static/uploads/70/48ef0bced6565f565296db75237d27.jpg', 'Colborne', '这是测试', '* 在《Revising Prose》这本书中，理查德.蓝哈姆（Richard Lanham）向我们介绍了一种把长篇大论精简为短小句子的简单方法。\n\n    1. 不使用介词（“对于/根据/为了/基于/通过/关于”）。这些词汇弱化句子的谓语，因此要尽量省略。\n    1. 不使用is的动词形式（“正在消耗时间”），尽你所能使用其他表达方式（“花时间”）\n    1. 把被动语式（“时间是被这个项目所需要的”）转换为主动句式（“这个项目需要时间”）\n    1. 删除索然无味的开头（“大家都很容易看到这一点，......”），开门见山。\n    1. 减少废话。在表达相同意思的前提下，用“每天”代替“在每天的基础上”。\n\n    上述的规则能够让文字变简洁、清晰、有说服力。例如:  \n    修改前\n    > 请注意这一点，尽管Chrome同时被Mac和Windows操作系统所支持，但为了确保您的浏览体验最佳，我们还是建议本站点的所有用户使用到目前为止最新版本的Firefox浏览器。（69个字）\n\n   修改后\n    > 为了保证最佳效果，请使用最新版的Firefox。本站也支持Mac和Windows平台下的Chrome。（31个字）\n\n\n* **几乎任何的句子都能够精简，几乎任何文字都可以删除**', '', '2', 0, '2020-01-07 23:09:12', '2020-01-07 23:09:12', '2020-01-07 22:51:19', '<ul>\n<li>\n<p>在《Revising Prose》这本书中，理查德.蓝哈姆（Richard Lanham）向我们介绍了一种把长篇大论精简为短小句子的简单方法。</p>\n<ol>\n<li>不使用介词（“对于/根据/为了/基于/通过/关于”）。这些词汇弱化句子的谓语，因此要尽量省略。</li>\n<li>不使用is的动词形式（“正在消耗时间”），尽你所能使用其他表达方式（“花时间”）</li>\n<li>把被动语式（“时间是被这个项目所需要的”）转换为主动句式（“这个项目需要时间”）</li>\n<li>删除索然无味的开头（“大家都很容易看到这一点，......”），开门见山。</li>\n<li>减少废话。在表达相同意思的前提下，用“每天”代替“在每天的基础上”。</li>\n</ol>\n<p>上述的规则能够让文字变简洁、清晰、有说服力。例如:<br>\n修改前</p>\n<blockquote>\n<p>请注意这一点，尽管Chrome同时被Mac和Windows操作系统所支持，但为了确保您的浏览体验最佳，我们还是建议本站点的所有用户使用到目前为止最新版本的Firefox浏览器。（69个字）</p>\n</blockquote>\n<p>修改后</p>\n<blockquote>\n<p>为了保证最佳效果，请使用最新版的Firefox。本站也支持Mac和Windows平台下的Chrome。（31个字）</p>\n</blockquote>\n</li>\n<li>\n<p><strong>几乎任何的句子都能够精简，几乎任何文字都可以删除</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (293, '删减过多', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'Colborne', '素质三连', '```text\n在东京的苹果专卖店，有一部引人注意的玻璃电梯，装饰着苹果独有的拉丝铝合金。这部电梯与世界上其他电梯的不同之处在于，它没有按钮：电梯外面没有呼叫电梯的按钮，电梯里也没有任何控制按钮。这台升降机在专卖店的四层楼之间上下往返运行，每个电梯都会自动停一下。\n苹果已经把这部电梯精简到了极致： 一个在不同楼层间运送顾客的平台。\n```\n\n* 然而，这部电梯并没有给人简单的感觉，而是让人觉得它神经错乱。面对这部电梯，你能感受到的只有迷惑、沮丧和无助。它在我想去的那层停不停？为什么在没人上下的楼层还要停呢？\n\n    苹果删除了一个关键的要素：**操控装置**\n\n    没有了控制感（呼叫电梯和控制电梯），没有一个活生生的人在操作（站在你前面问你去几层，然后为你按按钮），也没有了电梯工作正常的反馈（按下按钮后，它会发光），就相当于把自己完全交给这部机器去碰运气。\n\n    在没有按钮的电梯里，人们会感觉到是在浪费时间，心烦意乱。删除所有的操控装置并没有简化体验，反而让体验更复杂。\n\n    人们希望自己能够掌控全局。他们更愿意成为导航员，而不是过路人。在感觉自己在撞大运或受不可见的力量支配时，他们会非常焦急，甚至会求助某些迷信行为，让自己找到掌控全局的感觉。\n\n    > 比如，走路可以避开人行道的缝隙，或者穿上一件能带来幸运的内衣。\n\n    这里的关键在于人们能够控制结果。换句话说，足够多的控制可以让他们消除因疾病需求得不到满足而引发的焦虑，但要避免控制太多导致他们选择而浪费时间。\n\n    > 比如，让用户可以控制电梯运运行速度多块合适？电梯门打开多长时间合适？\n\n* **电梯里没有按钮，可是，人们更想当导航员，而不是过路人**', '', '2', 0, '2020-01-07 23:09:17', '2020-01-07 23:09:17', '2020-01-07 22:52:36', '<pre><code data-language=\"text\" class=\"lang-text\">在东京的苹果专卖店，有一部引人注意的玻璃电梯，装饰着苹果独有的拉丝铝合金。这部电梯与世界上其他电梯的不同之处在于，它没有按钮：电梯外面没有呼叫电梯的按钮，电梯里也没有任何控制按钮。这台升降机在专卖店的四层楼之间上下往返运行，每个电梯都会自动停一下。\n苹果已经把这部电梯精简到了极致： 一个在不同楼层间运送顾客的平台。\n</code></pre>\n<ul>\n<li>\n<p>然而，这部电梯并没有给人简单的感觉，而是让人觉得它神经错乱。面对这部电梯，你能感受到的只有迷惑、沮丧和无助。它在我想去的那层停不停？为什么在没人上下的楼层还要停呢？</p>\n<p>苹果删除了一个关键的要素：<strong>操控装置</strong></p>\n<p>没有了控制感（呼叫电梯和控制电梯），没有一个活生生的人在操作（站在你前面问你去几层，然后为你按按钮），也没有了电梯工作正常的反馈（按下按钮后，它会发光），就相当于把自己完全交给这部机器去碰运气。</p>\n<p>在没有按钮的电梯里，人们会感觉到是在浪费时间，心烦意乱。删除所有的操控装置并没有简化体验，反而让体验更复杂。</p>\n<p>人们希望自己能够掌控全局。他们更愿意成为导航员，而不是过路人。在感觉自己在撞大运或受不可见的力量支配时，他们会非常焦急，甚至会求助某些迷信行为，让自己找到掌控全局的感觉。</p>\n<blockquote>\n<p>比如，走路可以避开人行道的缝隙，或者穿上一件能带来幸运的内衣。</p>\n</blockquote>\n<p>这里的关键在于人们能够控制结果。换句话说，足够多的控制可以让他们消除因疾病需求得不到满足而引发的焦虑，但要避免控制太多导致他们选择而浪费时间。</p>\n<blockquote>\n<p>比如，让用户可以控制电梯运运行速度多块合适？电梯门打开多长时间合适？</p>\n</blockquote>\n</li>\n<li>\n<p><strong>电梯里没有按钮，可是，人们更想当导航员，而不是过路人</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (294, '决策', 'http://47.100.57.39/static/uploads/e2/0abaf19f9b9697fe01a66a14941141.jpg', 'Colborne', 'Hello World', '* 我们通常会为用户提供尽可能多的选择。但选择过多很容易让用户无所适从。\n    ```text\n    2000年，希娜.S.艾扬格博士和马克.R.莱珀博士在加利福利亚情况。门洛帕克的德尔格市场上摆了一个货摊。\n    每天有几百个人从摊位上经过。一个周末，他们在货摊上摆出了24中不同口味的果酱；另一个周末，他们只摆出6种。\n    ```\n  结果证明，提供的选择多了，销售业绩反而更差。只有2%的路人会买果酱。而在选择较少的情况下，购买果酱的比例增加到12%。\n    \n  而且，他们还发现在选择较少的情况xiangm，用户购买之后的满意度要高于选择多的情况\n\n* 给用户提供选择会让人感觉自己的把控着局面，而在某些情况下，人们更愿意少一些选择。如果选择超过了一定的界限，特别是在很多选择都相似的情况下，选择反而会变成负担。\n\n* 从人们对待技术的态度上，也可以发现类似的倾向。在面对无数的选项和按钮时，人们一般都会感觉不知所措。拿到一个复杂的小玩意之后，他们会因为看不懂、玩不转而心烦意乱，乱中反而更容易出错。太多的选择容易让人反感。\n\n  下次，当你再看到长长的功能列表，满是链接的页面，或者充斥着数不清选项的计算机菜单时，应该想到这些都是容易导致设计失败的因素。\n\n* **选择有限，用户反而更喜欢**', '', '2', 0, '2020-01-07 23:09:22', '2020-01-07 23:09:22', '2020-01-07 22:53:50', '<ul>\n<li>\n<p>我们通常会为用户提供尽可能多的选择。但选择过多很容易让用户无所适从。</p>\n<pre><code data-language=\"text\" class=\"lang-text\">2000年，希娜.S.艾扬格博士和马克.R.莱珀博士在加利福利亚情况。门洛帕克的德尔格市场上摆了一个货摊。\n每天有几百个人从摊位上经过。一个周末，他们在货摊上摆出了24中不同口味的果酱；另一个周末，他们只摆出6种。\n</code></pre>\n<p>结果证明，提供的选择多了，销售业绩反而更差。只有2%的路人会买果酱。而在选择较少的情况下，购买果酱的比例增加到12%。</p>\n<p>而且，他们还发现在选择较少的情况xiangm，用户购买之后的满意度要高于选择多的情况</p>\n</li>\n<li>\n<p>给用户提供选择会让人感觉自己的把控着局面，而在某些情况下，人们更愿意少一些选择。如果选择超过了一定的界限，特别是在很多选择都相似的情况下，选择反而会变成负担。</p>\n</li>\n<li>\n<p>从人们对待技术的态度上，也可以发现类似的倾向。在面对无数的选项和按钮时，人们一般都会感觉不知所措。拿到一个复杂的小玩意之后，他们会因为看不懂、玩不转而心烦意乱，乱中反而更容易出错。太多的选择容易让人反感。</p>\n<p>下次，当你再看到长长的功能列表，满是链接的页面，或者充斥着数不清选项的计算机菜单时，应该想到这些都是容易导致设计失败的因素。</p>\n</li>\n<li>\n<p><strong>选择有限，用户反而更喜欢</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (295, '多余的文字', 'http://47.100.57.39/static/uploads/29/24a04e1a2500e47d0a881722b7d665.jpg', 'Colborne', '双一流大学', '# 删除文字\n\n* 多余的文字通常是浪费。用户不会傻了吧唧，一字不落的看完。他们用研究扫视整个页面，只捡其中有意思的词或句子看两眼就不错了。\n\n* 删除文字有三大好处：\n\n    1. 重要的内容“水落石出”\n    1. 消除了分析满屏内容的麻烦\n    1. 读者会对自己看到了什么更有自信\n\n* 如果不知道应该删除哪些文字？可以看看下面常见的几个藏身之处。\n\n    1. 删除引见文字。通常，一打开页面，首先映入眼帘的是文章开头的那几句废话（“欢迎光临我们的网站，我们希望您心情愉快...”）。删掉这些文字，开门见山的好。\n    2. 删除不必要的说明。这一类内容是多余文字的“主力军”，通常可以“片甲不留”。删除“填写完这些字段后，请您提交按钮把申请提交给我们”。页面的标题（“申请表”）和页面的内容（表单）足以让用户明白自己该怎么做了\n    3. 删除烦琐的解释。链接下面经常会有描述和解释性文字。这些文字有时候是必要的，否则不同的人对链接指向哪儿会产生不同的理解。然而，解释性文字经常是页面冗余的又一大来源。把“产品搜索”，就能从24个字中省去20个。\n    4. 使用描述性链接。通常位于标题下面的“单击这里”或者“更多内容”链接都想说明要把读者带到哪里。把标题本身作为链接可以让页面更清爽。\n    \n    ```text\n    “把每一页中的文字删掉一般，然后把剩下的再删掉一般”  \n      -- 史蒂夫.克鲁格《点石成金》中第三条可用性法则\n    ```\n\n* **减少不必要的说明**', '', '2', 0, '2020-01-07 23:09:26', '2020-01-07 23:09:26', '2020-01-07 22:54:51', '<h1>删除文字</h1>\n<ul>\n<li>\n<p>多余的文字通常是浪费。用户不会傻了吧唧，一字不落的看完。他们用研究扫视整个页面，只捡其中有意思的词或句子看两眼就不错了。</p>\n</li>\n<li>\n<p>删除文字有三大好处：</p>\n<ol>\n<li>重要的内容“水落石出”</li>\n<li>消除了分析满屏内容的麻烦</li>\n<li>读者会对自己看到了什么更有自信</li>\n</ol>\n</li>\n<li>\n<p>如果不知道应该删除哪些文字？可以看看下面常见的几个藏身之处。</p>\n<ol>\n<li>删除引见文字。通常，一打开页面，首先映入眼帘的是文章开头的那几句废话（“欢迎光临我们的网站，我们希望您心情愉快...”）。删掉这些文字，开门见山的好。</li>\n<li>删除不必要的说明。这一类内容是多余文字的“主力军”，通常可以“片甲不留”。删除“填写完这些字段后，请您提交按钮把申请提交给我们”。页面的标题（“申请表”）和页面的内容（表单）足以让用户明白自己该怎么做了</li>\n<li>删除烦琐的解释。链接下面经常会有描述和解释性文字。这些文字有时候是必要的，否则不同的人对链接指向哪儿会产生不同的理解。然而，解释性文字经常是页面冗余的又一大来源。把“产品搜索”，就能从24个字中省去20个。</li>\n<li>使用描述性链接。通常位于标题下面的“单击这里”或者“更多内容”链接都想说明要把读者带到哪里。把标题本身作为链接可以让页面更清爽。</li>\n</ol>\n<pre><code data-language=\"text\" class=\"lang-text\">“把每一页中的文字删掉一般，然后把剩下的再删掉一般”  \n  -- 史蒂夫.克鲁格《点石成金》中第三条可用性法则\n</code></pre>\n</li>\n<li>\n<p><strong>减少不必要的说明</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (296, '用户界面', 'http://47.100.57.39/static/uploads/d2/5a259cc418815a3c60e97875d547a8.jpg', 'Colborne', '用户界面', '# 分心\n\n用户界面，尤其是网页上面，到处都是让人分心的东西。这些讨厌的细节会让哪怕阅读文章这么简单的事情都变成一场噩梦。\n\n> Safari专门推出一项功能，能够将在线文章的干扰因素一扫而空。只需点击阅读器按钮，文章将立刻连贯的显示，让你专心阅读。\n\n**如果想设计简单的用户体验，就该牢记删除那些干扰因素，让用户注意力保持集中**\n', '', '2', 0, '2020-01-07 23:16:11', '2020-01-07 23:16:11', '2020-01-07 22:55:42', '');
INSERT INTO `tb_article` VALUES (297, '简化用户体验', 'http://47.100.57.39/static/uploads/e2/0abaf19f9b9697fe01a66a14941141.jpg', 'Colborne', '消除错误的来源是简化体验的一个重要思路', '即使非常小的错误也会让用户烦恼。消除错误是简化用户体验的一个方面。\n\n> 一家网上银行设计了一个往来账户查询页面。这家银行想让这个服务吻合他们品牌的理念--友好、亲切和简单。\n> 具体来说，需要从两个下拉菜单中选择月份和年份，然后在单击“Go”按钮。听起来已经够简单了。\n\n> 但这个控件可能会导致两方面的错误。如果你选择了将来的日期，就会有一条错误提示，意思就是说“你很白痴”。如果你选择了一个一年前的日期，同样会看到一条提示消息，告诉你再试一次，因为银行只提供12月以内的对账单。\n\n> 用户很容易在这个控件上选错，无论显示什么错误消息，好像都没有那么友好、亲切和简单。\n\n实际上用户只需要从过去的12个月的对账单中进行选择，可却在要求他们输入日期。因此，将两个日期控件改成一个可用银行对账单的下拉列表。\n\n在重新的设计的控件里，用户只能选择可用的对账单，因此都不用再实际错误消息了。这样，系统维护起来自然也会更简单。\n\n用户在纠正错误的时候，总会分散一部分注意力，而且感觉上是遇到了麻烦。为了避免发生错误，设计者经常会打断用户--“你确定要这样做吗？”但从某种角度来说，这种方式很差劲的。因为这样会干扰所有人，即使人家的选择没有错也不能幸免。\n\n在实际简单的体验时，关键的一步是确定哪些地方需要错误消息，或者检查错误日志，从中找出常见的错误信息。\n', '', '2', 0, '2020-01-08 17:05:37', '2020-01-08 17:05:37', '2020-01-07 22:57:14', '<p>即使非常小的错误也会让用户烦恼。消除错误是简化用户体验的一个方面。</p>\n<blockquote>\n<p>一家网上银行设计了一个往来账户查询页面。这家银行想让这个服务吻合他们品牌的理念--友好、亲切和简单。<br>\n具体来说，需要从两个下拉菜单中选择月份和年份，然后在单击“Go”按钮。听起来已经够简单了。</p>\n</blockquote>\n<blockquote>\n<p>但这个控件可能会导致两方面的错误。如果你选择了将来的日期，就会有一条错误提示，意思就是说“你很白痴”。如果你选择了一个一年前的日期，同样会看到一条提示消息，告诉你再试一次，因为银行只提供12月以内的对账单。</p>\n</blockquote>\n<blockquote>\n<p>用户很容易在这个控件上选错，无论显示什么错误消息，好像都没有那么友好、亲切和简单。</p>\n</blockquote>\n<p>实际上用户只需要从过去的12个月的对账单中进行选择，可却在要求他们输入日期。因此，将两个日期控件改成一个可用银行对账单的下拉列表。</p>\n<p>在重新的设计的控件里，用户只能选择可用的对账单，因此都不用再实际错误消息了。这样，系统维护起来自然也会更简单。</p>\n<p>用户在纠正错误的时候，总会分散一部分注意力，而且感觉上是遇到了麻烦。为了避免发生错误，设计者经常会打断用户--“你确定要这样做吗？”但从某种角度来说，这种方式很差劲的。因为这样会干扰所有人，即使人家的选择没有错也不能幸免。</p>\n<p>在实际简单的体验时，关键的一步是确定哪些地方需要错误消息，或者检查错误日志，从中找出常见的错误信息。</p>\n');
INSERT INTO `tb_article` VALUES (298, '焦点', 'http://47.100.57.39/static/uploads/84/493ef6312d7fd03326c135db87b0d2.jpg', 'Colborne', '焦点', '# 焦点\n\n“删除”策略的核心就是干掉哪些分散注意力的因素，聚焦于项目。\n\n1. 聚焦于对用户有价值的功能。这意味着专注于那些承载用户核心体验的功能，也意味着交付的功能必须能够消除用户的挫折感，能够消除他们的焦虑\n1. 聚焦于可用资源，通过删除残缺的功能、不切题的元素和花里胡哨的东西为用户提供价值。\n1. 聚焦于达成用户的目标。纠结于流程会陷入细节的泥潭而无法自拔。\n1. 删除那些干扰性的、添加用户负担的“减速带”：错误消息、不知所云的文字、不必要的选项和造成视觉混乱的元素。\n\n有了耐心，再加上数据支持，你就可以为自己的大多数项目找到焦点。如果你面临的是人的问题，那么可以通过阶段性的步步为营或者通过测试获得的证据来解决。如果你的问题是技术过时或者系统不兼容，那么问题会随着时间推移而（缓慢）变化。\n\n例外:\n\n1. 一个不可避免的法律要件，必须包含特定的内容或信息。\n1. 不能脱离环境删除某些功能。\n\n**删除混乱的要素可以让用户聚焦于真正重要的功能。**\n', '', '2', 0, '2020-01-07 23:15:21', '2020-01-07 23:15:21', '2020-01-07 22:58:34', '');
INSERT INTO `tb_article` VALUES (299, '向用户提供选择', 'http://47.100.57.39/static/uploads/c5/25a4dbacc072dbc5db67555c8a86c4.jpg', 'Colborne', '向用户提供选择', '# 如果一个选项还嫌多\n\n* 有时候，即使一个选项都嫌多。\n\n* 在向用户提供选择是，务必要考虑周全一些，想清楚用户会不会因为这些选项而不知所措，或者这些选项会不会动摇他们的决心。\n\n     大部分的电商网站，他们在结账这个环节中，删除了其他页面顶部和底部都有导航链接。\n\n    电商网站这样做的目的是，在结账的时候，用户必须做出决断：买，还是走人。所有可能影响用户决定选项都会被移除。\n\n* **主流用户希望 “够了就行了，快点”，而专家则希望 “尽可能的完美，等多长时间都愿意” 。**\n\n* 如果你设计受主流用户喜爱的简单体验，就问问自己，**向用户提供这些选项会不会因为追求完美而牺牲速度和简单**。如果是，则删除那些选项。\n', '', '2', 0, '2020-01-07 23:15:52', '2020-01-07 23:15:52', '2020-01-07 22:59:15', '');
INSERT INTO `tb_article` VALUES (300, '增加功能有害无益', 'http://47.100.57.39/static/uploads/29/24a04e1a2500e47d0a881722b7d665.jpg', 'Colborne', '增加功能有害无益', '* 设计一款引人注意的产品，删除功能表面上回冒一定的风险，但是却能获得长期的收益。\n\n    经过研究：产品的功能多会对没有机会试用的消费者更有吸引力。但是在消费者使用了产品之后，他们的偏好就会改变。一下子从重视功能，变成更重视可用性。\n\n* 在今天，口碑、用户评论、个人推荐以及产品试用的重要性已经远远超过了大众媒体广告。消费者在选择产品之前，都要听一听用户的意见，他是意见对产品的可用性有了了解的人。因此，痛下决心，砍掉不必要的功能，要强于无意义的堆砌功能。\n\n* 你设计的产品如果承载了过多的功能，更有可能降低主流用户的满意度，从而对产品的长期盈利能力造成损害。\n\n* **长远来看，增加功能有害无益。**', '', '2', 0, '2020-01-07 23:15:11', '2020-01-07 23:15:11', '2020-01-07 23:00:24', '');
INSERT INTO `tb_article` VALUES (301, '求全的心理', 'http://47.100.57.39/static/uploads/d2/5a259cc418815a3c60e97875d547a8.jpg', 'Colborne', '求全的心理', '# 假如用户......\n\n* 要是你经历过委员会主导的设计，那么肯定知道没有一项功能可以被确定是不需要的。\n\n* “假如用户想......”意味着任何待删功能都可以安然无恙回到产品中。如果所有功能都必须通过“假如......”测试，那你制定删除计划花费的心事也就只能无端打水漂了。\n就像一个要远行的人，“假如......”会让你把所有可能用到的东西统统塞入你的包里，最终你会不堪重负。\n\n* 人们求全的心理，担心自己会漏掉什么需求。为了寄托这份担忧，就要有人付出时间、精力和金钱增加新功能了。\n\n* 如果你发现自己（或别人）说：“假如用户需要......”那么只有一个答案：**搞清楚这个功能对用户是否真的重要**。\n\n    问一问：“我的目标用户经常会遇到这个问题吗？”如果答案是“几乎没有遇到过。”，那么请放弃这个想法，继续前进吧。\n\n* 不要再“假如”了，还是去发现问题吧。\n\n* **不要猜测用户可能会或者可能不会怎么样。**', '', '2', 0, '2020-01-07 23:17:15', '2020-01-07 23:17:15', '2020-01-07 23:01:08', '');
INSERT INTO `tb_article` VALUES (302, '体会过环境', 'http://47.100.57.39/static/uploads/15/7814b7d1ed76cbcc8038098a0c0910.jpg', 'Colborne', '收到货物起飞', '# 砍掉残缺功能\n\n* 删掉实现的不够理想的功能也是很重要的。\n\n* 有人可能会说，删除部网站的功能或内容会导致已经付出的时间和努力白白的浪费。一样东西，不管它有多么差，只要是花钱买的，没有谁愿意把它白白扔掉。经济学上把这种现象称为“沉没成本误区”。事实上，用于创建这部分功能的成本是不可能收回来了，因此判断这种功能的唯一方式就是看它能够发挥几分作用，保留它会额外导致多少成本。\n\n* 所以，我们该思考的绝不是“为什么应该去掉它”，而是“为什么要留着它”。\n\n* 以“去掉它们是一种浪费”作为理由而抓住残缺的功能不放，可能会妨碍你成功。\n\n* **人们都舍不得扔东西，即使它已经破烂不堪。**', '', '2', 0, '2020-01-07 23:10:00', '2020-01-07 23:10:00', '2020-01-07 23:01:52', '<h1>砍掉残缺功能</h1>\n<ul>\n<li>\n<p>删掉实现的不够理想的功能也是很重要的。</p>\n</li>\n<li>\n<p>有人可能会说，删除部网站的功能或内容会导致已经付出的时间和努力白白的浪费。一样东西，不管它有多么差，只要是花钱买的，没有谁愿意把它白白扔掉。经济学上把这种现象称为“沉没成本误区”。事实上，用于创建这部分功能的成本是不可能收回来了，因此判断这种功能的唯一方式就是看它能够发挥几分作用，保留它会额外导致多少成本。</p>\n</li>\n<li>\n<p>所以，我们该思考的绝不是“为什么应该去掉它”，而是“为什么要留着它”。</p>\n</li>\n<li>\n<p>以“去掉它们是一种浪费”作为理由而抓住残缺的功能不放，可能会妨碍你成功。</p>\n</li>\n<li>\n<p><strong>人们都舍不得扔东西，即使它已经破烂不堪。</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (303, '选项和首选项', 'http://47.100.57.39/static/uploads/f2/4929659b5472b48e90e0132e7c2973.jpg', 'Colborne', '选项和首选项', '# 选项和首选项\n\n* 在选择想要删除的东西吗？就从选项和首选项开始吧。\n\n* 通常，选项是让用户来自定义设置的。可以说，这是典型的专家行为--专家想要掌握自己的汽车，并且选择很多个性的配置。主流用户只想买辆车开开。\n\n* 我发现，在设计团队模棱两可的时候，选项和首选项比较容易泛滥。\n\n     网站导航设计一般有两种形式：面包屑和下拉菜单。这两种形式都不错，干脆都加上吧。这样可以让用户多一种选择。\n\n     这个决定听起来还蛮像那么回事。但是，难道要然给用户浪费时间来回答“哪种导航形式最方便”这个问题吗？这种做法对简单产品的追求相差十万八千里。\n\n* 简单的用户体验不会强迫用户去做这种选择，哪种方式最有效应该是设计团队考虑的问题。解决这个问题的最佳途径就是请一些用户来测试。如果测试结果是两种方式不分伯仲，都没有明显的缺陷，就意味着没有“错误”的设计。赶紧选择一种方式来实现，然后继续。\n\n* **主流用户不喜欢为设置选项和首选项费心劳神。**', '', '2', 0, '2020-01-07 23:14:41', '2020-01-07 23:14:41', '2020-01-07 23:02:44', '');
INSERT INTO `tb_article` VALUES (304, '方案，不是流程', 'http://47.100.57.39/static/uploads/bc/5d292e108f3e78c38f646e6fae1bc9.jpg', 'Colborne', '方案，不是流程', '# 方案，不是流程\n\n举个例子：\n\n### 目的：\n\n> 银行希望加一项功能，允许客户把他们的存款账号分为可以命名的“存钱罐”（如“节日”，“燃气”，等等）。 这样通过明确存款的目的，可以让客户更加积极踊跃地存储。\n\n### 最初的解决方案：\n\n> 开始设计存款流程的时候，事情一下机会变得复杂起来，比如说，客户在账户中存钱时，他得先存上钱，然后再把这笔钱划到某个“罐”里--原来的一步变成两步。如果有人在存款时不知道系统支持“存钱罐”功能，那么存入的钱必须保存到账户中的“日常存钱罐”中。\n> \n> 在从账户中转账的时候，问题就变得复杂了。用户必须要选择从哪个“罐”里提钱。如果客户从某个“罐”中提钱太多，即使其他“罐”里还有钱，也可能会被拒付。\n\n**导致一大堆非正常的操作和细节的功能。 这应该是所有产品设计者应该长鸣的警钟。**\n\n### 最终的解决方案：\n\n> 后来我们认识到，允许客户命名他们的存款账户就能达到命名“存钱罐”的效果。\n> \n> 如果客户想换一个“存钱罐”，只要再开一个新户就行了。甚至从一开始就给他们两到三个账号，并建议他们为这些账号分别起不同的名字。\n> \n> 从实现、解释和支持“存钱罐”的投入来看，还是让客户命名账户更快捷、更节省成本。\n\n* **关键是客户更容易理解**\n\n* 如果在设计的时候只盯住流程，那么结果很可能会创造更多的功能去处理出现的各种异常情况、问题和细节。想要避免这些复杂性，退一步想，把注意力集中到客户的目的上面，问自己“还有其他解决方式吗？”\n\n* #### **如果一个小的变化导致了复杂的流程，就应该退一步去寻找更好的解决方案。**', '', '2', 0, '2020-01-08 16:29:09', '2020-01-08 16:29:09', '2020-01-07 23:03:48', '');
INSERT INTO `tb_article` VALUES (305, '删除或省略功能可以创造出成功的产品', 'http://47.100.57.39/static/uploads/e2/0abaf19f9b9697fe01a66a14941141.jpg', 'Colborne', '删除或省略功能可以创造出成功的产品', '# 第4章 删除\n\n* 传统的观点认为，功能越多，能力就越强，产品的用途就越广。\n\n*   不过美国专门从事跟踪IT项目成功或失败的权威机构Standish Group在2002年发表了一份研究报告，称64%的软件功能“从未使用或极少使用”。\n\n* **删除或省略功能可以创造出成功的产品。**\n\n    1. Tumblr的博客服务只有WordPress或Blogger等站点的一部分功能，但在开通3年后，博客日发表量超过了200万份。\n    2. 莲花爱丽丝（Elise）最开始的定位是一款返璞归真的跑车，没有空调系统，一年只生产800部。15年后，这款车仍然在生产，而且已经卖出几万部。\n    3. iPhone刚刚发布的时候，与诺基亚和RIM（黑莓手机制造商）的同类手机相比只有很少的功能，但却引起了轰动。\n    4. Basecamp是有37Signals开发的一个项目管理平台，只有Microsoft SharePoint功能的几分之一，但《商业杂志》对它的描述确实“好用的让人着迷”，在全世界拥有几百万用户。\n\n* 上面说的这些例子更注重功能的深度，而不是广度。它们广受好评是因为它们做的事情虽少，但却比竞争产品做的更好。\n\n* 删除杂乱的特性可以让设计师专注于把有些的重要问题解决好。而且也有助于用户心无旁骛的完成自己的目标。\n\n* **简化设计最明显的方式就是删除不必要的功能。**', '', '2', 0, '2020-01-08 16:29:27', '2020-01-08 16:29:27', '2020-01-07 23:04:33', '');
INSERT INTO `tb_article` VALUES (306, '真有影响吗', 'http://47.100.57.39/static/uploads/d2/5a259cc418815a3c60e97875d547a8.jpg', 'Colborne', '真有影响吗', '# 真有影响吗\n\n* 某项功能一旦发布，就一定会有人在某个地方使用它。如果用户喜欢它，就会改变自己的行为来适应这项功能。当用户离不开这项功能时，你再把它砍掉，即使是一个很不起眼的变化，都会激怒用户。\n\n    不过，有些依赖性还是比较容易消除的。对于用户来说，真正重要的是什么？是你的设计能不能解决他的大问题。如果能，那么他就会顺从你，即使你的改变会让他不舒服。\n\n* 判断删除功能对于用户的影响有多大是一件需要技巧的事情。\n\n* 如果你简单的去询问用户“你愿意我们删除这个功能吗？”。答案永远只有一个“不！”谁也不愿意被拿走什么。即使这个功能是他从来没有用过的。\n\n     功能这个词要比实际的用户更吸引人\n\n    如果涉及一个给销售人员来管理自己潜在客户的手机应用，那么去掉更换背景的功能就不会有什么影响，因为更换背景并非核心任务。\n\n* 如果想要去掉的功能与应用的核心功能沾边，那么事情就没有那么简单了。最好的办法，是先做一个模型出来让人们试用一下，才能知道他们真正关心的是什么。\n\n* 想在任何时候取悦所有用户都是不可能的。因此，我们只能退而求其次，专注于目标客户的核心任务，只有让他们高兴、让他们满意就行了。\n\n* **删除一项功能，对于不同的用户影响不同。**', '', '2', 0, '2020-01-08 16:28:25', '2020-01-08 16:28:25', '2020-01-07 23:05:04', '');
INSERT INTO `tb_article` VALUES (307, '关注核心', 'http://47.100.57.39/static/uploads/29/24a04e1a2500e47d0a881722b7d665.jpg', 'Colborne', '关注核心', '# 关注核心\n\n* **增加价值始于改进核心体验。**\n\n* 在按照优先级对功能排序时，要时刻记住用户认为那些关系到他们日常使用体验的功能最有价值。以此为起点，可以开始编写你的用户故事。\n\n    另外，能够消除他们挫折感的功能同样也会受到欢迎。在描述用户故事时，别忘了寻找常见的挫折和难题。\n\n* **搞清楚产品核心竞争力，说明白需求优先级**，对于一个合格的产品设计者来说，这都是基本能力。\n\n* **与新增功能相比，客户更关注于基本功能的改进。**', '', '2', 0, '2020-01-08 16:28:36', '2020-01-08 16:28:36', '2020-01-07 23:05:40', '');
INSERT INTO `tb_article` VALUES (308, '聪明的默认值', 'http://47.100.57.39/static/uploads/b4/d6396ac9a72920fc80be05269529f8.jpg', 'Colborne', '闪电风暴并提出V千万别聚家分店', '\n\n* 选择聪明的默认值可以减少用户的选择。\n\n* 有的人可能会修改默认值，但提供默认值总是比提供一张空表要好。无论如何，这样的做法可以节省客户的时间。\n\n* 聪明的默认值指的是适合大多数人口味的选择。通过分析客户信息（比如日志文件），可以找到很多选择默认值的依据。\n\n    1. 热门文档（“头条新闻”）\n    2. 类似项（“浏览过这个产品的用户还看过......”）\n    3. 个性化信息（“使用你的地址自动填写表单”）\n    4. 共同的选择（把“中国”放在国家列表的最前面，如果你的大多数客户都来自中国国内的话）\n\n* 还应该记住一点，当一个客户再次光顾网站或营业，他通常原因以前次离开的状态作为起点。\n\n    1. 最近保存的文档（“打开‘欢迎您.doc’”）\n    2. 恢复状态（“继续从游戏的第三关开始玩起”）\n\n    许多实用旅游类网站的用户都抱怨，他们每次访问统一网站都要重新输入一遍相同的信息。\n    但是记住这些用户过去的旅游路线、乘坐的航班以及下榻的酒店真的很难吗？\n\n* 默认值是节省用户时间和精力的有效方式，也是清除设计蓝图中“减速带”的首选方式。\n\n* **雷克萨斯汽车网站的默认比较项大多数情况下，对于大多数客户都是有用的。**', '', '2', 0, '2020-01-07 23:13:30', '2020-01-07 23:13:30', '2020-01-07 23:06:39', '<ul>\n<li>\n<p>选择聪明的默认值可以减少用户的选择。</p>\n</li>\n<li>\n<p>有的人可能会修改默认值，但提供默认值总是比提供一张空表要好。无论如何，这样的做法可以节省客户的时间。</p>\n</li>\n<li>\n<p>聪明的默认值指的是适合大多数人口味的选择。通过分析客户信息（比如日志文件），可以找到很多选择默认值的依据。</p>\n<ol>\n<li>热门文档（“头条新闻”）</li>\n<li>类似项（“浏览过这个产品的用户还看过......”）</li>\n<li>个性化信息（“使用你的地址自动填写表单”）</li>\n<li>共同的选择（把“中国”放在国家列表的最前面，如果你的大多数客户都来自中国国内的话）</li>\n</ol>\n</li>\n<li>\n<p>还应该记住一点，当一个客户再次光顾网站或营业，他通常原因以前次离开的状态作为起点。</p>\n<ol>\n<li>最近保存的文档（“打开‘欢迎您.doc’”）</li>\n<li>恢复状态（“继续从游戏的第三关开始玩起”）</li>\n</ol>\n<p>许多实用旅游类网站的用户都抱怨，他们每次访问统一网站都要重新输入一遍相同的信息。<br>\n但是记住这些用户过去的旅游路线、乘坐的航班以及下榻的酒店真的很难吗？</p>\n</li>\n<li>\n<p>默认值是节省用户时间和精力的有效方式，也是清除设计蓝图中“减速带”的首选方式。</p>\n</li>\n<li>\n<p><strong>雷克萨斯汽车网站的默认比较项大多数情况下，对于大多数客户都是有用的。</strong></p>\n</li>\n</ul>\n');
INSERT INTO `tb_article` VALUES (309, '排定功能优先级', 'http://47.100.57.39/static/uploads/27/141aa83bf42f43afa9b0d8fb5cdde0.jpg', 'Colborne', '在确定什么功能该保留，什么功能该删除的时候', '# 排定功能优先级\n\n* 在确定什么功能该保留，什么功能该删除的时候，遵循如下原则：\n\n    1. 确定用户想要达到的目的，并排定优先次序。\n        比如DVD来说，主要目的是看DVD，其次是使用DVD的附加功能，还有一个不那么重要的目标是播放其他媒体，比如CD、MP3等。\n    \n    2. 专注于寻找能够完全满足优先级最高的用户需求的解决方案。找到之后再考虑满足用户的其他目标。\n    \n    3. 确定用户在受用产品过程中的最常见的干扰源，并将接近这些问题的功能按难易程度排出优先级次序。\n         例如看电视的时候，突然来个电话就是一个干扰，而遥控器上的暂停按键就是把这种干扰降到最低程度的一个解决方案。\n    \n    4. 要知道能够满足主流用户的“足够好”的产品和只有专家才能看上眼的“精确的”产品有什么区别。\n\n* 不要以功能的多寡来认定产品的价值，应该看用户是否满足用户最高优先级的目标。\n\n* **给那些轻易能够满足主流用户需求的功能排定优先次序**', '', '2', 0, '2020-01-08 16:30:56', '2020-01-08 16:30:56', '2020-01-07 23:07:19', '');
INSERT INTO `tb_article` VALUES (310, ' 视觉混乱', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'Colborne', '删除视觉混乱的元素意味着人们必须处理的信息就变少了，能够把注意力集中到真正重要的内容上。', '# 视觉混乱\n\n* 删除视觉混乱的元素意味着人们必须处理的信息就变少了，能够把注意力集中到真正重要的内容上。\n\n     用户所说的“干净”的界面，意思就是其中没有杂乱的元素\n\n* 界面中的像素不应该浪费在那些不是内容或者重复的内容上。\n\n* **删除混乱元素很简单。观察方案中的每一个元素，想一想为什么需要它。它能够提供重要的信息，还是能够提供支持？先把它从方案中删掉。如果方案中没有它不行，再把它拿回来。**\n\n* 以下是一些减少视觉混乱的方法：\n\n    1. 使用空白或轻微的背景色来划分页面，而不要使用线条。为什么？因为线条在前景中，而空白和颜色在背景上，前景就会更多地吸引人的注意力。\n    1. 尽可能少用强调。如果仅加粗就行了，就不必又加粗、又放大、又变红色。\n    1. 别使用黑粗线，匀称、浅色的线更好。\n    1. 控制信息的层次。如果页面中信息的层次超过了两到三个层次，就会导致用户迷惑。比如说，要少用数字、大字体或粗体字。最好总共不超过三个层次：标题、子标题和正文。\n    1. 减少元素大小的变化。例如，如果你再设计某个报纸的电子版，可能会有一大块放置头条新闻，另有5小块放置次要一些的新闻，千万不要让版面上出现大小都不同的6个区块。\n    1. 减少元素形状的变化。整个界面中最好只使用一种按钮样式，使用三或四种按钮样式就太花哨了。\n\n* 按照上面的方法来来看，你会发现原来可以从界面中清理掉的混乱因素真是太多了\n', '', '2', 0, '2020-01-08 16:30:40', '2020-01-08 16:30:40', '2020-01-07 23:07:48', '');
INSERT INTO `tb_article` VALUES (311, '你能做到', 'http://47.100.57.39/static/uploads/16/36231773f6704edcf1f68fdd38ee49.jpg', 'Colborne', '奥数GV发', '# 你能做到\n\n* 一个大型组织的团队，能不能重新设计他们的网站，说服干系人删除内容和功能？\n\n* 简单的设计通常出自一位眼光独到的设计师、一位“无情的”或“毫不妥协的”创新者之手。但是，我们大多数所在的组织中，妥协和让步已经成为常态。\n\n* 在共同愿景的基础上，在关注主流用户的前提下，通过彻底重新设计是可以达到简约之效的。\n', '', '2', 0, '2020-01-07 23:14:12', '2020-01-07 23:14:12', '2020-01-07 23:08:26', '');
INSERT INTO `tb_article` VALUES (312, 'Spring基础', 'http://47.100.57.39/static/uploads/84/493ef6312d7fd03326c135db87b0d2.jpg', 'seaswalker', 'spring基本配置和分析', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [基本](#%E5%9F%BA%E6%9C%AC)\n  - [ClassPathXmlApplicationContext](#classpathxmlapplicationcontext)\n    - [构造器](#%E6%9E%84%E9%80%A0%E5%99%A8)\n    - [设置配置文件路径](#%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84)\n      - [Environment接口](#environment%E6%8E%A5%E5%8F%A3)\n        - [Profile](#profile)\n        - [Property](#property)\n      - [Environment构造器](#environment%E6%9E%84%E9%80%A0%E5%99%A8)\n        - [PropertySources接口](#propertysources%E6%8E%A5%E5%8F%A3)\n        - [PropertySource接口](#propertysource%E6%8E%A5%E5%8F%A3)\n      - [路径Placeholder处理](#%E8%B7%AF%E5%BE%84placeholder%E5%A4%84%E7%90%86)\n        - [PropertyResolver接口](#propertyresolver%E6%8E%A5%E5%8F%A3)\n        - [解析](#%E8%A7%A3%E6%9E%90)\n  - [refresh](#refresh)\n    - [prepareRefresh](#preparerefresh)\n      - [属性校验](#%E5%B1%9E%E6%80%A7%E6%A0%A1%E9%AA%8C)\n    - [BeanFactory创建](#beanfactory%E5%88%9B%E5%BB%BA)\n      - [BeanFactory接口](#beanfactory%E6%8E%A5%E5%8F%A3)\n      - [BeanFactory定制](#beanfactory%E5%AE%9A%E5%88%B6)\n      - [Bean加载](#bean%E5%8A%A0%E8%BD%BD)\n        - [EntityResolver](#entityresolver)\n        - [BeanDefinitionReader](#beandefinitionreader)\n        - [路径解析(Ant)](#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90ant)\n        - [配置文件加载](#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD)\n        - [Bean解析](#bean%E8%A7%A3%E6%9E%90)\n      - [默认命名空间解析](#%E9%BB%98%E8%AE%A4%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90)\n        - [import](#import)\n        - [alias](#alias)\n        - [bean](#bean)\n          - [id & name处理](#id--name%E5%A4%84%E7%90%86)\n          - [beanName生成](#beanname%E7%94%9F%E6%88%90)\n          - [bean解析](#bean%E8%A7%A3%E6%9E%90)\n          - [Bean装饰](#bean%E8%A3%85%E9%A5%B0)\n          - [Bean注册](#bean%E6%B3%A8%E5%86%8C)\n          - [BeanDefiniton数据结构](#beandefiniton%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n        - [beans](#beans)\n      - [其它命名空间解析](#%E5%85%B6%E5%AE%83%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90)\n        - [NamespaceHandler继承体系](#namespacehandler%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB)\n        - [init](#init)\n        - [BeanFactory数据结构](#beanfactory%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n    - [prepareBeanFactory](#preparebeanfactory)\n      - [BeanExpressionResolver](#beanexpressionresolver)\n      - [PropertyEditorRegistrar](#propertyeditorregistrar)\n      - [环境注入](#%E7%8E%AF%E5%A2%83%E6%B3%A8%E5%85%A5)\n      - [依赖解析忽略](#%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90%E5%BF%BD%E7%95%A5)\n      - [bean伪装](#bean%E4%BC%AA%E8%A3%85)\n      - [LoadTimeWeaver](#loadtimeweaver)\n      - [注册环境](#%E6%B3%A8%E5%86%8C%E7%8E%AF%E5%A2%83)\n    - [postProcessBeanFactory](#postprocessbeanfactory)\n    - [invokeBeanFactoryPostProcessors](#invokebeanfactorypostprocessors)\n    - [BeanPostProcessor注册](#beanpostprocessor%E6%B3%A8%E5%86%8C)\n    - [MessageSource](#messagesource)\n    - [事件驱动](#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8)\n      - [事件](#%E4%BA%8B%E4%BB%B6)\n      - [发布者](#%E5%8F%91%E5%B8%83%E8%80%85)\n        - [ApplicationEventPublisher](#applicationeventpublisher)\n        - [ApplicationEventMulticaster](#applicationeventmulticaster)\n      - [监听器](#%E7%9B%91%E5%90%AC%E5%99%A8)\n      - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96)\n      - [事件发布](#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83)\n        - [监听器获取](#%E7%9B%91%E5%90%AC%E5%99%A8%E8%8E%B7%E5%8F%96)\n        - [同步/异步](#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)\n          - [全局](#%E5%85%A8%E5%B1%80)\n          - [注解](#%E6%B3%A8%E8%A7%A3)\n    - [onRefresh](#onrefresh)\n    - [ApplicationListener注册](#applicationlistener%E6%B3%A8%E5%86%8C)\n    - [singleton初始化](#singleton%E5%88%9D%E5%A7%8B%E5%8C%96)\n      - [ConversionService](#conversionservice)\n      - [StringValueResolver](#stringvalueresolver)\n      - [LoadTimeWeaverAware](#loadtimeweaveraware)\n      - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96-1)\n- [getBean](#getbean)\n  - [beanName转化](#beanname%E8%BD%AC%E5%8C%96)\n  - [手动注册bean检测](#%E6%89%8B%E5%8A%A8%E6%B3%A8%E5%86%8Cbean%E6%A3%80%E6%B5%8B)\n  - [检查父容器](#%E6%A3%80%E6%9F%A5%E7%88%B6%E5%AE%B9%E5%99%A8)\n  - [依赖初始化](#%E4%BE%9D%E8%B5%96%E5%88%9D%E5%A7%8B%E5%8C%96)\n  - [Singleton初始化](#singleton%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [getSingleton方法](#getsingleton%E6%96%B9%E6%B3%95)\n      - [是否存在](#%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8)\n      - [bean创建](#bean%E5%88%9B%E5%BB%BA)\n        - [lookup-method检测](#lookup-method%E6%A3%80%E6%B5%8B)\n        - [InstantiationAwareBeanPostProcessor触发](#instantiationawarebeanpostprocessor%E8%A7%A6%E5%8F%91)\n        - [doCreateBean](#docreatebean)\n          - [创建(createBeanInstance)](#%E5%88%9B%E5%BB%BAcreatebeaninstance)\n          - [MergedBeanDefinitionPostProcessor](#mergedbeandefinitionpostprocessor)\n          - [属性解析](#%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90)\n          - [属性设置](#%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE)\n          - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96-2)\n    - [getObjectForBeanInstance](#getobjectforbeaninstance)\n  - [Prototype初始化](#prototype%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [beforePrototypeCreation](#beforeprototypecreation)\n    - [createBean](#createbean)\n    - [afterPrototypeCreation](#afterprototypecreation)\n    - [总结](#%E6%80%BB%E7%BB%93)\n  - [其它Scope初始化](#%E5%85%B6%E5%AE%83scope%E5%88%9D%E5%A7%8B%E5%8C%96)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 基本\n\n本部分从最基本的Spring开始。配置文件:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>    \n<beans>    \n    <bean class=\"base.SimpleBean\"></bean>\n</beans>\n```\n\n启动代码:\n\n```java\npublic static void main(String[] args) {\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n    SimpleBean bean = context.getBean(SimpleBean.class);\n    bean.send();\n    context.close();\n}\n```\n\nSimpleBean:\n\n```java\npublic class SimpleBean {\n    public void send() {\n        System.out.println(\"I am send method from SimpleBean!\");\n    }\n}\n```\n\n## ClassPathXmlApplicationContext\n\n整个继承体系如下:\n\n![ResourceLoader继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ResourceLoader.jpg)\n\nResourceLoader代表了**加载资源的一种方式，正是策略模式的实现**。\n\n构造器源码:\n\n```java\npublic ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext 	         parent) {\n    //null\n    super(parent);\n    setConfigLocations(configLocations);\n    //默认true\n    if (refresh) {\n        refresh();\n    }\n}\n```\n\n### 构造器\n\n首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:\n\n```java\npublic AbstractApplicationContext(ApplicationContext parent) {\n    this();\n    setParent(parent);\n}\npublic AbstractApplicationContext() {\n    this.resourcePatternResolver = getResourcePatternResolver();\n}\n```\n\ngetResourcePatternResolver:\n\n```java\nprotected ResourcePatternResolver getResourcePatternResolver() {\n    return new PathMatchingResourcePatternResolver(this);\n}\n```\n\nPathMatchingResourcePatternResolver支持Ant风格的路径解析。\n\n### 设置配置文件路径\n\n即AbstractRefreshableConfigApplicationContext.setConfigLocations:\n\n```java\npublic void setConfigLocations(String... locations) {\n    if (locations != null) {\n        Assert.noNullElements(locations, \"Config locations must not be null\");\n        this.configLocations = new String[locations.length];\n        for (int i = 0; i < locations.length; i++) {\n            this.configLocations[i] = resolvePath(locations[i]).trim();\n        }\n    } else {\n        this.configLocations = null;\n    }\n}\n```\n\nresolvePath:\n\n```java\nprotected String resolvePath(String path) {\n    return getEnvironment().resolveRequiredPlaceholders(path);\n}\n```\n\n此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: `new ClassPathXmlApplicationContext(\"classpath:config.xml\");`那么classpath:就是需要被解析的。\n\ngetEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:\n\n```java\nprotected ConfigurableEnvironment createEnvironment() {\n    return new StandardEnvironment();\n}\n```\n\n#### Environment接口\n\n继承体系:\n\n![Environment继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Environment.jpg)\n\nEnvironmen接口**代表了当前应用所处的环境。**从此接口的方法可以看出，其主要和profile、Property相关。\n\n##### Profile\n\nSpring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。**Spring容器管理的所有bean都是和一个profile绑定在一起的。**使用了Profile的配置文件示例:\n\n```xml\n<beans profile=\"develop\">  \n    <context:property-placeholder location=\"classpath*:jdbc-develop.properties\"/>  \n</beans>  \n<beans profile=\"production\">  \n    <context:property-placeholder location=\"classpath*:jdbc-production.properties\"/>  \n</beans>  \n<beans profile=\"test\">  \n    <context:property-placeholder location=\"classpath*:jdbc-test.properties\"/>  \n</beans>\n```\n\n在启动代码中可以用如下代码设置活跃(当前使用的)Profile:\n\n```java\ncontext.getEnvironment().setActiveProfiles(\"dev\");\n```\n\n当然使用的方式还有很多(比如注解)，参考:\n\n[spring3.1 profile 配置不同的环境](http://radiumxie.iteye.com/blog/1851919)\n\n[Spring Profiles example](http://www.mkyong.com/spring/spring-profiles-example/)\n\n##### Property\n\n这里的Property指的是程序运行时的一些参数，引用注释:\n\n> > properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.\n\n#### Environment构造器\n\n```java\nprivate final MutablePropertySources propertySources = new MutablePropertySources(this.logger);\npublic AbstractEnvironment() {\n    customizePropertySources(this.propertySources);\n}\n```\n\n#####  PropertySources接口\n\n继承体系:\n\n![PropertySources继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertySources.jpg)\n\n此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。\n\nStandardEnvironment.customizePropertySources:\n\n```java\n/** System environment property source name: {@value} */\npublic static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = \"systemEnvironment\";\n/** JVM system properties property source name: {@value} */\npublic static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = \"systemProperties\";\n@Override\nprotected void customizePropertySources(MutablePropertySources propertySources) {\n    propertySources.addLast(new MapPropertySource\n        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));\n    propertySources.addLast(new SystemEnvironmentPropertySource\n        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));\n}\n```\n\n##### PropertySource接口\n\nPropertySource接口代表了键值对的Property来源。继承体系：\n\n![PropertySource继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertySource.jpg)\n\nAbstractEnvironment.getSystemProperties:\n\n```java\n@Override\npublic Map<String, Object> getSystemProperties() {\n    try {\n        return (Map) System.getProperties();\n    }\n    catch (AccessControlException ex) {\n        return (Map) new ReadOnlySystemAttributesMap() {\n            @Override\n            protected String getSystemAttribute(String attributeName) {\n                try {\n                    return System.getProperty(attributeName);\n                }\n                catch (AccessControlException ex) {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(format(\"Caught AccessControlException when accessing system \" +\n                                \"property [%s]; its value will be returned [null]. Reason: %s\",\n                                attributeName, ex.getMessage()));\n                    }\n                    return null;\n                }\n            }\n        };\n    }\n}\n```\n\n这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。\n\ngetSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。\n\n#### 路径Placeholder处理\n\nAbstractEnvironment.resolveRequiredPlaceholders:\n\n```java\n@Override\npublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n    //text即配置文件路径，比如classpath:config.xml\n    return this.propertyResolver.resolveRequiredPlaceholders(text);\n}\n```\n\npropertyResolver是一个PropertySourcesPropertyResolver对象:\n\n```java\nprivate final ConfigurablePropertyResolver propertyResolver =\n            new PropertySourcesPropertyResolver(this.propertySources);\n```\n\n##### PropertyResolver接口\n\nPropertyResolver继承体系(排除Environment分支):\n\n![PropertyResolver继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertyResolver.jpg)\n\n此接口正是用来解析PropertyResource。\n\n##### 解析\n\nAbstractPropertyResolver.resolveRequiredPlaceholders:\n\n```java\n@Override\npublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n    if (this.strictHelper == null) {\n        this.strictHelper = createPlaceholderHelper(false);\n    }\n    return doResolvePlaceholders(text, this.strictHelper);\n}\n```\n\n```java\nprivate PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) {\n    //三个参数分别是${, }, :\n    return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix,\n        this.valueSeparator, ignoreUnresolvablePlaceholders);\n}\n```\n\ndoResolvePlaceholders：\n\n```java\nprivate String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {\n    //PlaceholderResolver接口依然是策略模式的体现\n    return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() {\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            return getPropertyAsRawString(placeholderName);\n        }\n    });\n}\n```\n\n其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:\n\n```java\nSystem.setProperty(\"spring\", \"classpath\");\nClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"${spring}:config.xml\");\nSimpleBean bean = context.getBean(SimpleBean.class);\n```\n\n这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:\n\n```java\n@Override\nprotected String getPropertyAsRawString(String key) {\n    return getProperty(key, String.class, false);\n}\nprotected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {\n    if (this.propertySources != null) {\n        for (PropertySource<?> propertySource : this.propertySources) {\n            Object value = propertySource.getProperty(key);\n            return value;\n        }\n    }\n    return null;\n}\n```\n\n很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。\n\n注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。\n\n## refresh\n\nSpring bean解析就在此方法，所以单独提出来。\n\nAbstractApplicationContext.refresh:\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n        // Tell the subclass to refresh the internal bean factory.\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        // Prepare the bean factory for use in this context.\n        prepareBeanFactory(beanFactory);\n        try {\n            // Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n            // Invoke factory processors registered as beans in the context.\n            invokeBeanFactoryPostProcessors(beanFactory);\n            // Register bean processors that intercept bean creation.\n            registerBeanPostProcessors(beanFactory);\n            // Initialize message source for this context.\n            initMessageSource();\n            // Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n            // Initialize other special beans in specific context subclasses.\n            onRefresh();\n            // Check for listener beans and register them.\n            registerListeners();\n            // Instantiate all remaining (non-lazy-init) singletons.\n            finishBeanFactoryInitialization(beanFactory);\n            // Last step: publish corresponding event.\n            finishRefresh();\n        } catch (BeansException ex) {\n            // Destroy already created singletons to avoid dangling resources.\n            destroyBeans();\n            // Reset \'active\' flag.\n            cancelRefresh(ex);\n            // Propagate exception to caller.\n            throw ex;\n        } finally {\n            // Reset common introspection caches in Spring\'s core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n### prepareRefresh\n\n```java\nprotected void prepareRefresh() {\n    this.startupDate = System.currentTimeMillis();\n    this.closed.set(false);\n    this.active.set(true);\n    // Initialize any placeholder property sources in the context environment\n    //空实现\n    initPropertySources();\n    // Validate that all properties marked as required are resolvable\n    // see ConfigurablePropertyResolver#setRequiredProperties\n    getEnvironment().validateRequiredProperties();\n    // Allow for the collection of early ApplicationEvents,\n    // to be published once the multicaster is available...\n    this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();\n}\n```\n\n#### 属性校验\n\nAbstractEnvironment.validateRequiredProperties:\n\n```java\n@Override\npublic void validateRequiredProperties() throws MissingRequiredPropertiesException {\n    this.propertyResolver.validateRequiredProperties();\n}\n```\n\nAbstractPropertyResolver.validateRequiredProperties:\n\n```java\n@Override\npublic void validateRequiredProperties() {\n    MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();\n    for (String key : this.requiredProperties) {\n        if (this.getProperty(key) == null) {\n            ex.addMissingRequiredProperty(key);\n        }\n    }\n    if (!ex.getMissingRequiredProperties().isEmpty()) {\n        throw ex;\n    }\n}\n```\n\nrequiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。\n\n### BeanFactory创建\n\n由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory:\n\n```java\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n    //如果已经存在，那么销毁之前的\n    if (hasBeanFactory()) {\n        destroyBeans();\n        closeBeanFactory();\n    }\n    //创建了一个DefaultListableBeanFactory对象\n    DefaultListableBeanFactory beanFactory = createBeanFactory();\n    beanFactory.setSerializationId(getId());\n    customizeBeanFactory(beanFactory);\n    loadBeanDefinitions(beanFactory);\n    synchronized (this.beanFactoryMonitor) {\n        this.beanFactory = beanFactory;\n    }\n}\n```\n\n#### BeanFactory接口\n\n此接口实际上就是Bean容器，其继承体系:\n\n![BeanFactory继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanFactory.jpg)\n\n#### BeanFactory定制\n\nAbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现:\n\n```java\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n    if (this.allowBeanDefinitionOverriding != null) {\n        //默认false，不允许覆盖\n        beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.allowCircularReferences != null) {\n        //默认false，不允许循环引用\n        beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n    }\n}\n```\n\n#### Bean加载\n\nAbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了:\n\n```java\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) {\n    // Create a new XmlBeanDefinitionReader for the given BeanFactory.\n    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n    // Configure the bean definition reader with this context\'s\n    // resource loading environment.\n    beanDefinitionReader.setEnvironment(this.getEnvironment());\n    beanDefinitionReader.setResourceLoader(this);\n    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n    // Allow a subclass to provide custom initialization of the reader,\n    // then proceed with actually loading the bean definitions.\n    //默认空实现\n    initBeanDefinitionReader(beanDefinitionReader);\n    loadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n##### EntityResolver\n\n此处只说明用到的部分继承体系:\n\n![EntityResolver继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EntityResolver.jpg)\n\nEntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。\n\n##### BeanDefinitionReader\n\n继承体系:\n\n![BeanDefinitionReader继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanDefinitionReader.jpg)\n\n\n\n##### 路径解析(Ant)\n\n```java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) {\n    Resource[] configResources = getConfigResources();\n    if (configResources != null) {\n        reader.loadBeanDefinitions(configResources);\n    }\n    String[] configLocations = getConfigLocations();\n    //here\n    if (configLocations != null) {\n        reader.loadBeanDefinitions(configLocations);\n    }\n}\n```\n\nAbstractBeanDefinitionReader.loadBeanDefinitions:\n\n```java\n@Override\npublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {\n    Assert.notNull(locations, \"Location array must not be null\");\n    int counter = 0;\n    for (String location : locations) {\n        counter += loadBeanDefinitions(location);\n    }\n    return counter;\n}\n```\n\n之后调用:\n\n```java\n//第二个参数为空\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) {\n    ResourceLoader resourceLoader = getResourceLoader();\n    //参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口\n    if (resourceLoader instanceof ResourcePatternResolver) {\n        // Resource pattern matching available.\n        try {\n            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n            int loadCount = loadBeanDefinitions(resources);\n            if (actualResources != null) {\n                for (Resource resource : resources) {\n                    actualResources.add(resource);\n                }\n            }\n            return loadCount;\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n        }\n    }\n    else {\n        // Can only load single resources by absolute URL.\n        Resource resource = resourceLoader.getResource(location);\n        int loadCount = loadBeanDefinitions(resource);\n        if (actualResources != null) {\n            actualResources.add(resource);\n        }\n        return loadCount;\n    }\n}\n```\n\ngetResource的实现在AbstractApplicationContext：\n\n```java\n@Override\npublic Resource[] getResources(String locationPattern) throws IOException {\n    //构造器中初始化，PathMatchingResourcePatternResolver对象\n    return this.resourcePatternResolver.getResources(locationPattern);\n}\n```\n\nPathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。\n\n```java\n@Override\npublic Resource[] getResources(String locationPattern) throws IOException {\n    Assert.notNull(locationPattern, \"Location pattern must not be null\");\n    //classpath:\n    if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n        // a class path resource (multiple resources for same name possible)\n        //matcher是一个AntPathMatcher对象\n        if (getPathMatcher().isPattern(locationPattern\n            .substring(CLASSPATH_ALL_URL_PREFIX.length()))) {\n            // a class path resource pattern\n            return findPathMatchingResources(locationPattern);\n        } else {\n            // all class path resources with the given name\n            return findAllClassPathResources(locationPattern\n                .substring(CLASSPATH_ALL_URL_PREFIX.length()));\n        }\n    } else {\n        // Only look for a pattern after a prefix here\n        // (to not get fooled by a pattern symbol in a strange prefix).\n        int prefixEnd = locationPattern.indexOf(\":\") + 1;\n        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n            // a file pattern\n            return findPathMatchingResources(locationPattern);\n        }\n        else {\n            // a single resource with the given name\n            return new Resource[] {getResourceLoader().getResource(locationPattern)};\n        }\n    }\n}\n```\n\nisPattern:\n\n```java\n@Override\npublic boolean isPattern(String path) {\n    return (path.indexOf(\'*\') != -1 || path.indexOf(\'?\') != -1);\n}\n```\n\n可以看出配置文件路径是支持ant风格的，也就是可以这么写:\n\n```java\nnew ClassPathXmlApplicationContext(\"con*.xml\");\n```\n\n具体怎么解析ant风格的就不写了。\n\n##### 配置文件加载\n\n入口方法在AbstractBeanDefinitionReader的217行:\n\n```java\n//加载\nResource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n//解析\nint loadCount = loadBeanDefinitions(resources);\n```\n\n最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法:\n\n```java\n@Override\npublic int loadBeanDefinitions(Resource resource) {\n    return loadBeanDefinitions(new EncodedResource(resource));\n}\n```\n\nResource是代表一种资源的接口，其类图:\n\n![Resource类图](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Resource.jpg)\n\nEncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。\n\n之后关键的源码只有两行:\n\n```java\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n    InputStream inputStream = encodedResource.getResource().getInputStream();\n    InputSource inputSource = new InputSource(inputStream);\n    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n}\n```\n\nInputSource是org.xml.sax的类。\n\ndoLoadBeanDefinitions：\n\n```java\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) {\n    Document doc = doLoadDocument(inputSource, resource);\n    return registerBeanDefinitions(doc, resource);\n}\n```\n\ndoLoadDocument:\n\n```java\nprotected Document doLoadDocument(InputSource inputSource, Resource resource) {\n    return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,\n        getValidationModeForResource(resource), isNamespaceAware());\n}\n```\n\ndocumentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。\n\n校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。\n\nNamespaceAware默认false，因为默认配置了校验为true。\n\nDefaultDocumentLoader.loadDocument:\n\n```java\n@Override\npublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver,\n    ErrorHandler errorHandler, int validationMode, boolean namespaceAware) {\n    //这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存\n    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);\n    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);\n    return builder.parse(inputSource);\n}\n```\n\ncreateDocumentBuilderFactory比较有意思:\n\n```java\nprotected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware{\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    factory.setNamespaceAware(namespaceAware);\n    if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {\n        //此方法设为true仅对dtd有效，xsd(schema)无效\n        factory.setValidating(true);\n        if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {\n            // Enforce namespace aware for XSD...\n             //开启xsd(schema)支持\n            factory.setNamespaceAware(true);\n             //这个也是Java支持Schema的套路，可以问度娘\n            factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);\n        }\n    }\n    return factory;\n}\n```\n\n##### Bean解析\n\nXmlBeanDefinitionReader.registerBeanDefinitions:\n\n```java\npublic int registerBeanDefinitions(Document doc, Resource resource) {\n    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n    int countBefore = getRegistry().getBeanDefinitionCount();\n    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n    return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n```\n\ncreateBeanDefinitionDocumentReader:\n\n```java\nprotected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {\n    return BeanDefinitionDocumentReader.class.cast\n      //反射\n      (BeanUtils.instantiateClass(this.documentReaderClass));\n}\n```\n\ndocumentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。\n\n注意cast方法，代替了强转。\n\ncreateReaderContext：\n\n```java\npublic XmlReaderContext createReaderContext(Resource resource) {\n    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n        this.sourceExtractor, this, getNamespaceHandlerResolver());\n}\n```\n\nproblemReporter是一个FailFastProblemReporter对象。\n\neventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。\n\nsourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。\n\ngetNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。\n\nXmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。\n\nDefaultBeanDefinitionDocumentReader.registerBeanDefinitions:\n\n```java\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n    this.readerContext = readerContext;\n    Element root = doc.getDocumentElement();\n    doRegisterBeanDefinitions(root);\n}\n```\n\ndoRegisterBeanDefinitions:\n\n```java\nprotected void doRegisterBeanDefinitions(Element root) {\n    BeanDefinitionParserDelegate parent = this.delegate;\n    this.delegate = createDelegate(getReaderContext(), root, parent);\n    //默认的命名空间即\n    //http://www.springframework.org/schema/beans\n    if (this.delegate.isDefaultNamespace(root)) {\n        //检查profile属性\n        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n        if (StringUtils.hasText(profileSpec)) {\n            //profile属性可以以,分割\n            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n                return;\n            }\n        }\n    }\n    preProcessXml(root);\n    parseBeanDefinitions(root, this.delegate);\n    postProcessXml(root);\n    this.delegate = parent;\n}\n```\n\ndelegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>    \n<beans>    \n    <bean class=\"base.SimpleBean\"></bean>\n    <beans>\n        <bean class=\"java.lang.Object\"></bean>\n    </beans>\n</beans>\n```\n\nxml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>    \n<beans xmlns=\"http://www.springframework.org/schema/beans\"></beans>\n```\n\nxmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于http://www.springframework.org/schema/beans:bean，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。\n\n注意一下profile的检查, AbstractEnvironment.acceptsProfiles:\n\n```java\n@Override\npublic boolean acceptsProfiles(String... profiles) {\n    Assert.notEmpty(profiles, \"Must specify at least one profile\");\n    for (String profile : profiles) {\n        if (StringUtils.hasLength(profile) && profile.charAt(0) == \'!\') {\n            if (!isProfileActive(profile.substring(1))) {\n                return true;\n            }\n        } else if (isProfileActive(profile)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原理很简单，注意从源码可以看出，**profile属性支持!取反**。\n\npreProcessXml方法是个空实现，供子类去覆盖，**目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会**, 想的真周到。\n\nDefaultBeanDefinitionDocumentReader.parseBeanDefinitions：\n\n```java\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n    if (delegate.isDefaultNamespace(root)) {\n        NodeList nl = root.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (node instanceof Element) {\n                Element ele = (Element) node;\n                if (delegate.isDefaultNamespace(ele)) {\n                    parseDefaultElement(ele, delegate);\n                } else {\n                    delegate.parseCustomElement(ele);\n                }\n            }\n        }\n    } else {\n        delegate.parseCustomElement(root);\n    }\n}\n```\n\n可见，对于非默认命名空间的元素交由delegate处理。\n\n#### 默认命名空间解析\n\n即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement:\n\n```java\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n    //\"import\"\n    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n        importBeanDefinitionResource(ele);\n    }\n    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n        processAliasRegistration(ele);\n    }\n    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n        processBeanDefinition(ele, delegate);\n    }\n    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n        // recurse\n        doRegisterBeanDefinitions(ele);\n    }\n}\n```\n\n##### import\n\n写法示例:\n\n```xml\n<import resource=\"CTIContext.xml\" />\n<import resource=\"customerContext.xml\" />\n```\n\nimportBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。\n\n##### alias\n\n加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义:\n\n```xml\n<alias name=\"componentA-dataSource\" alias=\"componentB-dataSource\"/>\n```\n\nprocessAliasRegistration核心源码:\n\n```java\nprotected void processAliasRegistration(Element ele) {\n    String name = ele.getAttribute(NAME_ATTRIBUTE);\n    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);\n    getReaderContext().getRegistry().registerAlias(name, alias);\n    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));\n}\n```\n\n从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry:\n\n```java\n@Override\npublic void registerAlias(String name, String alias) {\n    Assert.hasText(name, \"\'name\' must not be empty\");\n    Assert.hasText(alias, \"\'alias\' must not be empty\");\n    //名字和别名一样\n    if (alias.equals(name)) {\n        //ConcurrentHashMap\n        this.aliasMap.remove(alias);\n    } else {\n        String registeredName = this.aliasMap.get(alias);\n        if (registeredName != null) {\n            if (registeredName.equals(name)) {\n                // An existing alias - no need to re-register\n                return;\n            }\n            if (!allowAliasOverriding()) {\n                throw new IllegalStateException\n                    (\"Cannot register alias \'\" + alias + \"\' for name \'\" +\n                    name + \"\': It is already registered for name \'\" + registeredName + \"\'.\");\n            }\n        }\n        checkForAliasCircle(name, alias);\n        this.aliasMap.put(alias, name);\n    }\n}\n```\n\n所以别名关系的保存使用Map完成，key为别名，value为本来的名字。\n\n##### bean\n\nbean节点是Spring最最常见的节点了。\n\nDefaultBeanDefinitionDocumentReader.processBeanDefinition:\n\n```java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n    if (bdHolder != null) {\n        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n        try {\n            // Register the final decorated instance.\n            BeanDefinitionReaderUtils.registerBeanDefinition\n                (bdHolder, getReaderContext().getRegistry());\n        }\n        catch (BeanDefinitionStoreException ex) {\n            getReaderContext().error(\"Failed to register bean definition with name \'\" +\n                    bdHolder.getBeanName() + \"\'\", ele, ex);\n        }\n        // Send registration event.\n        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n    }\n}\n```\n\n###### id & name处理\n\n最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。\n\n首先获取到id和name属性，**name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做**。\n\n```java\nString id = ele.getAttribute(ID_ATTRIBUTE);\nString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\nList<String> aliases = new ArrayList<String>();\nif (StringUtils.hasLength(nameAttr)) {\n    //按,分隔\n    String[] nameArr = StringUtils.tokenizeToStringArray\n        (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n    aliases.addAll(Arrays.asList(nameArr));\n}\nString beanName = id;\nif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n    //name的第一个值作为id\n    beanName = aliases.remove(0);\n}\n//默认null\nif (containingBean == null) {\n    //校验id是否已重复，如果重复直接抛异常\n    //校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set\n    checkNameUniqueness(beanName, aliases, ele);\n}\n```\n\n###### beanName生成\n\n如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement:\n\n```java\nbeanName = this.readerContext.generateBeanName(beanDefinition);\nString beanClassName = beanDefinition.getBeanClassName();\naliases.add(beanClassName);\n```\n\n可见，Spring同时会把类名作为其别名。\n\n最终调用的是BeanDefinitionReaderUtils.generateBeanName:\n\n```java\npublic static String generateBeanName(\n        BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) {\n    String generatedBeanName = definition.getBeanClassName();\n    if (generatedBeanName == null) {\n        if (definition.getParentName() != null) {\n            generatedBeanName = definition.getParentName() + \"$child\";\n             //工厂方法产生的bean\n        } else if (definition.getFactoryBeanName() != null) {\n            generatedBeanName = definition.getFactoryBeanName() + \"$created\";\n        }\n    }\n    String id = generatedBeanName;\n    if (isInnerBean) {\n        // Inner bean: generate identity hashcode suffix.\n        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + \n            ObjectUtils.getIdentityHexString(definition);\n    } else {\n        // Top-level bean: use plain class name.\n        // Increase counter until the id is unique.\n        int counter = -1;\n         //用类名#自增的数字命名\n        while (counter == -1 || registry.containsBeanDefinition(id)) {\n            counter++;\n            id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter;\n        }\n    }\n    return id;\n}\n```\n\n###### bean解析\n\n还是分部分说明(parseBeanDefinitionElement)。\n\n首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。\n\n```java\nString className = null;\nif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n}\nString parent = null;\nif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n    parent = ele.getAttribute(PARENT_ATTRIBUTE);\n}\nAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n```\n\nBeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition:\n\n```java\npublic static AbstractBeanDefinition createBeanDefinition(\n        String parentName, String className, ClassLoader classLoader) {\n    GenericBeanDefinition bd = new GenericBeanDefinition();\n    bd.setParentName(parentName);\n    if (className != null) {\n        if (classLoader != null) {\n            bd.setBeanClass(ClassUtils.forName(className, classLoader));\n        }\n        else {\n            bd.setBeanClassName(className);\n        }\n    }\n    return bd;\n}\n```\n\n之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中:\n\n```java\nparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n```\n\n之后解析bean的decription子元素:\n\n```xml\n<bean id=\"b\" name=\"one, two\" class=\"base.SimpleBean\">\n    <description>SimpleBean</description>\n</bean>\n```\n\n就仅仅是个描述。\n\n然后是meta子元素的解析，meta元素在xml配置文件里是这样的:\n\n```xml\n<bean id=\"b\" name=\"one, two\" class=\"base.SimpleBean\">\n    <meta key=\"name\" value=\"skywalker\"/>\n</bean>\n```\n\n注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码:\n\n```java\npublic void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {\n    NodeList nl = ele.getChildNodes();\n    for (int i = 0; i < nl.getLength(); i++) {\n        Node node = nl.item(i);\n        if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n            Element metaElement = (Element) node;\n            String key = metaElement.getAttribute(KEY_ATTRIBUTE);\n            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n             //就是一个key, value的载体，无他\n            BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);\n             //sourceExtractor默认是NullSourceExtractor，返回的是空\n            attribute.setSource(extractSource(metaElement));\n            attributeAccessor.addMetadataAttribute(attribute);\n        }\n    }\n}\n```\n\nAbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。\n\nlookup-method解析：\n\n此标签的作用在于当一个bean的某个方法被设置为lookup-method后，**每次调用此方法时，都会返回一个新的指定bean的对象**。用法示例:\n\n```xml\n<bean id=\"apple\" class=\"cn.com.willchen.test.di.Apple\" scope=\"prototype\"/>\n<!--水果盘-->\n<bean id=\"fruitPlate\" class=\"cn.com.willchen.test.di.FruitPlate\">\n    <lookup-method name=\"getFruit\" bean=\"apple\"/>\n</bean>\n```\n\n数据保存在Set中，对应的类是MethodOverrides。可以参考:\n\n[Spring - lookup-method方式实现依赖注入](http://www.cnblogs.com/ViviChan/p/4981619.html)\n\nreplace-mothod解析:\n\n此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。\n\n配置文件示例:\n\n```xml\n<bean name=\"replacer\" class=\"springroad.deomo.chap4.MethodReplace\" />  \n<bean name=\"testBean\" class=\"springroad.deomo.chap4.LookupMethodBean\">\n    <replaced-method name=\"test\" replacer=\"replacer\">\n        <arg-type match=\"String\" />\n    </replaced-method>  \n</bean> \n```\n\narg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: [SPRING.NET 1.3.2 学习20--方法注入之替换方法注入](http://blog.csdn.net/lee576/article/details/8725548)\n\n解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList<String>专门用于保存arg-type。\n\n构造参数(constructor-arg)解析:\n\n作用一目了然，使用示例:\n\n```xml\n<bean class=\"base.SimpleBean\">\n    <constructor-arg>\n        <value type=\"java.lang.String\">Cat</value>\n    </constructor-arg>\n</bean>\n```\n\ntype一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map<Integer, ValueHolder>的形式保存，反之，以List<ValueHolder>的形式保存。\n\nproperty解析:\n\n非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例:\n\n```xml\n<bean class=\"base.SimpleBean\">\n    <property name=\"name\" value=\"skywalker\" />\n</bean>\n```\n\nvalue和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。\n\nqualifier解析:\n\n配置示例:\n\n```xml\n<bean class=\"base.Student\">\n    <property name=\"name\" value=\"skywalker\"></property>\n    <property name=\"age\" value=\"12\"></property>\n    <qualifier type=\"org.springframework.beans.factory.annotation.Qualifier\" value=\"student\" />\n</bean>	\n<bean class=\"base.Student\">\n    <property name=\"name\" value=\"seaswalker\"></property>\n    <property name=\"age\" value=\"15\"></property>\n    <qualifier value=\"student_2\"></qualifier>\n</bean>\n<bean class=\"base.SimpleBean\" />\n```\n\nSimpleBean部分源码:\n\n```java\n@Autowired\n@Qualifier(\"student\")\nprivate Student student;\n```\n\n此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如:\n\n```xml\n<qualifier type=\"org.springframework.beans.factory.annotation.Qualifier\" value=\"student\">\n    <attribute key=\"id\" value=\"1\"/>\n</qualifier>\n```\n\n貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。\n\n###### Bean装饰\n\n这部分是针对其它schema的属性以及子节点，比如:\n\n```xml\n<bean class=\"base.Student\" primary=\"true\">\n    <context:property-override />\n</bean>\n```\n\n没见过这种用法，留个坑。\n\n###### Bean注册\n\nBeanDefinitionReaderUtils.registerBeanDefinition:\n\n```java\npublic static void registerBeanDefinition(\n    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n    // Register bean definition under primary name.\n    String beanName = definitionHolder.getBeanName();\n    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n    // Register aliases for bean name, if any.\n    String[] aliases = definitionHolder.getAliases();\n    if (aliases != null) {\n        for (String alias : aliases) {\n            registry.registerAlias(beanName, alias);\n        }\n    }\n}\n```\n\nregistry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事:\n\n```java\n@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) {\n    this.beanDefinitionMap.put(beanName, beanDefinition);\n    this.beanDefinitionNames.add(beanName);\n}\n```\n\n一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。\n\nComponentRegistered事件触发:\n\n默认是个空实现，前面说过了。\n\n###### BeanDefiniton数据结构\n\nBeanDefiniton数据结构如下图:\n\n![BeanDefinition数据结构](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanDefinition.jpg)\n\n##### beans\n\nbeans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。\n\n#### 其它命名空间解析\n\n入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions->BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空):\n\n```java\npublic BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {\n    String namespaceUri = getNamespaceURI(ele);\n    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n}\n```\n\nNamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。\n\n其resolve方法:\n\n```java\n@Override\npublic NamespaceHandler resolve(String namespaceUri) {\n    Map<String, Object> handlerMappings = getHandlerMappings();\n    Object handlerOrClassName = handlerMappings.get(namespaceUri);\n    if (handlerOrClassName == null) {\n        return null;\n    } else if (handlerOrClassName instanceof NamespaceHandler) {\n        return (NamespaceHandler) handlerOrClassName;\n    } else {\n        String className = (String) handlerOrClassName;\n        Class<?> handlerClass = ClassUtils.forName(className, this.classLoader);\n        NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n        namespaceHandler.init();\n        handlerMappings.put(namespaceUri, namespaceHandler);\n        return namespaceHandler;\n    }\n}\n```\n\n容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是**NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回**。\n\nNamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例:\n\n```html\nhttp\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler\nhttp\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler\nhttp\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler\nhttp\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler\nhttp\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler\n```\n\n##### NamespaceHandler继承体系\n\n![NamespaceHandler继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/NamespaceHandler.jpg)\n\n##### init\n\nresolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。**此接口用以解析顶层(beans下)的非默认命名空间元素，比如`<context:annotation-config />`**。\n\n所以这样逻辑就很容易理解了: **每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程**。\n\n此部分较为重要，所以重新开始大纲。 \n\n##### BeanFactory数据结构\n\nBeanDefinition在BeanFactory中的主要数据结构如下图:\n\n![Beanfactory数据结构](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Beanfactory_structure.jpg)\n\n### prepareBeanFactory\n\n此方法负责对BeanFactory进行一些特征的设置工作，\"特征\"包含这么几个方面:\n\n#### BeanExpressionResolver\n\n此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法:\n\n```java\nObject evaluate(String value, BeanExpressionContext evalContext)\n```\n\nprepareBeanFactory将一个此对象放入BeanFactory:\n\n```java\nbeanFactory.setBeanExpressionResolver(new 						 			StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n```\n\nStandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图:\n\n![ExpressionParser继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ExpressionParser.jpg)\n\n这便是Spring3.0开始出现的Spel表达式的解释器。\n\n#### PropertyEditorRegistrar\n\n此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法:\n\n```java\nregisterCustomEditors(PropertyEditorRegistry registry)\n```\n\n实现也只有一个: ResourceEditorRegistrar。\n\n在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。\n\nprepareBeanFactory:\n\n```java\nbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n```\n\nBeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。\n\n我们有两种方式可以添加自定义PropertyEditor:\n\n- 通过`context.getBeanFactory().registerCustomEditor`\n\n- 通过Spring配置文件:\n\n  ```xml\n  <bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n    <property name=\"customEditors\">\n            <map>\n                <entry key=\"base.Cat\" value=\"base.CatEditor\" /> \n        </map>\n    </property>\n  </bean>\n  ```\n\n参考: [深入理解JavaBean(2)：属性编辑器PropertyEditor](http://blog.csdn.net/zhoudaxia/article/details/36247883)\n\n#### 环境注入\n\n在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory:\n\n```java\nbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n```\n\nApplicationContextAwareProcessor核心的invokeAwareInterfaces方法:\n\n```java\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof Aware) {\n        if (bean instanceof EnvironmentAware) {\n            ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n        }\n        if (bean instanceof EmbeddedValueResolverAware) {\n            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);\n        }\n        //....\n    }\n}\n```\n\n#### 依赖解析忽略\n\n此部分设置哪些接口在进行依赖注入的时候应该被忽略:\n\n```java\nbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\nbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\nbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);\nbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\nbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n```\n\n#### bean伪装\n\n有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下:\n\n```java\nbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\nbeanFactory.registerResolvableDependency(ResourceLoader.class, this);\nbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\nbeanFactory.registerResolvableDependency(ApplicationContext.class, this);\n```\n\n伪装关系保存在一个Map<Class<?>, Object>里。\n\n#### LoadTimeWeaver\n\n如果配置了此bean，那么：\n\n```java\nif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n    // Set a temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n}\n```\n\n这个东西具体是干什么的在后面context:load-time-weaver中说明。\n\n#### 注册环境\n\n源码:\n\n```java\nif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n}\nif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n}\nif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().\n        getSystemEnvironment());\n}\n```\n\ncontainsLocalBean特殊之处在于不会去父BeanFactory寻找。\n\n### postProcessBeanFactory\n\n此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。\n\n### invokeBeanFactoryPostProcessors\n\nBeanFactoryPostProcessor接口允许我们在bean正是初始化之前改变其值。此接口只有一个方法:\n\n```java\nvoid postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory);\n```\n\n有两种方式可以向Spring添加此对象:\n\n- 通过代码的方式:\n\n  ```java\n  context.addBeanFactoryPostProcessor\n  ```\n\n- 通过xml配置的方式:\n\n  ```xml\n  <bean class=\"base.SimpleBeanFactoryPostProcessor\" />\n  ```\n\n注意此时尚未进行bean的初始化工作，初始化是在后面的finishBeanFactoryInitialization进行的，所以在BeanFactoryPostProcessor对象中获取bean会导致提前初始化。\n\n此方法的关键源码:\n\n```java\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory,\n        getBeanFactoryPostProcessors());\n}\n```\n\ngetBeanFactoryPostProcessors获取的就是AbstractApplicationContext的成员beanFactoryPostProcessors(ArrayList)，但是很有意思，**只有通过context.addBeanFactoryPostProcessor这种方式添加的才会出现在这个List里，所以对于xml配置方式，此List其实没有任何元素。玄机就在PostProcessorRegistrationDelegate里**。\n\n核心思想就是使用BeanFactory的getBeanNamesForType方法获取相应的BeanDefinition的name数组，之后逐一调用getBean方法获取到bean(初始化)，getBean方法后面再说。\n\n注意此处有一个优先级的概念，如果你的BeanFactoryPostProcessor同时实现了Ordered或者是PriorityOrdered接口，那么会被首先执行。\n\n### BeanPostProcessor注册\n\n此部分实质上是在BeanDefinitions中寻找BeanPostProcessor，之后调用BeanFactory.addBeanPostProcessor方法保存在一个List中，注意添加时仍然有优先级的概念，优先级高的在前面。\n\n### MessageSource\n\n此接口用以支持Spring国际化。继承体系如下:\n\n![MessageSource继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MessageSource.jpg)\n\nAbstractApplicationContext的initMessageSource()方法就是在BeanFactory中查找MessageSource的bean，如果配置了此bean，那么调用getBean方法完成其初始化并将其保存在AbstractApplicationContext内部messageSource成员变量中，用以处理ApplicationContext的getMessage调用，因为从继承体系上来看，ApplicationContext是MessageSource的子类，此处是委托模式的体现。如果没有配置此bean，那么初始化一个DelegatingMessageSource对象，此类是一个空实现，同样用以处理getMessage调用请求。\n\n参考: [学习Spring必学的Java基础知识(8)----国际化信息](http://stamen.iteye.com/blog/1541732)\n\n### 事件驱动\n\n此接口代表了Spring的事件驱动(监听器)模式。一个事件驱动包含三部分:\n\n#### 事件\n\njava的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:\n\n![EventObject继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EventObject.jpg)\n\n#### 发布者\n\n##### ApplicationEventPublisher\n\n![ApplicationEventPublisher继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationEventPublisher.jpg)\n\n一目了然。\n\n##### ApplicationEventMulticaster\n\nApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:\n\n![ApplicationEventMulticaster继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationEventMulticaster.jpg)\n\n#### 监听器\n\n所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:\n\n![EventListener继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EventListener.jpg)\n\n可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。\n\n#### 初始化\n\n前面说过ApplicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:\n\n```java\n// Initialize event multicaster for this context.\ninitApplicationEventMulticaster();\n```\n\ninitApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。\n\n#### 事件发布\n\nAbstractApplicationContext.publishEvent核心代码:\n\n```java\nprotected void publishEvent(Object event, ResolvableType eventType) {\n    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n}\n```\n\nSimpleApplicationEventMulticaster.multicastEvent:\n\n```java\n@Override\npublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {\n    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n    for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n        Executor executor = getTaskExecutor();\n        if (executor != null) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    invokeListener(listener, event);\n                }\n            });\n        } else {\n            invokeListener(listener, event);\n        }\n    }\n}\n```\n\n##### 监听器获取\n\n获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。\n\n##### 同步/异步\n\n可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步/异步呢?\n\n###### 全局\n\n```xml\n<task:executor id=\"multicasterExecutor\" pool-size=\"3\"/>\n<bean class=\"org.springframework.context.event.SimpleApplicationEventMulticaster\">\n    <property name=\"taskExecutor\" ref=\"multicasterExecutor\"></property>\n</bean>\n```\n\ntask schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：\n\n```xml\nxmlns:task=\"http://www.springframework.org/schema/task\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\"\n```\n\n可以参考: [Spring定时任务的几种实现](http://gong1208.iteye.com/blog/1773177)\n\n###### 注解\n\n开启注解支持:\n\n```xml\n<!-- 开启@AspectJ AOP代理 -->  \n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>  \n<!-- 任务调度器 -->  \n<task:scheduler id=\"scheduler\" pool-size=\"10\"/>  \n<!-- 任务执行器 -->  \n<task:executor id=\"executor\" pool-size=\"10\"/>  \n<!--开启注解调度支持 @Async @Scheduled-->  \n<task:annotation-driven executor=\"executor\" scheduler=\"scheduler\" proxy-target-class=\"true\"/>  \n```\n\n在代码中使用示例:\n\n```java\n@Component  \npublic class EmailRegisterListener implements ApplicationListener<RegisterEvent> {  \n    @Async  \n    @Override  \n    public void onApplicationEvent(final RegisterEvent event) {  \n        System.out.println(\"注册成功，发送确认邮件给：\" + ((User)event.getSource()).getUsername());  \n    }  \n}  \n```\n\n参考: [详解Spring事件驱动模型](http://jinnianshilongnian.iteye.com/blog/1902886)\n\n### onRefresh\n\n这又是一个模版方法，允许子类在进行bean初始化之前进行一些定制操作。默认空实现。\n\n### ApplicationListener注册\n\nregisterListeners方法干的，没什么好说的。\n\n### singleton初始化\n\nfinishBeanFactoryInitialization：\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n        beanFactory.setConversionService(\n                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n    }\n    if (!beanFactory.hasEmbeddedValueResolver()) {\n        beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n            @Override\n            public String resolveStringValue(String strVal) {\n                return getEnvironment().resolvePlaceholders(strVal);\n            }\n        });\n    }\n    String[] weaverAwareNames = beanFactory.getBeanNamesForType\n        (LoadTimeWeaverAware.class, false, false);\n    for (String weaverAwareName : weaverAwareNames) {\n        getBean(weaverAwareName);\n    }\n    // Allow for caching all bean definition metadata, not expecting further changes.\n    beanFactory.freezeConfiguration();\n    // Instantiate all remaining (non-lazy-init) singletons.\n    beanFactory.preInstantiateSingletons();\n}\n```\n\n分部分说明。\n\n#### ConversionService\n\n此接口用于类型之间的转换，在Spring里其实就是把配置文件中的String转为其它类型，从3.0开始出现，目的和jdk的PropertyEditor接口是一样的，参考ConfigurableBeanFactory.setConversionService注释:\n\n> >Specify a Spring 3.0 ConversionService to use for converting\n> > property values, as an alternative to JavaBeans PropertyEditors.\n> > @since 3.0\n\n#### StringValueResolver\n\n用于解析注解的值。接口只定义了一个方法:\n\n```java\nString resolveStringValue(String strVal);\n```\n\n#### LoadTimeWeaverAware\n\n实现了此接口的bean可以得到LoadTimeWeaver，此处仅仅初始化。\n\n#### 初始化\n\nDefaultListableBeanFactory.preInstantiateSingletons:\n\n```java\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n    List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\n    for (String beanName : beanNames) {\n        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n        if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n            if (isFactoryBean(beanName)) {\n                final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX \n                    + beanName);\n                boolean isEagerInit;\n                if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                    isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                        @Override\n                        public Boolean run() {\n                            return ((SmartFactoryBean<?>) factory).isEagerInit();\n                        }\n                    }, getAccessControlContext());\n                }\n                else {\n                    isEagerInit = (factory instanceof SmartFactoryBean &&\n                            ((SmartFactoryBean<?>) factory).isEagerInit());\n                }\n                if (isEagerInit) {\n                    getBean(beanName);\n                }\n            }\n            else {\n                getBean(beanName);\n            }\n        }\n    }\n\n    // Trigger post-initialization callback for all applicable beans...\n    for (String beanName : beanNames) {\n        Object singletonInstance = getSingleton(beanName);\n        if (singletonInstance instanceof SmartInitializingSingleton) {\n            final SmartInitializingSingleton smartSingleton = \n                (SmartInitializingSingleton) singletonInstance;\n            if (System.getSecurityManager() != null) {\n                AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        smartSingleton.afterSingletonsInstantiated();\n                        return null;\n                    }\n                }, getAccessControlContext());\n            }\n            else {\n                smartSingleton.afterSingletonsInstantiated();\n            }\n        }\n    }\n}\n```\n\n首先进行Singleton的初始化，其中如果bean是FactoryBean类型(注意，只定义了factory-method属性的普通bean并不是FactoryBean)，并且还是SmartFactoryBean类型，那么需要判断是否需要eagerInit(isEagerInit是此接口定义的方法)。\n\n# getBean\n\n这里便是bean初始化的核心逻辑。源码比较复杂，分开说。以getBean(String name)为例。AbstractBeanFactory.getBean:\n\n```java\n@Override\npublic Object getBean(String name) throws BeansException {\n    return doGetBean(name, null, null, false);\n}\n```\n\n第二个参数表示bean的Class类型，第三个表示创建bean需要的参数，最后一个表示不需要进行类型检查。\n\n## beanName转化\n\n```java\nfinal String beanName = transformedBeanName(name);\n```\n\n这里是将FactoryBean的前缀去掉以及将别名转为真实的名字。\n\n## 手动注册bean检测\n\n前面注册环境一节说过，Spring其实手动注册了一些单例bean。这一步就是检测是不是这些bean。如果是，那么再检测是不是工厂bean，如果是返回其工厂方法返回的实例，如果不是返回bean本身。\n\n```java\nObject sharedInstance = getSingleton(beanName);\nif (sharedInstance != null && args == null) {\n    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n}\n```\n\n## 检查父容器\n\n如果父容器存在并且存在此bean定义，那么交由其父容器初始化:\n\n```java\nBeanFactory parentBeanFactory = getParentBeanFactory();\nif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n    // Not found -> check parent.\n    //此方法其实是做了前面beanName转化的逆操作，因为父容器同样会进行转化操作\n    String nameToLookup = originalBeanName(name);\n    if (args != null) {\n        // Delegation to parent with explicit args.\n        return (T) parentBeanFactory.getBean(nameToLookup, args);\n    } else {\n        // No args -> delegate to standard getBean method.\n        return parentBeanFactory.getBean(nameToLookup, requiredType);\n    }\n}\n```\n\n## 依赖初始化\n\nbean可以由depends-on属性配置依赖的bean。Spring会首先初始化依赖的bean。\n\n```java\nString[] dependsOn = mbd.getDependsOn();\nif (dependsOn != null) {\n    for (String dependsOnBean : dependsOn) {\n         //检测是否存在循环依赖\n        if (isDependent(beanName, dependsOnBean)) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            \"Circular depends-on relationship between \'\" + beanName + \"\' and \'\" + dependsOnBean + \"\'\");\n        }\n        registerDependentBean(dependsOnBean, beanName);\n        getBean(dependsOnBean);\n    }\n}\n```\n\nregisterDependentBean进行了依赖关系的注册，这么做的原因是Spring在即进行bean销毁的时候会首先销毁被依赖的bean。依赖关系的保存是通过一个ConcurrentHashMap<String, Set<String>>完成的，key是bean的真实名字。\n\n## Singleton初始化\n\n虽然这里大纲是Singleton初始化，但是getBean方法本身是包括所有scope的初始化，在这里一次说明了。\n\n```java\nif (mbd.isSingleton()) {\n    sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n        @Override\n        public Object getObject() throws BeansException {\n            return createBean(beanName, mbd, args);\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n}\n```\n\n### getSingleton方法\n\n#### 是否存在\n\n首先会检测是否已经存在，如果存在，直接返回:\n\n```java\nsynchronized (this.singletonObjects) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n}\n```\n\n所有的单例bean都保存在这样的数据结构中: `ConcurrentHashMap<String, Object>`。\n\n#### bean创建\n\n源码位于AbstractAutowireCapableBeanFactory.createBean，主要分为几个部分:\n\n##### lookup-method检测\n\n此部分用于检测lookup-method标签配置的方法是否存在:\n\n```java\nRootBeanDefinition mbdToUse = mbd;\nmbdToUse.prepareMethodOverrides();\n```\n\nprepareMethodOverrides:\n\n```java\npublic void prepareMethodOverrides() throws BeanDefinitionValidationException {\n    // Check that lookup methods exists.\n    MethodOverrides methodOverrides = getMethodOverrides();\n    if (!methodOverrides.isEmpty()) {\n        Set<MethodOverride> overrides = methodOverrides.getOverrides();\n        synchronized (overrides) {\n            for (MethodOverride mo : overrides) {\n                prepareMethodOverride(mo);\n            }\n        }\n    }\n}\n```\n\nprepareMethodOverride:\n\n```java\nprotected void prepareMethodOverride(MethodOverride mo)  {\n    int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());\n    if (count == 0) {\n        throw new BeanDefinitionValidationException(\n                \"Invalid method override: no method with name \'\" + mo.getMethodName() +\n                \"\' on class [\" + getBeanClassName() + \"]\");\n    } else if (count == 1) {\n        // Mark override as not overloaded, to avoid the overhead of arg type checking.\n        mo.setOverloaded(false);\n    }\n}\n```\n\n##### InstantiationAwareBeanPostProcessor触发\n\n在这里触发的是其postProcessBeforeInitialization和postProcessAfterInstantiation方法。\n\n```java\nObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\nif (bean != null) {\n    return bean;\n}\nObject beanInstance = doCreateBean(beanName, mbdToUse, args);\nreturn beanInstance;\n```\n\n继续:\n\n```java\nprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n    Object bean = null;\n    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n        // Make sure bean class is actually resolved at this point.\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            Class<?> targetType = determineTargetType(beanName, mbd);\n            if (targetType != null) {\n                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n                if (bean != null) {\n                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n                }\n            }\n        }\n        mbd.beforeInstantiationResolved = (bean != null);\n    }\n    return bean;\n}\n```\n\n从这里可以看出，**如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程，此接口用于初始化自定义的bean，主要是在Spring内部使用**。\n\n##### doCreateBean\n\n同样分为几部分。\n\n###### 创建(createBeanInstance)\n\n关键代码:\n\n```java\nBeanWrapper instanceWrapper = null;\nif (instanceWrapper == null) {\n    instanceWrapper = createBeanInstance(beanName, mbd, args);\n}\n```\n\ncreateBeanInstance的创建过程又分为以下几种情况:\n\n- 工厂bean:\n\n  调用instantiateUsingFactoryMethod方法:\n\n  ```java\n  protected BeanWrapper instantiateUsingFactoryMethod(\n    String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);\n  }\n  ```\n\n  注意，此处的工厂bean指的是配置了factory-bean/factory-method属性的bean，不是实现了FacrotyBean接口的bean。如果没有配置factory-bean属性，那么factory-method指向的方法必须是静态的。此方法主要做了这么几件事:\n\n  - 初始化一个BeanWrapperImpl对象。\n\n  - 根据设置的参数列表使用反射的方法寻找相应的方法对象。\n\n  - InstantiationStrategy:\n\n    bean的初始化在此处又抽成了策略模式，类图:\n\n    ![InstantiationStrategy类图](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/InstantiationStrategy.jpg)\n\n    instantiateUsingFactoryMethod部分源码:\n\n    ```java\n    beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n        mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n    ```\n\n    getInstantiationStrategy返回的是CglibSubclassingInstantiationStrategy对象。此处instantiate实现也很简单，就是调用工厂方法的Method对象反射调用其invoke即可得到对象，SimpleInstantiationStrategy.\n\n    instantiate核心源码:\n\n    ```java\n    @Override\n    public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner,\n        Object factoryBean, final Method factoryMethod, Object... args) {\n        return factoryMethod.invoke(factoryBean, args);\n    }\n    ```\n\n- 构造器自动装配\n\n  createBeanInstance部分源码:\n\n  ```java\n  // Need to determine the constructor...\n  Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n  if (ctors != null ||\n    mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n      //配置了<constructor-arg>子元素\n    mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n    return autowireConstructor(beanName, mbd, ctors, args);\n  }\n  ```\n\n  determineConstructorsFromBeanPostProcessors源码:\n\n  ```java\n  protected Constructor<?>[] determineConstructorsFromBeanPostProcessors(Class<?> beanClass, String beanName) {\n    if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                SmartInstantiationAwareBeanPostProcessor ibp = \n                    (SmartInstantiationAwareBeanPostProcessor) bp;\n                Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);\n                if (ctors != null) {\n                    return ctors;\n                }\n            }\n        }\n    }\n    return null;\n  }\n  ```\n\n  可见是由SmartInstantiationAwareBeanPostProcessor决定的，默认是没有配置这种东西的。\n\n  之后就是判断bean的自动装配模式，可以通过如下方式配置:\n\n  ```xml\n  <bean id=\"student\" class=\"base.Student\" primary=\"true\" autowire=\"default\" />\n  ```\n\n  autowire共有以下几种选项:\n\n  - no: 默认的，不进行自动装配。在这种情况下，只能通过ref方式引用其它bean。\n  - byName: 根据bean里面属性的名字在BeanFactory中进行查找并装配。\n  - byType: 按类型。\n  - constructor: 以byType的方式查找bean的构造参数列表。\n  - default: 由父bean决定。\n\n  参考: [Spring - bean的autowire属性(自动装配)](http://www.cnblogs.com/ViviChan/p/4981539.html)\n\n  autowireConstructor调用的是ConstructorResolver.autowireConstructor，此方法主要做了两件事:\n\n  - 得到合适的构造器对象。\n\n  - 根据构造器参数的类型去BeanFactory查找相应的bean:\n\n    入口方法在ConstructorResolver.resolveAutowiredArgument:\n\n    ```java\n    protected Object resolveAutowiredArgument(\n            MethodParameter param, String beanName, Set<String> autowiredBeanNames, \n            TypeConverter typeConverter) {\n        return this.beanFactory.resolveDependency(\n                new DependencyDescriptor(param, true), beanName, \n                autowiredBeanNames, typeConverter);\n    }\n    ```\n\n  最终调用的还是CglibSubclassingInstantiationStrategy.instantiate方法，关键源码:\n\n  ```java\n  @Override\n  public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner,\n        final Constructor<?> ctor, Object... args) {\n    if (bd.getMethodOverrides().isEmpty()) {\n             //反射调用\n        return BeanUtils.instantiateClass(ctor, args);\n    } else {\n        return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);\n    }\n  }\n  ```\n\n  可以看出，如果配置了lookup-method标签，**得到的实际上是用Cglib生成的目标类的代理子类**。\n\n  CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection:\n\n  ```java\n  @Override\n  protected Object instantiateWithMethodInjection(RootBeanDefinition bd, String beanName, BeanFactory 	owner,Constructor<?> ctor, Object... args) {\n    // Must generate CGLIB subclass...\n    return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n  }\n  ```\n\n- 默认构造器\n\n  一行代码，很简单:\n\n  ```java\n  // No special handling: simply use no-arg constructor.\n  return instantiateBean(beanName, mbd);\n  ```\n\n###### MergedBeanDefinitionPostProcessor\n\n触发源码:\n\n```java\nsynchronized (mbd.postProcessingLock) {\n    if (!mbd.postProcessed) {\n        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n        mbd.postProcessed = true;\n    }\n}\n```\n\n此接口也是Spring内部使用的，不管它了。\n\n###### 属性解析\n\n入口方法: AbstractAutowireCapableBeanFactory.populateBean，它的作用是: 根据autowire类型进行autowire by name，by type 或者是直接进行设置，简略后的源码:\n\n```java\nprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n    //所有<property>的值\n    PropertyValues pvs = mbd.getPropertyValues();\n\n    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n        // Add property values based on autowire by name if applicable.\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n            autowireByName(beanName, mbd, bw, newPvs);\n        }\n\n        // Add property values based on autowire by type if applicable.\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n            autowireByType(beanName, mbd, bw, newPvs);\n        }\n\n        pvs = newPvs;\n    }\n    //设值\n    applyPropertyValues(beanName, mbd, bw, pvs);\n}\n```\n\nautowireByName源码:\n\n```java\nprotected void autowireByName(\n        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n    //返回所有引用(ref=\"XXX\")的bean名称\n    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n    for (String propertyName : propertyNames) {\n        if (containsBean(propertyName)) {\n             //从BeanFactory获取\n            Object bean = getBean(propertyName);\n            pvs.add(propertyName, bean);\n            registerDependentBean(propertyName, beanName);\n        }\n    }\n}\n```\n\nautowireByType也是同样的套路，所以可以得出结论: **autowireByName和autowireByType方法只是先获取到引用的bean，真正的设值是在applyPropertyValues中进行的。**\n\n###### 属性设置\n\nSpring判断一个属性可不可以被设置(存不存在)是通过java bean的内省操作来完成的，也就是说，属性可以被设置的条件是**此属性拥有public的setter方法，并且注入时的属性名应该是setter的名字**。\n\n###### 初始化\n\n此处的初始化指的是bean已经构造完成，执行诸如调用其init方法的操作。相关源码:\n\n```java\n// Initialize the bean instance.\nObject exposedObject = bean;\ntry {\n    populateBean(beanName, mbd, instanceWrapper);\n    if (exposedObject != null) {\n        exposedObject = initializeBean(beanName, exposedObject, mbd);\n    }\n}\n```\n\ninitializeBean:\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n    if (System.getSecurityManager() != null) {\n        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }\n        }, getAccessControlContext());\n    }\n    else {\n        invokeAwareMethods(beanName, bean);\n    }\n\n    Object wrappedBean = bean;\n    if (mbd == null || !mbd.isSynthetic()) {\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    }\n\n    invokeInitMethods(beanName, wrappedBean, mbd);\n\n    if (mbd == null || !mbd.isSynthetic()) {\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n    }\n    return wrappedBean;\n}\n```\n\n主要的操作步骤一目了然。\n\n- Aware方法触发:\n\n  我们的bean有可能实现了一些XXXAware接口，此处就是负责调用它们:\n\n  ```java\n  private void invokeAwareMethods(final String beanName, final Object bean) {\n    if (bean instanceof Aware) {\n        if (bean instanceof BeanNameAware) {\n            ((BeanNameAware) bean).setBeanName(beanName);\n        }\n        if (bean instanceof BeanClassLoaderAware) {\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        }\n        if (bean instanceof BeanFactoryAware) {\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        }\n    }\n  }\n  ```\n\n- BeanPostProcessor触发，没什么好说的\n\n- 调用init方法:\n\n  在XML配置中，bean可以有一个init-method属性来指定初始化时调用的方法。从原理来说，其实就是一个反射调用。不过注意这里有一个InitializingBean的概念。\n\n  此接口只有一个方法：\n\n  ```java\n  void afterPropertiesSet() throws Exception;\n  ```\n\n  如果我们的bean实现了此接口，那么此方法会首先被调用。此接口的意义在于: 当此bean的所有属性都被设置(注入)后，给bean一个利用现有属性重新组织或是检查属性的机会。感觉和init方法有些冲突，不过此接口在Spring被广泛使用。\n\n### getObjectForBeanInstance\n\n位于AbstractBeanFactory，此方法的目的在于如果bean是FactoryBean，那么返回其工厂方法创建的bean，而不是自身。\n\n## Prototype初始化\n\nAbstractBeanFactory.doGetBean相关源码:\n\n```java\nelse if (mbd.isPrototype()) {\n    // It\'s a prototype -> create a new instance.\n    Object prototypeInstance = null;\n    try {\n        beforePrototypeCreation(beanName);\n        prototypeInstance = createBean(beanName, mbd, args);\n    }\n    finally {\n        afterPrototypeCreation(beanName);\n    }\n    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n}\n```\n\n### beforePrototypeCreation\n\n此方法用于确保在同一时刻只能有一个此bean在初始化。\n\n### createBean\n\n和单例的是一样的，不在赘述。\n\n### afterPrototypeCreation\n\n和beforePrototypeCreation对应的，你懂的。\n\n### 总结\n\n可以看出，初始化其实和单例是一样的，只不过单例多了一个是否已经存在的检查。\n\n## 其它Scope初始化\n\n其它就指的是request、session。此部分源码:\n\n```java\nelse {\n    String scopeName = mbd.getScope();\n    final Scope scope = this.scopes.get(scopeName);\n    if (scope == null) {\n        throw new IllegalStateException(\"No Scope registered for scope name \'\" + scopeName + \"\'\");\n    }\n    Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n        @Override\n        public Object getObject() throws BeansException {\n            beforePrototypeCreation(beanName);\n            try {\n                return createBean(beanName, mbd, args);\n            }\n            finally {\n                afterPrototypeCreation(beanName);\n            }\n        }\n    });\n    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n}\n```\n\nscopes是一个LinkedHashMap<String, Scope>，可以调用 ConfigurableBeanFactory定义的registerScope方法注册其值。\n\nScope接口继承体系:\n\n![Scope继承体系](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Scope.jpg)\n\n根据socpe.get的注释，此方法如果找到了叫做beanName的bean，那么返回，如果没有，将调用ObjectFactory创建之。Scope的实现参考类图。\n\n\n\n\n\n\n\n', '', '2', 0, '2020-01-08 17:05:28', '2020-01-08 17:05:28', '2020-01-08 16:22:23', '');
INSERT INTO `tb_article` VALUES (313, 'guava-cache笔记', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'seaswalker', 'guava-cache数据结构，put、get算法', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [创建](#%E5%88%9B%E5%BB%BA)\n  - [数据结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n    - [segments](#segments)\n    - [ReferenceEntry](#referenceentry)\n  - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [ReferenceEntry数组](#referenceentry%E6%95%B0%E7%BB%84)\n    - [引用队列](#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97)\n- [put](#put)\n  - [Hash算法](#hash%E7%AE%97%E6%B3%95)\n  - [ReHash](#rehash)\n  - [Segment选取](#segment%E9%80%89%E5%8F%96)\n  - [Segment.put](#segmentput)\n    - [线程安全性](#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7)\n    - [过期/垃圾缓存清理](#%E8%BF%87%E6%9C%9F%E5%9E%83%E5%9C%BE%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86)\n      - [垃圾缓存](#%E5%9E%83%E5%9C%BE%E7%BC%93%E5%AD%98)\n        - [善后](#%E5%96%84%E5%90%8E)\n        - [writeQueue移除](#writequeue%E7%A7%BB%E9%99%A4)\n        - [accessQueue移除](#accessqueue%E7%A7%BB%E9%99%A4)\n        - [加载终止](#%E5%8A%A0%E8%BD%BD%E7%BB%88%E6%AD%A2)\n        - [移除算法](#%E7%A7%BB%E9%99%A4%E7%AE%97%E6%B3%95)\n      - [过期缓存](#%E8%BF%87%E6%9C%9F%E7%BC%93%E5%AD%98)\n    - [扩容](#%E6%89%A9%E5%AE%B9)\n    - [设值](#%E8%AE%BE%E5%80%BC)\n- [get(key)](#getkey)\n  - [get(key,hash,loader)](#getkeyhashloader)\n- [参考](#%E5%8F%82%E8%80%83)\n- [总结](#%E6%80%BB%E7%BB%93)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 创建\n\n以CacheLoader的方式为例:\n\n```java\nLoadingCache<String, String> cache = CacheBuilder.newBuilder().maximumSize(2)\n    .build(new CacheLoader<String, String>() {\n        @Override\n         public String load(String s) throws Exception {\n            return \"Hello: \" + s;\n        }\n    });\n```\n\n创建的关键便在于build方法,build方法的核心逻辑位于LocalCache构造器，构造器完成了两件事:\n\n- 将设置的属性从CacheBuilder复制到LocalCache。\n- 构造缓存存储的数据结构，此数据结构可以理解为一个自己实现的ConcurrentHashMap(分段锁)。\n\n数据结构的示意图:\n\n![guava-cache](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/guava-cache.jpg)\n\n## 数据结构\n\n###  segments\n\nSegment代表了其中的一段。其类图(部分):\n\n![Segment类图](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Segment.jpg)\n\n此类继承ReentrantLock的目的在于方便的进行加锁操作。\n\n那么Segment的个数是如何确定的呢?\n\n**取最小的大于等于目的并行度的2的整次幂，如果设置了按权重大小的淘汰策略，那么还应注意总的权重值不超过给定的上限，每个Segment的权重按20计**。\n\n相关源码:\n\n```java\nLocalCache(\n      CacheBuilder<? super K, ? super V> builder, @Nullable CacheLoader<? super K, V> loader) {\n    concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);\n    int segmentCount = 1;\n    while (segmentCount < concurrencyLevel && (!evictsBySize() || segmentCount * 20 <= maxWeight)) {\n      ++segmentShift;\n      segmentCount <<= 1;\n    }\n}\n```\n\n并行度即并发修改缓存值的线程数，可以通过CacheBuilder的concurrencyLevel方法进行设置，默认4.\n\n### ReferenceEntry\n\nReferenceEntry是guava-cache中实际进行存储的数据结构，其类图:\n\n![ReferenceEntry类图](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ReferenceEntry.jpg)\n\n那么在初始状态下，每个Segment中有多少个ReferenceEntry呢?\n\n**取最小的大于等于(initialCapacity / segmentCount)的2的整次幂的值**。关键代码:\n\n```java\nLocalCache(\n      CacheBuilder<? super K, ? super V> builder, @Nullable CacheLoader<? super K, V> loader) {\n    int segmentCapacity = initialCapacity / segmentCount;\n    if (segmentCapacity * segmentCount < initialCapacity) {\n      ++segmentCapacity;\n    }\n    int segmentSize = 1;\n    while (segmentSize < segmentCapacity) {\n        segmentSize <<= 1;\n    }\n}\n```\n\ninitialCapacity由CacheBuilder的同名方法进行设置，默认16.\n\n## 初始化\n\n关键代码:\n\n```java\nLocalCache(\n      CacheBuilder<? super K, ? super V> builder, @Nullable CacheLoader<? super K, V> loader) {\n    if (evictsBySize()) {\n        // Ensure sum of segment max weights = overall max weights\n        long maxSegmentWeight = maxWeight / segmentCount + 1;\n        long remainder = maxWeight % segmentCount;\n        for (int i = 0; i < this.segments.length; ++i) {\n            if (i == remainder) {\n                maxSegmentWeight--;\n            }\n            this.segments[i] =\n                createSegment(segmentSize, maxSegmentWeight, builder.getStatsCounterSupplier().get());\n        }\n    } else {\n        for (int i = 0; i < this.segments.length; ++i) {\n         this.segments[i] =\n            createSegment(segmentSize, UNSET_INT, builder.getStatsCounterSupplier().get());\n        }\n    }\n}\n```\n\n可以看出，初始化根据是否启用了权重大小限制分为了两种情况，两种情况的区别在于maxSegmentWeight参数，用以指定此Segment的权重上限。\n\ncreateSegment其实就是对Segment构造器的调用，此构造器主要做了两件事:\n\n- 初始化ReferenceEntry数组数据结构。\n- 初始化引用队列。\n\n下面分开对其进行说明。\n\n###  ReferenceEntry数组\n\n关键代码:\n\n```java\nSegment(LocalCache<K, V> map, int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter) {\n     initTable(newEntryArray(initialCapacity));\n}\n```\n\nnewEntryArray方法只是创建了一个initialCapacity大小的数组，关键在于initTable:\n\n```java\nvoid initTable(AtomicReferenceArray<ReferenceEntry<K, V>> newTable) {\n  this.threshold = newTable.length() * 3 / 4; // 0.75\n  if (!map.customWeigher() && this.threshold == maxSegmentWeight) {\n    // prevent spurious expansion before eviction\n    this.threshold++;\n  }\n  this.table = newTable;\n}\n```\n\n这里完成的是对临界值的设置，超过此值数据将进行扩张。\n\n### 引用队列\n\n关键代码:\n\n```java\nSegment(LocalCache<K, V> map, int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter) {\n    //当不是强引用的时候成立\n    keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;\n    valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue<V>() : null;\n    recencyQueue =\n        map.usesAccessQueue()\n        ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()\n        : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n    writeQueue =\n        map.usesWriteQueue()\n        ? new WriteQueue<K, V>()\n        : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n    accessQueue =\n        map.usesAccessQueue()\n        ? new AccessQueue<K, V>()\n        : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n}\n```\n\nkeyReferenceQueue和valueReferenceQueue用于结合软引用、弱引用以及虚引用使用，关于java中四种引用的区别以及ReferenceQueue的用途，参考:\n\n[Java对象的强、软、弱和虚引用原理+结合ReferenceQueue对象构造Java对象的高速缓存器](http://blog.csdn.net/lyfi01/article/details/6415726)\n\nusesKeyReferences源码:\n\n```java\nboolean usesKeyReferences() {\n    return keyStrength != Strength.STRONG;\n}\n```\n\nkeyStrength通过CacheBuilder.getKeyStrength获取:\n\n```java\nStrength getKeyStrength() {\n    return MoreObjects.firstNonNull(keyStrength, Strength.STRONG);\n}\n```\n\n可以看出，**默认采用强引用的方式**。我们可以通过CacheBuilder的softValues、weakKeys，weakValues方法对其进行设置。\n\nrecencyQueue等队列将在后面结合get方法进行说明。\n\n# put\n\nLocalCache.put:\n\n```java\n@Override\npublic V put(K key, V value) {\n    checkNotNull(key);\n    checkNotNull(value);\n    int hash = hash(key);\n    return segmentFor(hash).put(key, hash, value, false);\n}\n```\n\n## Hash算法\n\nLocalCache.hash:\n\n```java\nint hash(@Nullable Object key) {\n    int h = keyEquivalence.hash(key);\n    return rehash(h);\n}\n```\n\nkeyEquivalence是策略模式的体现，针对不同的引用方式(LocalCache.Strength)提供不同的hash算法实现。\n\nEquivalence接口类图:\n\n![Equivalence类图](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Equivalence.jpg)\n\nkeyEquivalence属性由CacheBuilder的getKeyEquivalence方法获得:\n\n```java\nEquivalence<Object> getKeyEquivalence() {\n    return MoreObjects.firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());\n}\n```\n\n可以看出，**使用的hash算法与Strength相关联**。Strength部分源码(仅展示defaultEquivalence方法):\n\n```java\nenum Strength {\n    STRONG {\n        @Override\n        Equivalence<Object> defaultEquivalence() {\n            return Equivalence.equals();\n        }\n    },\n    SOFT {\n        @Override\n        Equivalence<Object> defaultEquivalence() {\n            return Equivalence.identity();\n        }\n    },\n    WEAK {\n        @Override\n        Equivalence<Object> defaultEquivalence() {\n            return Equivalence.identity();\n        }\n    }\n};\n```\n\n以强引用为例。Equivalence.equals()返回的其实是一个单例的Equals对象，由上面类图可以看出，Equals是Equivalence的子类，源码:\n\n```java\nstatic final class Equals extends Equivalence<Object> implements Serializable {\n\n    static final Equals INSTANCE = new Equals();\n\n    @Override\n    protected boolean doEquivalent(Object a, Object b) {\n        return a.equals(b);\n    }\n\n    @Override\n    protected int doHash(Object o) {\n        return o.hashCode();\n    }\n\n    private Object readResolve() {\n        return INSTANCE;\n    }\n}\n```\n\n可以看出，对于强引用来说，其哈希算法就是JDK Object的hashCode方法。\n\n而对于weak和soft引用来说，对应的是Identity实例，源码:\n\n```java\nstatic final class Identity extends Equivalence<Object> implements Serializable {\n    static final Identity INSTANCE = new Identity();\n    @Override\n    protected boolean doEquivalent(Object a, Object b) {\n        return false;\n    }\n    @Override\n    protected int doHash(Object o) {\n        return System.identityHashCode(o);\n    }\n    private Object readResolve() {\n        return INSTANCE;\n    }\n}\n```\n\nidentityHashCode返回的是**默认hashCode方法的计算结果，即根据内存地址计算而来的结果**。\n\n至于为什么要分开处理，暂时未知。\n\n## ReHash\n\nguava cache采用了和ConcurrentHashMap同样的算法。\n\n## Segment选取\n\nLocalCache.segmentFor:\n\n```java\nSegment<K, V> segmentFor(int hash) {\n    return segments[(hash >>> segmentShift) & segmentMask];\n}\n```\n\nsegmentShift和segmentMask的取值，LocalCache构造器源码:\n\n```java\nint segmentShift = 0;\nint segmentCount = 1;\nwhile (segmentCount < concurrencyLevel && (!evictsBySize() || segmentCount * 20 <= maxWeight)) {\n    ++segmentShift;\n    segmentCount <<= 1;\n}\nthis.segmentShift = 32 - segmentShift;\nsegmentMask = segmentCount - 1;\n```\n\n可以看出，寻找Segment的过程其实是对**hashCode先取高n位，再取余的过程**。\n\n## Segment.put\n\n源码很长，下面分部分说明。\n\n### 线程安全性\n\n部分源码:\n\n```java\n@Nullable\nV put(K key, int hash, V value, boolean onlyIfAbsent) {\n    lock();\n    try {\n        //...\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}\n```\n\n可见，核心逻辑都位于锁的保护之中。\n\n### 过期/垃圾缓存清理\n\n相关源码:\n\n```java\nlong now = map.ticker.read();\npreWriteCleanup(now);\n```\n\nticker.read方法返回的实际上就是System.nanoTime的值。preWriteCleanup最终调用runLockedCleanup方法:\n\n```java\nvoid runLockedCleanup(long now) {\n    //必定通过\n    if (tryLock()) {\n        try {\n            drainReferenceQueues();\n            expireEntries(now); // calls drainRecencyQueue\n            readCount.set(0);\n        } finally {\n            unlock();\n        }\n    }\n}\n```\n\n#### 垃圾缓存\n\n当引用类型是弱引用或是虚引用，垃圾缓存才会存在，当JVM对这些缓存进行回收时，会将已经失效的**引用对象**放到特定的ReferenceQueue中，清理便是针对此队列进行，防止无用的引用对象浪费内存空间。\n\ndrainReferenceQueues:\n\n```java\n@GuardedBy(\"this\")\nvoid drainReferenceQueues() {\n    if (map.usesKeyReferences()) {\n        drainKeyReferenceQueue();\n    }\n    if (map.usesValueReferences()) {\n        drainValueReferenceQueue();\n    }\n}\n```\n\n以drainKeyReferenceQueue为例:\n\n```java\n@GuardedBy(\"this\")\nvoid drainKeyReferenceQueue() {\n    Reference<? extends K> ref;\n    int i = 0;\n    while ((ref = keyReferenceQueue.poll()) != null) {\n        @SuppressWarnings(\"unchecked\")\n        ReferenceEntry<K, V> entry = (ReferenceEntry<K, V>) ref;\n        map.reclaimKey(entry);\n        if (++i == DRAIN_MAX) {\n            break;\n        }\n    }\n}\n```\n\nDRAIN_MAX取值16，猜测这样做的目的在于降低开销，防止一次put操作耗费过多的时间。\n\nreclaimKey用于清理ReferenceEntry对象，因为**keyReference和valueReference是保存在此类中的**。\n\n```java\nboolean reclaimKey(ReferenceEntry<K, V> entry, int hash) {\n    lock();\n    try {\n        int newCount = count - 1;\n        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;\n        int index = hash & (table.length() - 1);\n        ReferenceEntry<K, V> first = table.get(index);\n\n        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {\n            if (e == entry) {\n                ++modCount;\n                ReferenceEntry<K, V> newFirst =\n                    removeValueFromChain(\n                        first,\n                        e,\n                        e.getKey(),\n                        hash,\n                        e.getValueReference().get(),\n                        e.getValueReference(),\n                        RemovalCause.COLLECTED);\n                newCount = this.count - 1;\n                table.set(index, newFirst);\n                this.count = newCount; // write-volatile\n                return true;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}\n```\n\n注意两点:\n\n- guava cache也是**采用链表的形式解决hash冲突的**。源码中for循环便是遍历链表寻找指定的引用的过程。\n- removeValueFromChain方法真正的完成移除value的操作。\n\nremoveValueFromChain:\n\n```java\nReferenceEntry<K, V> removeValueFromChain(\n    ReferenceEntry<K, V> first,\n    ReferenceEntry<K, V> entry,\n    @Nullable K key,\n    int hash, V value, ValueReference<K, V> valueReference, RemovalCause cause) {\n        enqueueNotification(key, hash, value, valueReference.getWeight(), cause);\n        writeQueue.remove(entry);\n        accessQueue.remove(entry);\n        if (valueReference.isLoading()) {\n            valueReference.notifyNewValue(null);\n            return first;\n        } else {\n            return removeEntryFromChain(first, entry);\n        }\n}\n```\n\n##### 善后\n\nenqueueNotification用于进行一些移除之后的善后工作(然而却是在 移除之前执行的):\n\n```java\n@GuardedBy(\"this\")\nvoid enqueueNotification(@Nullable K key, int hash, @Nullable V value, int weight, RemovalCause cause) {\n    //减少权重\n    totalWeight -= weight;\n    //分析统计\n    if (cause.wasEvicted()) {\n        statsCounter.recordEviction();\n    }\n    if (map.removalNotificationQueue != DISCARDING_QUEUE) {\n        RemovalNotification<K, V> notification = RemovalNotification.create(key, value, cause);\n        map.removalNotificationQueue.offer(notification);\n    }\n}\n```\n\n加入removalNotificationQueue的目的在于通知我们自定义的**移除监听器**，LocalCache构造器相关源码回顾:\n\n```java\n//...\nremovalListener = builder.getRemovalListener();\n    removalNotificationQueue =\n        (removalListener == NullListener.INSTANCE)\n            ? LocalCache.<RemovalNotification<K, V>>discardingQueue()\n            : new ConcurrentLinkedQueue<RemovalNotification<K, V>>();\n//...\n```\n\n可以通过CacheBuilder的removalListener方法指定监听器。\n\n##### writeQueue移除\n\n初始化在Segment构造器，相关源码:\n\n```java\n writeQueue =\n          map.usesWriteQueue()\n              ? new WriteQueue<K, V>()\n              : LocalCache.<ReferenceEntry<K, V>>discardingQueue();\n```\n\nusesWriteQueue最终的逻辑在expiresAfterWrite:\n\n```java\nboolean expiresAfterWrite() {\n    return expireAfterWriteNanos > 0;\n}\n```\n\n这其实是guava cache提供的一种缓存淘汰策略，即**记录最后一次执行写入的时间，按照此时间间隔进行淘汰**，WriteQueue用于按照写入的顺序进行排序，直接继承自JDK的AbstractQueue。\n\n此策略可以通过CacheBuilder的expireAfterWrite方法进行开启。\n\nWriteQueue利用了双端队列实现了时间轴的概念，即**每次在队列前段插入新节点**，示意:\n\n>  ----进入时间最短-----Enter-->--D-->--C-->--B-->--A-->--进入时间最久-----\n\n当需要进行回收的时候，只需要从前往后遍历队列，只要找到一个过期的缓存，那么可以保证**此缓存后续的所有缓存都已过期.**\n\n##### accessQueue移除\n\n原理和writeQueue一样，此策略通过CacheBuilder的expireAfterAccess方法进行开启。\n\n##### 加载终止\n\n如果已被回收的key对应的value尚处于正在加载的状态，那么将终止加载过程。有意义的实现位于LoadingValueReference\n(其它类均是空实现):\n\n```java\n@Override\npublic void notifyNewValue(@Nullable V newValue) {\n    if (newValue != null) {\n        // The pending load was clobbered by a manual write.\n        // Unblock all pending gets, and have them return the new value.\n        set(newValue);\n    } else {\n        // The pending load was removed. Delay notifications until loading completes.\n        oldValue = unset();\n    }\n    // TODO(fry): could also cancel loading if we had a handle on its future\n}\n```\n\nunset方法返回一个占位符对象，此对象用以说明此ValueReference将被加载。\n\n##### 移除算法\n\n真正的移除位于removeEntryFromChain方法中:\n\n```java\n@GuardedBy(\"this\")\n@Nullable\nReferenceEntry<K, V> removeEntryFromChain(ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry) {\n    int newCount = count;\n    ReferenceEntry<K, V> newFirst = entry.getNext();\n    for (ReferenceEntry<K, V> e = first; e != entry; e = e.getNext()) {\n        ReferenceEntry<K, V> next = copyEntry(e, newFirst);\n        if (next != null) {\n            newFirst = next;\n        } else {\n            removeCollectedEntry(e);\n            newCount--;\n        }\n    }\n    this.count = newCount;\n    return newFirst;\n}\n```\n\n移除算法并未采用从前往后遍历的方式，下面以图来说明。\n\n假设链表最初的结构如下所示:\n\n![初始](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/entry_before_remove.png)\n\n处理之后的结构:\n\n![之后](https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/entry_after_remove.png)\n\n结合源码看出，**节点移除实际上导致了一条新的链表的创建**，那么为什么不采用直接将2和4连接的方式呢?\n\nWeakEntry部分源码:\n\n```java\nfinal int hash;\nfinal ReferenceEntry<K, V> next;\nvolatile ValueReference<K, V> valueReference = unset();\n```\n\n可以看出，next指针被定义为final，这样可以保证**即使有读线程在并发(读操作是没有加锁的)地读取，也可以读取到数据，只不过是过期的数据**，这里是CopyOnWrite思想的体现。\n\n#### 过期缓存\n\nexpireEntries:\n\n```java\n@GuardedBy(\"this\")\nvoid expireEntries(long now) {\n    //recencyQueue和accessQueue区分不清，暂且跳过\n    drainRecencyQueue();\n    ReferenceEntry<K, V> e;\n    while ((e = writeQueue.peek()) != null && map.isExpired(e, now)) {\n        if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {\n            throw new AssertionError();\n        }\n    }\n    while ((e = accessQueue.peek()) != null && map.isExpired(e, now)) {\n        if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {\n            throw new AssertionError();\n        }\n    }\n}\n```\n\n逻辑到这里就很明确了。\n\n### 扩容\n\n相关源码:\n\n```java\nint newCount = this.count + 1;\nif (newCount > this.threshold) { // ensure capacity\n    expand();\n    newCount = this.count + 1;\n}\n```\n\nguava cache扩容仍然采用了ConcurrentHashMap的思想。**扩容是针对Segment进行的，而不是整个Map，这样可以保证一个Segment的扩容不会对其它的Segment访问造成影响。**\n\n**扩容都是在原来的基础上进行两倍扩容**，ConcurrentHashMap针对此特性做出了一定的优化措施，以原长度为16，扩容到32为例:\n\n16的Mask:\n\n 01111\n\n32的Mask:\n\n11111\n\n也就是说，如果对象的hashCode的高一位是0，那么其在新数组中的位置其实是不变的，这些也就无需复制。\n\n源码不再贴出。\n\n### 设值\n\n。。。\n\n# get(key)\n\n即LocalLoadingCache.get:\n\n```java\n@Override\npublic V get(K key) throws ExecutionException {\n    return localCache.getOrLoad(key);\n}\n```\n\nLocalCache.getOrLoad:\n\n```java\nV getOrLoad(K key) throws ExecutionException {\n    return get(key, defaultLoader);\n}\n```\n\ndefaultLoader便是在构造时指定的CacheLoader对象。\n\nLocalCache.get:\n\n```java\nV get(K key, CacheLoader<? super K, V> loader) throws ExecutionException {\n    int hash = hash(checkNotNull(key));\n    return segmentFor(hash).get(key, hash, loader);\n}\n```\n\n## get(key,hash,loader)\n\nSegment.get简略版源码:\n\n```java\nV get(K key, int hash, CacheLoader<? super K, V> loader) throws ExecutionException {\n  try {\n    //快速判断\n    if (count != 0) { // read-volatile\n      //遍历寻找\n      ReferenceEntry<K, V> e = getEntry(key, hash);\n      if (e != null) {\n        long now = map.ticker.read();\n        //判断Entry是否已经过期、被回收或是正在加载，如果是，返回null\n        V value = getLiveValue(e, now);\n        if (value != null) {\n          recordRead(e, now);\n          statsCounter.recordHits(1);\n          return scheduleRefresh(e, key, hash, value, now, loader);\n        }\n        ValueReference<K, V> valueReference = e.getValueReference();\n        if (valueReference.isLoading()) {\n          //阻塞等待直到加载完成\n          return waitForLoadingValue(e, key, valueReference);\n        }\n      }\n    }\n    // at this point e is either null or expired;\n    //加锁再次遍历或是加载\n    return lockedGetOrLoad(key, hash, loader);\n  } catch (ExecutionException ee) {\n    throw ee;\n  } finally {\n    postReadCleanup();\n  }\n}\n```\n\n逻辑注释里已经很清楚了，这里只需要补充一点，scheduleRefresh方法:\n\n```java\nV scheduleRefresh(ReferenceEntry<K, V> entry,K key,int hash,V oldValue,long now,CacheLoader<? super K, V> loader) {\n    if (map.refreshes()\n        && (now - entry.getWriteTime() > map.refreshNanos)\n        && !entry.getValueReference().isLoading()) {\n        V newValue = refresh(key, hash, loader, true);\n        if (newValue != null) {\n            return newValue;\n        }\n    }\n    return oldValue;\n}\n```\n\nrefreshes()方法的条件是refreshNanos > 0，这其实是guava cache提供的自动刷新机制，可以通过CacheBuilder的refreshAfterWrite方法进行设置。\n\n# 参考\n\n很好的两篇博客:\n\n[为什么ConcurrentHashMap可以这么快？](http://www.cnblogs.com/cm4j/p/cc_1.html)\n\n[高并发下数据写入与过期](http://www.cnblogs.com/cm4j/p/cc_2.html)\n\n# 总结\n\nGuava cache其实是在ConcurrentHashMap的基础上加入了过期、权重、自动刷新等特性。\n\n', '', '2', 0, '2020-01-08 17:04:54', '2020-01-08 17:04:54', '2020-01-08 16:51:09', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA\">创建</a>\n<ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>\n<ul>\n<li><a href=\"#segments\">segments</a></li>\n<li><a href=\"#referenceentry\">ReferenceEntry</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\">初始化</a>\n<ul>\n<li><a href=\"#referenceentry%E6%95%B0%E7%BB%84\">ReferenceEntry数组</a></li>\n<li><a href=\"#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97\">引用队列</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#put\">put</a>\n<ul>\n<li><a href=\"#hash%E7%AE%97%E6%B3%95\">Hash算法</a></li>\n<li><a href=\"#rehash\">ReHash</a></li>\n<li><a href=\"#segment%E9%80%89%E5%8F%96\">Segment选取</a></li>\n<li><a href=\"#segmentput\">Segment.put</a>\n<ul>\n<li><a href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7\">线程安全性</a></li>\n<li><a href=\"#%E8%BF%87%E6%9C%9F%E5%9E%83%E5%9C%BE%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86\">过期/垃圾缓存清理</a>\n<ul>\n<li><a href=\"#%E5%9E%83%E5%9C%BE%E7%BC%93%E5%AD%98\">垃圾缓存</a>\n<ul>\n<li><a href=\"#%E5%96%84%E5%90%8E\">善后</a></li>\n<li><a href=\"#writequeue%E7%A7%BB%E9%99%A4\">writeQueue移除</a></li>\n<li><a href=\"#accessqueue%E7%A7%BB%E9%99%A4\">accessQueue移除</a></li>\n<li><a href=\"#%E5%8A%A0%E8%BD%BD%E7%BB%88%E6%AD%A2\">加载终止</a></li>\n<li><a href=\"#%E7%A7%BB%E9%99%A4%E7%AE%97%E6%B3%95\">移除算法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%87%E6%9C%9F%E7%BC%93%E5%AD%98\">过期缓存</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%89%A9%E5%AE%B9\">扩容</a></li>\n<li><a href=\"#%E8%AE%BE%E5%80%BC\">设值</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#getkey\">get(key)</a>\n<ul>\n<li><a href=\"#getkeyhashloader\">get(key,hash,loader)</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n\n<h1>创建</h1>\n<p>以CacheLoader的方式为例:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(2)\n    .build(new CacheLoader&lt;String, String&gt;() {\n        @Override\n         public String load(String s) throws Exception {\n            return \"Hello: \" + s;\n        }\n    });\n</code></pre>\n<p>创建的关键便在于build方法,build方法的核心逻辑位于LocalCache构造器，构造器完成了两件事:</p>\n<ul>\n<li>将设置的属性从CacheBuilder复制到LocalCache。</li>\n<li>构造缓存存储的数据结构，此数据结构可以理解为一个自己实现的ConcurrentHashMap(分段锁)。</li>\n</ul>\n<p>数据结构的示意图:</p>\n<p><img src=\"https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/guava-cache.jpg\" alt=\"guava-cache\"></p>\n<h2>数据结构</h2>\n<h3>segments</h3>\n<p>Segment代表了其中的一段。其类图(部分):</p>\n<p><img src=\"https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Segment.jpg\" alt=\"Segment类图\"></p>\n<p>此类继承ReentrantLock的目的在于方便的进行加锁操作。</p>\n<p>那么Segment的个数是如何确定的呢?</p>\n<p><strong>取最小的大于等于目的并行度的2的整次幂，如果设置了按权重大小的淘汰策略，那么还应注意总的权重值不超过给定的上限，每个Segment的权重按20计</strong>。</p>\n<p>相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">LocalCache(\n      CacheBuilder&lt;? super K, ? super V&gt; builder, @Nullable CacheLoader&lt;? super K, V&gt; loader) {\n    concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);\n    int segmentCount = 1;\n    while (segmentCount &lt; concurrencyLevel &amp;&amp; (!evictsBySize() || segmentCount * 20 &lt;= maxWeight)) {\n      ++segmentShift;\n      segmentCount &lt;&lt;= 1;\n    }\n}\n</code></pre>\n<p>并行度即并发修改缓存值的线程数，可以通过CacheBuilder的concurrencyLevel方法进行设置，默认4.</p>\n<h3>ReferenceEntry</h3>\n<p>ReferenceEntry是guava-cache中实际进行存储的数据结构，其类图:</p>\n<p><img src=\"https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ReferenceEntry.jpg\" alt=\"ReferenceEntry类图\"></p>\n<p>那么在初始状态下，每个Segment中有多少个ReferenceEntry呢?</p>\n<p><strong>取最小的大于等于(initialCapacity / segmentCount)的2的整次幂的值</strong>。关键代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">LocalCache(\n      CacheBuilder&lt;? super K, ? super V&gt; builder, @Nullable CacheLoader&lt;? super K, V&gt; loader) {\n    int segmentCapacity = initialCapacity / segmentCount;\n    if (segmentCapacity * segmentCount &lt; initialCapacity) {\n      ++segmentCapacity;\n    }\n    int segmentSize = 1;\n    while (segmentSize &lt; segmentCapacity) {\n        segmentSize &lt;&lt;= 1;\n    }\n}\n</code></pre>\n<p>initialCapacity由CacheBuilder的同名方法进行设置，默认16.</p>\n<h2>初始化</h2>\n<p>关键代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">LocalCache(\n      CacheBuilder&lt;? super K, ? super V&gt; builder, @Nullable CacheLoader&lt;? super K, V&gt; loader) {\n    if (evictsBySize()) {\n        // Ensure sum of segment max weights = overall max weights\n        long maxSegmentWeight = maxWeight / segmentCount + 1;\n        long remainder = maxWeight % segmentCount;\n        for (int i = 0; i &lt; this.segments.length; ++i) {\n            if (i == remainder) {\n                maxSegmentWeight--;\n            }\n            this.segments[i] =\n                createSegment(segmentSize, maxSegmentWeight, builder.getStatsCounterSupplier().get());\n        }\n    } else {\n        for (int i = 0; i &lt; this.segments.length; ++i) {\n         this.segments[i] =\n            createSegment(segmentSize, UNSET_INT, builder.getStatsCounterSupplier().get());\n        }\n    }\n}\n</code></pre>\n<p>可以看出，初始化根据是否启用了权重大小限制分为了两种情况，两种情况的区别在于maxSegmentWeight参数，用以指定此Segment的权重上限。</p>\n<p>createSegment其实就是对Segment构造器的调用，此构造器主要做了两件事:</p>\n<ul>\n<li>初始化ReferenceEntry数组数据结构。</li>\n<li>初始化引用队列。</li>\n</ul>\n<p>下面分开对其进行说明。</p>\n<h3>ReferenceEntry数组</h3>\n<p>关键代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">Segment(LocalCache&lt;K, V&gt; map, int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter) {\n     initTable(newEntryArray(initialCapacity));\n}\n</code></pre>\n<p>newEntryArray方法只是创建了一个initialCapacity大小的数组，关键在于initTable:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">void initTable(AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newTable) {\n  this.threshold = newTable.length() * 3 / 4; // 0.75\n  if (!map.customWeigher() &amp;&amp; this.threshold == maxSegmentWeight) {\n    // prevent spurious expansion before eviction\n    this.threshold++;\n  }\n  this.table = newTable;\n}\n</code></pre>\n<p>这里完成的是对临界值的设置，超过此值数据将进行扩张。</p>\n<h3>引用队列</h3>\n<p>关键代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">Segment(LocalCache&lt;K, V&gt; map, int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter) {\n    //当不是强引用的时候成立\n    keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue&lt;K&gt;() : null;\n    valueReferenceQueue = map.usesValueReferences() ? new ReferenceQueue&lt;V&gt;() : null;\n    recencyQueue =\n        map.usesAccessQueue()\n        ? new ConcurrentLinkedQueue&lt;ReferenceEntry&lt;K, V&gt;&gt;()\n        : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();\n    writeQueue =\n        map.usesWriteQueue()\n        ? new WriteQueue&lt;K, V&gt;()\n        : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();\n    accessQueue =\n        map.usesAccessQueue()\n        ? new AccessQueue&lt;K, V&gt;()\n        : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();\n}\n</code></pre>\n<p>keyReferenceQueue和valueReferenceQueue用于结合软引用、弱引用以及虚引用使用，关于java中四种引用的区别以及ReferenceQueue的用途，参考:</p>\n<p><a href=\"http://blog.csdn.net/lyfi01/article/details/6415726\">Java对象的强、软、弱和虚引用原理+结合ReferenceQueue对象构造Java对象的高速缓存器</a></p>\n<p>usesKeyReferences源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">boolean usesKeyReferences() {\n    return keyStrength != Strength.STRONG;\n}\n</code></pre>\n<p>keyStrength通过CacheBuilder.getKeyStrength获取:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">Strength getKeyStrength() {\n    return MoreObjects.firstNonNull(keyStrength, Strength.STRONG);\n}\n</code></pre>\n<p>可以看出，<strong>默认采用强引用的方式</strong>。我们可以通过CacheBuilder的softValues、weakKeys，weakValues方法对其进行设置。</p>\n<p>recencyQueue等队列将在后面结合get方法进行说明。</p>\n<h1>put</h1>\n<p>LocalCache.put:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic V put(K key, V value) {\n    checkNotNull(key);\n    checkNotNull(value);\n    int hash = hash(key);\n    return segmentFor(hash).put(key, hash, value, false);\n}\n</code></pre>\n<h2>Hash算法</h2>\n<p>LocalCache.hash:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">int hash(@Nullable Object key) {\n    int h = keyEquivalence.hash(key);\n    return rehash(h);\n}\n</code></pre>\n<p>keyEquivalence是策略模式的体现，针对不同的引用方式(LocalCache.Strength)提供不同的hash算法实现。</p>\n<p>Equivalence接口类图:</p>\n<p><img src=\"https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Equivalence.jpg\" alt=\"Equivalence类图\"></p>\n<p>keyEquivalence属性由CacheBuilder的getKeyEquivalence方法获得:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">Equivalence&lt;Object&gt; getKeyEquivalence() {\n    return MoreObjects.firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());\n}\n</code></pre>\n<p>可以看出，<strong>使用的hash算法与Strength相关联</strong>。Strength部分源码(仅展示defaultEquivalence方法):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">enum Strength {\n    STRONG {\n        @Override\n        Equivalence&lt;Object&gt; defaultEquivalence() {\n            return Equivalence.equals();\n        }\n    },\n    SOFT {\n        @Override\n        Equivalence&lt;Object&gt; defaultEquivalence() {\n            return Equivalence.identity();\n        }\n    },\n    WEAK {\n        @Override\n        Equivalence&lt;Object&gt; defaultEquivalence() {\n            return Equivalence.identity();\n        }\n    }\n};\n</code></pre>\n<p>以强引用为例。Equivalence.equals()返回的其实是一个单例的Equals对象，由上面类图可以看出，Equals是Equivalence的子类，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">static final class Equals extends Equivalence&lt;Object&gt; implements Serializable {\n\n    static final Equals INSTANCE = new Equals();\n\n    @Override\n    protected boolean doEquivalent(Object a, Object b) {\n        return a.equals(b);\n    }\n\n    @Override\n    protected int doHash(Object o) {\n        return o.hashCode();\n    }\n\n    private Object readResolve() {\n        return INSTANCE;\n    }\n}\n</code></pre>\n<p>可以看出，对于强引用来说，其哈希算法就是JDK Object的hashCode方法。</p>\n<p>而对于weak和soft引用来说，对应的是Identity实例，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">static final class Identity extends Equivalence&lt;Object&gt; implements Serializable {\n    static final Identity INSTANCE = new Identity();\n    @Override\n    protected boolean doEquivalent(Object a, Object b) {\n        return false;\n    }\n    @Override\n    protected int doHash(Object o) {\n        return System.identityHashCode(o);\n    }\n    private Object readResolve() {\n        return INSTANCE;\n    }\n}\n</code></pre>\n<p>identityHashCode返回的是<strong>默认hashCode方法的计算结果，即根据内存地址计算而来的结果</strong>。</p>\n<p>至于为什么要分开处理，暂时未知。</p>\n<h2>ReHash</h2>\n<p>guava cache采用了和ConcurrentHashMap同样的算法。</p>\n<h2>Segment选取</h2>\n<p>LocalCache.segmentFor:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">Segment&lt;K, V&gt; segmentFor(int hash) {\n    return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];\n}\n</code></pre>\n<p>segmentShift和segmentMask的取值，LocalCache构造器源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">int segmentShift = 0;\nint segmentCount = 1;\nwhile (segmentCount &lt; concurrencyLevel &amp;&amp; (!evictsBySize() || segmentCount * 20 &lt;= maxWeight)) {\n    ++segmentShift;\n    segmentCount &lt;&lt;= 1;\n}\nthis.segmentShift = 32 - segmentShift;\nsegmentMask = segmentCount - 1;\n</code></pre>\n<p>可以看出，寻找Segment的过程其实是对<strong>hashCode先取高n位，再取余的过程</strong>。</p>\n<h2>Segment.put</h2>\n<p>源码很长，下面分部分说明。</p>\n<h3>线程安全性</h3>\n<p>部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Nullable\nV put(K key, int hash, V value, boolean onlyIfAbsent) {\n    lock();\n    try {\n        //...\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}\n</code></pre>\n<p>可见，核心逻辑都位于锁的保护之中。</p>\n<h3>过期/垃圾缓存清理</h3>\n<p>相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">long now = map.ticker.read();\npreWriteCleanup(now);\n</code></pre>\n<p>ticker.read方法返回的实际上就是System.nanoTime的值。preWriteCleanup最终调用runLockedCleanup方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">void runLockedCleanup(long now) {\n    //必定通过\n    if (tryLock()) {\n        try {\n            drainReferenceQueues();\n            expireEntries(now); // calls drainRecencyQueue\n            readCount.set(0);\n        } finally {\n            unlock();\n        }\n    }\n}\n</code></pre>\n<h4>垃圾缓存</h4>\n<p>当引用类型是弱引用或是虚引用，垃圾缓存才会存在，当JVM对这些缓存进行回收时，会将已经失效的<strong>引用对象</strong>放到特定的ReferenceQueue中，清理便是针对此队列进行，防止无用的引用对象浪费内存空间。</p>\n<p>drainReferenceQueues:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@GuardedBy(\"this\")\nvoid drainReferenceQueues() {\n    if (map.usesKeyReferences()) {\n        drainKeyReferenceQueue();\n    }\n    if (map.usesValueReferences()) {\n        drainValueReferenceQueue();\n    }\n}\n</code></pre>\n<p>以drainKeyReferenceQueue为例:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@GuardedBy(\"this\")\nvoid drainKeyReferenceQueue() {\n    Reference&lt;? extends K&gt; ref;\n    int i = 0;\n    while ((ref = keyReferenceQueue.poll()) != null) {\n        @SuppressWarnings(\"unchecked\")\n        ReferenceEntry&lt;K, V&gt; entry = (ReferenceEntry&lt;K, V&gt;) ref;\n        map.reclaimKey(entry);\n        if (++i == DRAIN_MAX) {\n            break;\n        }\n    }\n}\n</code></pre>\n<p>DRAIN_MAX取值16，猜测这样做的目的在于降低开销，防止一次put操作耗费过多的时间。</p>\n<p>reclaimKey用于清理ReferenceEntry对象，因为<strong>keyReference和valueReference是保存在此类中的</strong>。</p>\n<pre><code data-language=\"java\" class=\"lang-java\">boolean reclaimKey(ReferenceEntry&lt;K, V&gt; entry, int hash) {\n    lock();\n    try {\n        int newCount = count - 1;\n        AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table;\n        int index = hash &amp; (table.length() - 1);\n        ReferenceEntry&lt;K, V&gt; first = table.get(index);\n\n        for (ReferenceEntry&lt;K, V&gt; e = first; e != null; e = e.getNext()) {\n            if (e == entry) {\n                ++modCount;\n                ReferenceEntry&lt;K, V&gt; newFirst =\n                    removeValueFromChain(\n                        first,\n                        e,\n                        e.getKey(),\n                        hash,\n                        e.getValueReference().get(),\n                        e.getValueReference(),\n                        RemovalCause.COLLECTED);\n                newCount = this.count - 1;\n                table.set(index, newFirst);\n                this.count = newCount; // write-volatile\n                return true;\n            }\n        }\n        return false;\n    } finally {\n        unlock();\n        postWriteCleanup();\n    }\n}\n</code></pre>\n<p>注意两点:</p>\n<ul>\n<li>guava cache也是<strong>采用链表的形式解决hash冲突的</strong>。源码中for循环便是遍历链表寻找指定的引用的过程。</li>\n<li>removeValueFromChain方法真正的完成移除value的操作。</li>\n</ul>\n<p>removeValueFromChain:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">ReferenceEntry&lt;K, V&gt; removeValueFromChain(\n    ReferenceEntry&lt;K, V&gt; first,\n    ReferenceEntry&lt;K, V&gt; entry,\n    @Nullable K key,\n    int hash, V value, ValueReference&lt;K, V&gt; valueReference, RemovalCause cause) {\n        enqueueNotification(key, hash, value, valueReference.getWeight(), cause);\n        writeQueue.remove(entry);\n        accessQueue.remove(entry);\n        if (valueReference.isLoading()) {\n            valueReference.notifyNewValue(null);\n            return first;\n        } else {\n            return removeEntryFromChain(first, entry);\n        }\n}\n</code></pre>\n<h5>善后</h5>\n<p>enqueueNotification用于进行一些移除之后的善后工作(然而却是在 移除之前执行的):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@GuardedBy(\"this\")\nvoid enqueueNotification(@Nullable K key, int hash, @Nullable V value, int weight, RemovalCause cause) {\n    //减少权重\n    totalWeight -= weight;\n    //分析统计\n    if (cause.wasEvicted()) {\n        statsCounter.recordEviction();\n    }\n    if (map.removalNotificationQueue != DISCARDING_QUEUE) {\n        RemovalNotification&lt;K, V&gt; notification = RemovalNotification.create(key, value, cause);\n        map.removalNotificationQueue.offer(notification);\n    }\n}\n</code></pre>\n<p>加入removalNotificationQueue的目的在于通知我们自定义的<strong>移除监听器</strong>，LocalCache构造器相关源码回顾:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">//...\nremovalListener = builder.getRemovalListener();\n    removalNotificationQueue =\n        (removalListener == NullListener.INSTANCE)\n            ? LocalCache.&lt;RemovalNotification&lt;K, V&gt;&gt;discardingQueue()\n            : new ConcurrentLinkedQueue&lt;RemovalNotification&lt;K, V&gt;&gt;();\n//...\n</code></pre>\n<p>可以通过CacheBuilder的removalListener方法指定监听器。</p>\n<h5>writeQueue移除</h5>\n<p>初始化在Segment构造器，相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\"> writeQueue =\n          map.usesWriteQueue()\n              ? new WriteQueue&lt;K, V&gt;()\n              : LocalCache.&lt;ReferenceEntry&lt;K, V&gt;&gt;discardingQueue();\n</code></pre>\n<p>usesWriteQueue最终的逻辑在expiresAfterWrite:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">boolean expiresAfterWrite() {\n    return expireAfterWriteNanos &gt; 0;\n}\n</code></pre>\n<p>这其实是guava cache提供的一种缓存淘汰策略，即<strong>记录最后一次执行写入的时间，按照此时间间隔进行淘汰</strong>，WriteQueue用于按照写入的顺序进行排序，直接继承自JDK的AbstractQueue。</p>\n<p>此策略可以通过CacheBuilder的expireAfterWrite方法进行开启。</p>\n<p>WriteQueue利用了双端队列实现了时间轴的概念，即<strong>每次在队列前段插入新节点</strong>，示意:</p>\n<blockquote>\n<p>----进入时间最短-----Enter--&gt;--D--&gt;--C--&gt;--B--&gt;--A--&gt;--进入时间最久-----</p>\n</blockquote>\n<p>当需要进行回收的时候，只需要从前往后遍历队列，只要找到一个过期的缓存，那么可以保证<strong>此缓存后续的所有缓存都已过期.</strong></p>\n<h5>accessQueue移除</h5>\n<p>原理和writeQueue一样，此策略通过CacheBuilder的expireAfterAccess方法进行开启。</p>\n<h5>加载终止</h5>\n<p>如果已被回收的key对应的value尚处于正在加载的状态，那么将终止加载过程。有意义的实现位于LoadingValueReference<br>\n(其它类均是空实现):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void notifyNewValue(@Nullable V newValue) {\n    if (newValue != null) {\n        // The pending load was clobbered by a manual write.\n        // Unblock all pending gets, and have them return the new value.\n        set(newValue);\n    } else {\n        // The pending load was removed. Delay notifications until loading completes.\n        oldValue = unset();\n    }\n    // TODO(fry): could also cancel loading if we had a handle on its future\n}\n</code></pre>\n<p>unset方法返回一个占位符对象，此对象用以说明此ValueReference将被加载。</p>\n<h5>移除算法</h5>\n<p>真正的移除位于removeEntryFromChain方法中:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@GuardedBy(\"this\")\n@Nullable\nReferenceEntry&lt;K, V&gt; removeEntryFromChain(ReferenceEntry&lt;K, V&gt; first, ReferenceEntry&lt;K, V&gt; entry) {\n    int newCount = count;\n    ReferenceEntry&lt;K, V&gt; newFirst = entry.getNext();\n    for (ReferenceEntry&lt;K, V&gt; e = first; e != entry; e = e.getNext()) {\n        ReferenceEntry&lt;K, V&gt; next = copyEntry(e, newFirst);\n        if (next != null) {\n            newFirst = next;\n        } else {\n            removeCollectedEntry(e);\n            newCount--;\n        }\n    }\n    this.count = newCount;\n    return newFirst;\n}\n</code></pre>\n<p>移除算法并未采用从前往后遍历的方式，下面以图来说明。</p>\n<p>假设链表最初的结构如下所示:</p>\n<p><img src=\"https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/entry_before_remove.png\" alt=\"初始\"></p>\n<p>处理之后的结构:</p>\n<p><img src=\"https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/entry_after_remove.png\" alt=\"之后\"></p>\n<p>结合源码看出，<strong>节点移除实际上导致了一条新的链表的创建</strong>，那么为什么不采用直接将2和4连接的方式呢?</p>\n<p>WeakEntry部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">final int hash;\nfinal ReferenceEntry&lt;K, V&gt; next;\nvolatile ValueReference&lt;K, V&gt; valueReference = unset();\n</code></pre>\n<p>可以看出，next指针被定义为final，这样可以保证<strong>即使有读线程在并发(读操作是没有加锁的)地读取，也可以读取到数据，只不过是过期的数据</strong>，这里是CopyOnWrite思想的体现。</p>\n<h4>过期缓存</h4>\n<p>expireEntries:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@GuardedBy(\"this\")\nvoid expireEntries(long now) {\n    //recencyQueue和accessQueue区分不清，暂且跳过\n    drainRecencyQueue();\n    ReferenceEntry&lt;K, V&gt; e;\n    while ((e = writeQueue.peek()) != null &amp;&amp; map.isExpired(e, now)) {\n        if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {\n            throw new AssertionError();\n        }\n    }\n    while ((e = accessQueue.peek()) != null &amp;&amp; map.isExpired(e, now)) {\n        if (!removeEntry(e, e.getHash(), RemovalCause.EXPIRED)) {\n            throw new AssertionError();\n        }\n    }\n}\n</code></pre>\n<p>逻辑到这里就很明确了。</p>\n<h3>扩容</h3>\n<p>相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">int newCount = this.count + 1;\nif (newCount &gt; this.threshold) { // ensure capacity\n    expand();\n    newCount = this.count + 1;\n}\n</code></pre>\n<p>guava cache扩容仍然采用了ConcurrentHashMap的思想。<strong>扩容是针对Segment进行的，而不是整个Map，这样可以保证一个Segment的扩容不会对其它的Segment访问造成影响。</strong></p>\n<p><strong>扩容都是在原来的基础上进行两倍扩容</strong>，ConcurrentHashMap针对此特性做出了一定的优化措施，以原长度为16，扩容到32为例:</p>\n<p>16的Mask:</p>\n<p>01111</p>\n<p>32的Mask:</p>\n<p>11111</p>\n<p>也就是说，如果对象的hashCode的高一位是0，那么其在新数组中的位置其实是不变的，这些也就无需复制。</p>\n<p>源码不再贴出。</p>\n<h3>设值</h3>\n<p>。。。</p>\n<h1>get(key)</h1>\n<p>即LocalLoadingCache.get:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic V get(K key) throws ExecutionException {\n    return localCache.getOrLoad(key);\n}\n</code></pre>\n<p>LocalCache.getOrLoad:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">V getOrLoad(K key) throws ExecutionException {\n    return get(key, defaultLoader);\n}\n</code></pre>\n<p>defaultLoader便是在构造时指定的CacheLoader对象。</p>\n<p>LocalCache.get:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">V get(K key, CacheLoader&lt;? super K, V&gt; loader) throws ExecutionException {\n    int hash = hash(checkNotNull(key));\n    return segmentFor(hash).get(key, hash, loader);\n}\n</code></pre>\n<h2>get(key,hash,loader)</h2>\n<p>Segment.get简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">V get(K key, int hash, CacheLoader&lt;? super K, V&gt; loader) throws ExecutionException {\n  try {\n    //快速判断\n    if (count != 0) { // read-volatile\n      //遍历寻找\n      ReferenceEntry&lt;K, V&gt; e = getEntry(key, hash);\n      if (e != null) {\n        long now = map.ticker.read();\n        //判断Entry是否已经过期、被回收或是正在加载，如果是，返回null\n        V value = getLiveValue(e, now);\n        if (value != null) {\n          recordRead(e, now);\n          statsCounter.recordHits(1);\n          return scheduleRefresh(e, key, hash, value, now, loader);\n        }\n        ValueReference&lt;K, V&gt; valueReference = e.getValueReference();\n        if (valueReference.isLoading()) {\n          //阻塞等待直到加载完成\n          return waitForLoadingValue(e, key, valueReference);\n        }\n      }\n    }\n    // at this point e is either null or expired;\n    //加锁再次遍历或是加载\n    return lockedGetOrLoad(key, hash, loader);\n  } catch (ExecutionException ee) {\n    throw ee;\n  } finally {\n    postReadCleanup();\n  }\n}\n</code></pre>\n<p>逻辑注释里已经很清楚了，这里只需要补充一点，scheduleRefresh方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">V scheduleRefresh(ReferenceEntry&lt;K, V&gt; entry,K key,int hash,V oldValue,long now,CacheLoader&lt;? super K, V&gt; loader) {\n    if (map.refreshes()\n        &amp;&amp; (now - entry.getWriteTime() &gt; map.refreshNanos)\n        &amp;&amp; !entry.getValueReference().isLoading()) {\n        V newValue = refresh(key, hash, loader, true);\n        if (newValue != null) {\n            return newValue;\n        }\n    }\n    return oldValue;\n}\n</code></pre>\n<p>refreshes()方法的条件是refreshNanos &gt; 0，这其实是guava cache提供的自动刷新机制，可以通过CacheBuilder的refreshAfterWrite方法进行设置。</p>\n<h1>参考</h1>\n<p>很好的两篇博客:</p>\n<p><a href=\"http://www.cnblogs.com/cm4j/p/cc_1.html\">为什么ConcurrentHashMap可以这么快？</a></p>\n<p><a href=\"http://www.cnblogs.com/cm4j/p/cc_2.html\">高并发下数据写入与过期</a></p>\n<h1>总结</h1>\n<p>Guava cache其实是在ConcurrentHashMap的基础上加入了过期、权重、自动刷新等特性。</p>\n');
INSERT INTO `tb_article` VALUES (314, 'spring-aop笔记', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'seaswalker', 'aop配置和解析', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [开头](#%E5%BC%80%E5%A4%B4)\n- [aop:config](#aopconfig)\n  - [解析](#%E8%A7%A3%E6%9E%90)\n    - [proxy-target-class & expose-proxy](#proxy-target-class--expose-proxy)\n    - [aop:pointcut](#aoppointcut)\n    - [aop:advisor](#aopadvisor)\n    - [aop:aspect](#aopaspect)\n      - [aop:declare-parents](#aopdeclare-parents)\n      - [其它](#%E5%85%B6%E5%AE%83)\n        - [MethodLocatingFactoryBean](#methodlocatingfactorybean)\n        - [SimpleBeanFactoryAwareAspectInstanceFactory](#simplebeanfactoryawareaspectinstancefactory)\n      - [总结](#%E6%80%BB%E7%BB%93)\n  - [代理子类生成](#%E4%BB%A3%E7%90%86%E5%AD%90%E7%B1%BB%E7%94%9F%E6%88%90)\n    - [入口](#%E5%85%A5%E5%8F%A3)\n    - [postProcessBeforeInstantiation](#postprocessbeforeinstantiation)\n      - [调用时机](#%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA)\n      - [源码](#%E6%BA%90%E7%A0%81)\n      - [应该代理 ?](#%E5%BA%94%E8%AF%A5%E4%BB%A3%E7%90%86-)\n        - [基础类检测](#%E5%9F%BA%E7%A1%80%E7%B1%BB%E6%A3%80%E6%B5%8B)\n        - [跳过类检测](#%E8%B7%B3%E8%BF%87%E7%B1%BB%E6%A3%80%E6%B5%8B)\n          - [AOP逻辑](#aop%E9%80%BB%E8%BE%91)\n          - [Advisor寻找](#advisor%E5%AF%BB%E6%89%BE)\n          - [适用性检测](#%E9%80%82%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B)\n        - [检测结果缓存](#%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98)\n      - [TargetSource](#targetsource)\n    - [postProcessAfterInitialization](#postprocessafterinitialization)\n      - [Advisor寻找](#advisor%E5%AF%BB%E6%89%BE-1)\n        - [适用性判断](#%E9%80%82%E7%94%A8%E6%80%A7%E5%88%A4%E6%96%AD)\n          - [引入](#%E5%BC%95%E5%85%A5)\n          - [其它](#%E5%85%B6%E5%AE%83-1)\n        - [Advisor扩展](#advisor%E6%89%A9%E5%B1%95)\n        - [排序](#%E6%8E%92%E5%BA%8F)\n      - [创建](#%E5%88%9B%E5%BB%BA)\n        - [JDK动态代理 or Cglib](#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-or-cglib)\n        - [JDK动态代理](#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)\n          - [equals & hashCode](#equals--hashcode)\n          - [链式调用](#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8)\n        - [Cglib](#cglib)\n- [aop:scoped-proxy](#aopscoped-proxy)\n  - [解析](#%E8%A7%A3%E6%9E%90-1)\n    - [入口](#%E5%85%A5%E5%8F%A3-1)\n    - [装饰](#%E8%A3%85%E9%A5%B0)\n  - [代理生成](#%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90)\n    - [Advisor](#advisor)\n    - [引入](#%E5%BC%95%E5%85%A5-1)\n  - [例子](#%E4%BE%8B%E5%AD%90)\n    - [自定义Scope](#%E8%87%AA%E5%AE%9A%E4%B9%89scope)\n    - [配置](#%E9%85%8D%E7%BD%AE)\n    - [测试](#%E6%B5%8B%E8%AF%95)\n  - [原理](#%E5%8E%9F%E7%90%86)\n    - [doGetBean](#dogetbean)\n    - [代理子类](#%E4%BB%A3%E7%90%86%E5%AD%90%E7%B1%BB)\n    - [CallbackFilter & Callback](#callbackfilter--callback)\n      - [Callback](#callback)\n      - [CallbackFilter](#callbackfilter)\n    - [回调](#%E5%9B%9E%E8%B0%83)\n- [aop:aspectj-autoproxy](#aopaspectj-autoproxy)\n  - [属性](#%E5%B1%9E%E6%80%A7)\n    - [proxy-target-class](#proxy-target-class)\n    - [expose-proxy](#expose-proxy)\n  - [栗子](#%E6%A0%97%E5%AD%90)\n    - [切面](#%E5%88%87%E9%9D%A2)\n    - [被代理类](#%E8%A2%AB%E4%BB%A3%E7%90%86%E7%B1%BB)\n    - [配置](#%E9%85%8D%E7%BD%AE-1)\n  - [解析](#%E8%A7%A3%E6%9E%90-2)\n  - [原理](#%E5%8E%9F%E7%90%86-1)\n  - [总结](#%E6%80%BB%E7%BB%93-1)\n- [拾遗](#%E6%8B%BE%E9%81%97)\n  - [AOP切面的坑](#aop%E5%88%87%E9%9D%A2%E7%9A%84%E5%9D%91)\n    - [总结](#%E6%80%BB%E7%BB%93-2)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 开头\n\naop部分的解析器由AopNamespaceHandler注册，其init方法:\n\n```java\n@Override\npublic void init() {\n    registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser());\n    registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser());\n    registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());\n}\n```\n\n# aop:config\n\n此标签用以配置pointcut, advisor, aspect，实例:\n\n```xml\n<aop:config>\n    <aop:pointcut expression=\"execution(* exam.service..*.*(..))\" id=\"transaction\"/>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"transaction\"/>\n    <aop:aspect ref=\"\" />\n</aop:config>\n```\n\nConfigBeanDefinitionParser.parse:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    CompositeComponentDefinition compositeDef =\n            new CompositeComponentDefinition(element.getTagName(), \n            parserContext.extractSource(element));\n    parserContext.pushContainingComponent(compositeDef);\n    // 是否生成代理类\n    configureAutoProxyCreator(parserContext, element);\n    List<Element> childElts = DomUtils.getChildElements(element);\n    for (Element elt: childElts) {\n        String localName = parserContext.getDelegate().getLocalName(elt);\n        if (POINTCUT.equals(localName)) {\n            parsePointcut(elt, parserContext);\n        } else if (ADVISOR.equals(localName)) {\n            parseAdvisor(elt, parserContext);\n        } else if (ASPECT.equals(localName)) {\n            parseAspect(elt, parserContext);\n        }\n    }\n    parserContext.popAndRegisterContainingComponent();\n    return null;\n}\n```\n\n## 解析\n\n解析的过程主要分为以下几个部分。\n\n### proxy-target-class & expose-proxy\n\n对应着aop:config的两个属性，前者代表是否为被代理这生成CGLIB子类，默认false，只为接口生成代理子类(话说如果不生成子类那么怎么拦截?)。后者代表是否将代理bean暴露给用户，如果暴露，可以通过Spring AopContext类获得，默认不暴露。\n\n解析的过程无非就是属性的读取，不再详细说明。\n\n### aop:pointcut\n\npointcut的解析是一个生成一个BeanDefinition并将其id, expression等属性保存在BeanDefinition中。注意以下几点:\n\n- BeanDefinition的ID来自于id属性，如果没有，那么自动生成。\n- BeanDefinition的class是AspectJExpressionPointcut。\n- BeanDefinition的scope为prototype。\n\nAspectJExpressionPointcut类图:\n\n![AspectJExpressionPointcut类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJExpressionPointcut.jpg)\n\n### aop:advisor\n\n首先是其所有属性的示例:\n\n```xml\n<aop:advisor id=\"\" order=\"\" advice-ref=\"aopAdvice\" pointcut=\"\" pointcut-ref=\"\" />\n```\n\nadvisor概念是Spring独有的，来自于上古时代，应该是较早时候的aop概念的实现: [AOP Alliance (Java/J2EE AOP standards)](http://aopalliance.sourceforge.net/)。Spring官方的说法: [aop-schema-advisors](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-schema-advisors)。\n\n其相关的包/类就在spring-aop下:\n\n![aopalliance包]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/aopalliance.png)\n\nadvice-ref是必须的属性，**并且这里的advice必须实现org.aopalliance.aop.Advice的子接口**。这些子接口指的什么呢，见Spring官方文档: [aop-api-advice-types](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html#aop-api-advice-types)。比如org.aopalliance.intercept.MethodInterceptor。\n\n最常见的用途就是结合事务使用:\n\n```xml\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>\n        <tx:method name=\"get*\" read-only=\"true\" propagation=\"NOT_SUPPORTED\"/>\n        <tx:method name=\"find*\" read-only=\"true\" propagation=\"NOT_SUPPORTED\"/>\n        <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n    </tx:attributes>\n</tx:advice>\n\n<aop:config>\n    <aop:pointcut expression=\"execution(* exam.service..*.*(..))\" id=\"transaction\"/>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"transaction\"/>\n</aop:config>\n```\n\n解析的套路和楼上类似，只不过此处的beanClass是DefaultBeanFactoryPointcutAdvisor，其类图:\n\n![DefaultBeanFactoryPointcutAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DefaultBeanFactoryPointcutAdvisor.jpg)\n\n另外注意对于pointcut和pointcut-ref两者处理的区别，对于pointcut属性，Spring会同样创建一个AspectJExpressionPointcut类型的BeanDefinition，对于pointcut-ref会生成一个RuntimeBeanReference对象指向原pointcut的引用。此类的类图:\n\n![RuntimeBeanReference类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RuntimeBeanReference.jpg)\n\n可以看出，这种aop的实现需要实现各种接口，所以不应该再使用此种方式进行aop，除了Spring内部的实现。\n\n### aop:aspect\n\n配置举例:\n\n```xml\n<bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" />\n<!-- 必须配置，因为被代理的对象必须在Spring容器中 -->\n<bean id=\"aopDemo\" class=\"base.aop.AopDemo\" />\n<aop:config>\n    <aop:pointcut id=\"pointcut\" expression=\"execution(* base.aop.AopDemo.send())\" />\n    <aop:aspect ref=\"aopAdvice\">\n        <aop:before method=\"beforeSend\" pointcut-ref=\"pointcut\" />\n        <aop:after method=\"afterSend\" pointcut-ref=\"pointcut\" />\n    </aop:aspect>\n</aop:config>\n```\n\n解析形成的BeanDefinition结构如下:\n\n```html\nAspectComponentDefinition\n    beanRefArray\n        RuntimeBeanReference(aop:aspect的ref属性)\n    beanDefArray\n        // 被注册\n        RootBeanDefinition(aop:declare-parents)\n            beanClass: DeclareParentsAdvisor\n            ConstructorArg\n                implement-interface\n                types-matching\n                default-impl\n                delegate-ref\n        // 被注册\n        RootBeanDefinition(aop:before,aop:after...)\n            beanClass: AspectJPointcutAdvisor\n            ConstructorArg\n                RootBeanDefinition\n                    beanClass: 由子标签决定\n                    ConstructorArg\n                        RootBeanDefinition\n                            beanClass: MethodLocatingFactoryBean\n                            properties\n                                targetBeanName: aspectName\n                                methodName: method属性\n                        RootBeanDefinition\n                            beanClass: SimpleBeanFactoryAwareAspectInstanceFactory\n                            properties\n                                aspectBeanName: aspectName\n                        //还有pointcut定义和引用...\n```\n\n结构图里面的aspectName来自于aop:aspect的ref属性，此属性是必须配置的，因为Spring要知道aop:before等标签指定的方法是哪个bean/类/对象的方法。\n\n#### aop:declare-parents\n\n对于aop:declare-parents子标签，其决定的是代理子类应该实现哪些接口:\n\n```xml\n<aop:declare-parents types-matching=\"\" implement-interface=\"\" />\n```\n\n此标签最终被解析成为beanClass为DeclareParentsAdvisor的BeanDefinition，并注册到容器中。其类图:\n\n![DeclareParentsAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DeclareParentsAdvisor.jpg)\n\n#### 其它\n\n此处的其它指的是aop:before, aop:after等最核心的标签。其最终被解析为beanClass为AspectJPointcutAdvisor的BeanDefinition，类图:\n\n![AspectJPointcutAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJPointcutAdvisor.jpg)\n\n正如上面结构图里所描述的，其构造参数为一个BeanDefintion，此对象的beanClass是不确定的，由aop:before/after中的before和after决定，代码:\n\n```java\nprivate Class<?> getAdviceClass(Element adviceElement, ParserContext parserContext) {\n    String elementName = parserContext.getDelegate().getLocalName(adviceElement);\n    if (BEFORE.equals(elementName)) {\n        return AspectJMethodBeforeAdvice.class;\n    } else if (AFTER.equals(elementName)) {\n        return AspectJAfterAdvice.class;\n    } else if (AFTER_RETURNING_ELEMENT.equals(elementName)) {\n        return AspectJAfterReturningAdvice.class;\n    } else if (AFTER_THROWING_ELEMENT.equals(elementName)) {\n        return AspectJAfterThrowingAdvice.class;\n    } else if (AROUND.equals(elementName)) {\n        return AspectJAroundAdvice.class;\n    }\n}\n```\n\n而此BeanDefintion的构造参数又由以下三个部分组成:\n\n##### MethodLocatingFactoryBean\n\n第一个便是beanClass为此类型的BeanDefinition。其内部有一个methodName属性，存储的便是标签的method属性的值。其类图:\n\n![MethodLocatingFactoryBean类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MethodLocatingFactoryBean.jpg)\n\n这个东西是干什么用的呢?其实是用于在指定的advice(aop:aspect的ref属性)中得到Method对象。入口在setBeanFactory方法:\n\n```java\n@Override\npublic void setBeanFactory(BeanFactory beanFactory) {\n    Class<?> beanClass = beanFactory.getType(this.targetBeanName);\n    this.method = BeanUtils.resolveSignature(this.methodName, beanClass);\n}\n```\n\n##### SimpleBeanFactoryAwareAspectInstanceFactory\n\n其类图:\n\n![SimpleBeanFactoryAwareAspectInstanceFactory类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/SimpleBeanFactoryAwareAspectInstanceFactory.jpg)\n\n此类用于在BeanFactory中定位aspect bean，这个bean指的是谁?\n\n```xml\n<bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" />\n```\n\n就是它!查找很简单:\n\n```java\n@Override\npublic Object getAspectInstance() {\n    return this.beanFactory.getBean(this.aspectBeanName);\n}\n```\n\n#### 总结\n\n从整个aop:aspect标签最终被解析为一个AspectJPointcutAdvisor来看，Spring在实现上仍将其作为Advisor的概念。\n\n## 代理子类生成\n\n关键在于AspectJAwareAdvisorAutoProxyCreator，此对象在ConfigBeanDefinitionParser的configureAutoProxyCreator方法中注册，其类图:\n\n![AspectJAwareAdvisorAutoProxyCreator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJAwareAdvisorAutoProxyCreator.jpg)\n\n那么子类生成的入口在哪里呢?\n\n### 入口\n\n从AspectJAwareAdvisorAutoProxyCreator的类图中可以看出，此类实现了SmartInstantiationAwareBeanPostProcessor接口，所以很容易想到入口应该位于此接口及其父接口(BeanPostProcessor)的相关方法中。实际上确实是这样的。\n\n### postProcessBeforeInstantiation\n\n#### 调用时机\n\n先来回顾一下此方法在Bean创建的过程中的调用时机。\n\nAbstractAutowireCapableBeanFactory.createBean部分源码:\n\n```java\n//// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\nObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\nif (bean != null) {\n    return bean;\n}\nObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n```\n\n可以看出，调用发生在Bean实例的创建之前。\n\n#### 源码\n\nAbstractAutoProxyCreator.postProcessBeforeInstantiation:\n\n```java\n@Override\npublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n    Object cacheKey = getCacheKey(beanClass, beanName);\n    if (beanName == null || !this.targetSourcedBeans.contains(beanName)) {\n        if (this.advisedBeans.containsKey(cacheKey)) {\n            return null;\n        }\n        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {\n            this.advisedBeans.put(cacheKey, Boolean.FALSE);\n            return null;\n        }\n    }\n    if (beanName != null) {\n        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);\n        if (targetSource != null) {\n            this.targetSourcedBeans.add(beanName);\n            Object[] specificInterceptors = \n                getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);\n            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);\n            this.proxyTypes.put(cacheKey, proxy.getClass());\n            return proxy;\n        }\n    }\n    return null;\n}\n```\n\n下面分部分对其进行说明。\n\n#### 应该代理 ?\n\nSpring首先会对当前的beanClass进行检查(是否应该/可以对其进行代理)。\n\n不应该代理的类分为两种情况: \n\n- 用于实现AOP的Spring基础类，此种情况在isInfrastructureClass方法中完成检测(单词Infrastructure正是基础设施的意思)。\n- 子类定义的应该跳过的类，默认AbstractAutoProxyCreator的实现直接返回false，即都不应该跳过。\n\n##### 基础类检测\n\nAbstractAutoProxyCreator.isInfrastructureClass:\n\n```java\nprotected boolean isInfrastructureClass(Class<?> beanClass) {\n    boolean retVal = Advice.class.isAssignableFrom(beanClass) ||\n            Pointcut.class.isAssignableFrom(beanClass) ||\n            Advisor.class.isAssignableFrom(beanClass) ||\n            AopInfrastructureBean.class.isAssignableFrom(beanClass);\n    return retVal;\n}\n```\n\n可以看出，任何Advice、Pointcut、Advisor、AopInfrastructureBean的子类都被当做Spring实现AOP的基础设施类。\n\n##### 跳过类检测\n\n即shouldSkip方法。前面提到了，AbstractAutoProxyCreator的默认实现直接返回fasle，这一特性被子类AspectJAwareAdvisorAutoProxyCreator重写:\n\n```java\n@Override\nprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    for (Advisor advisor : candidateAdvisors) {\n        if (advisor instanceof AspectJPointcutAdvisor) {\n            if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) {\n                return true;\n            }\n        }\n    }\n    return super.shouldSkip(beanClass, beanName);\n}\n```\n\n那么此方法跳过的是谁呢？\n\n其实就是我们通过aop:aspect标签配置的切面，即:\n\n```xml\n<bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" />\n<aop:config>\n    <aop:aspect ref=\"aopAdvice\">\n    </aop:aspect>\n</aop:config>\n```\n\n里的aopAdvice。\n\n从前面的aop:aspect一节中可以知道，Spring对于aop:config的解析其实是把aop:before/after等标签解析成为了AspectJPointcutAdvisor类型的BeanDefinition，而aopAdvice以AbstractAspectJAdvice的类型保存在其中。\n\n所以可以得出结论: **Spring跳过的是适用于当前bean的Advisor的Advice/Aspect对象**。\n\n###### AOP逻辑\n\n![AOP逻辑图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/aop_logic.jpg)\n\n那么Spring又是如何找到适用于当前bean的Advisor的呢?\n\n###### Advisor寻找\n\n关键便是findCandidateAdvisors方法，此方法将逻辑委托给BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans:\n\n```java\npublic List<Advisor> findAdvisorBeans() {\n    String[] advisorNames = null;\n    synchronized (this) {\n         // 结果缓存\n        advisorNames = this.cachedAdvisorBeanNames;\n        if (advisorNames == null) {\n             // 去容器中寻找\n            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                    this.beanFactory, Advisor.class, true, false);\n            this.cachedAdvisorBeanNames = advisorNames;\n        }\n    }\n    if (advisorNames.length == 0) {\n        return new LinkedList<Advisor>();\n    }\n    List<Advisor> advisors = new LinkedList<Advisor>();\n    for (String name : advisorNames) {\n        if (isEligibleBean(name)) {\n            if (!this.beanFactory.isCurrentlyInCreation(name)) {\n                advisors.add(this.beanFactory.getBean(name, Advisor.class));\n            }\n        }\n    }\n    return advisors;\n}\n```\n\n可以看出，首先是从容器中获取到所有的Advisor示例，然后调用isEligibleBean方法逐一判断Advisor是否适用于当前bean。\n\n###### 适用性检测\n\n指的便是isEligibleBean方法。最终调用的是AbstractAdvisorAutoProxyCreator的同名方法:\n\n```java\nprotected boolean isEligibleAdvisorBean(String beanName) {\n    return true;\n}\n```\n\n而AbstractAdvisorAutoProxyCreator的子类AspectJAwareAdvisorAutoProxyCreator并没有覆盖此方法，所以此处会对**容器中所有的Advisor的Advice进行跳过**。\n\n##### 检测结果缓存\n\n因为postProcessBeforeInstantiation方法会在每个bean初始化之前被调用，所以没有必要每次都真的进行基础类检测和跳过类检测，Spring使用了advisedBeans作为缓存用以提高性能。\n\n#### TargetSource\n\n从源码中可以看出，对于自定义的TargetSource，Spring会立即执行代理子类的创建。Spring的代理其实是针对TargetSource的，其类图:\n\n![TargetSource类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/TargetSource.jpg)\n\n关于此接口在此不展开叙述。\n\n### postProcessAfterInitialization\n\nAbstractAutoProxyCreator.postProcessAfterInitialization:\n\n```java\n@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName) {\n    if (bean != null) {\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n```\n\n关键便在于wrapIfNecessary方法:\n\n```java\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    //自定义TargetSource，已经进行过代理子类生成\n    if (beanName != null && this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n    // Create proxy if we have advice.\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        // 创建\n        Object proxy = createProxy(\n                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n```\n\n可以看出，在此方法的开头又进行了基础类以及跳过类的检测，再次不再赘述。\n\n#### Advisor寻找\n\n即getAdvicesAndAdvisorsForBean方法，这里进行的便是去容器中寻找适用于当前bean的Advisor，最终调用的是\n\nAbstractAdvisorAutoProxyCreator.findEligibleAdvisors:\n\n```java\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n\nfindCandidateAdvisors前面已经说过了。\n\n##### 适用性判断\n\nfindAdvisorsThatCanApply最终调用AopUtils.findAdvisorsThatCanApply:\n\n```java\npublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n    if (candidateAdvisors.isEmpty()) {\n        return candidateAdvisors;\n    }\n    List<Advisor> eligibleAdvisors = new LinkedList<Advisor>();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor) {\n            // already processed\n            continue;\n        }\n        if (canApply(candidate, clazz, hasIntroductions)) {\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    return eligibleAdvisors;\n}\n```\n\n关键在于canApply方法，从源码中可以看出，对于Advisor的判断分为了IntroductionAdvisor以及非IntroductionAdvisor两种情况。\n\n这种分开处理导致了**IntroductionAdvisor在Advisor链中总是位于非IntroductionAdvisor前面**。\n\ncanApply(candidate, clazz)其实等价于canApply(candidate, clazz, false):\n\n```java\npublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n    if (advisor instanceof IntroductionAdvisor) {\n        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n    }\n    else if (advisor instanceof PointcutAdvisor) {\n        PointcutAdvisor pca = (PointcutAdvisor) advisor;\n        return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n    }\n    else {\n        // It doesn\'t have a pointcut so we assume it applies.\n        return true;\n    }\n}\n```\n\n很明显，对于引入Advisor与其它Advisor是两种不同的判断方式。\n\n###### 引入\n\n引入的概念在下面aop:scoped-proxy中有提到。因为引入的目的在于动态地向一个类添加另一种功能(接口)，所以只要判断给定的类是否是要引入到的类即可。\n\n###### 其它\n\nAopUtils.canApply:\n\n```java\npublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n    //是否Pointcut可以匹配当前类\n    if (!pc.getClassFilter().matches(targetClass)) {\n        return false;\n    }\n    MethodMatcher methodMatcher = pc.getMethodMatcher();\n    //是否Pointcut可以匹配所有方法\n    if (methodMatcher == MethodMatcher.TRUE) {\n        // No need to iterate the methods if we\'re matching any method anyway...\n        return true;\n    }\n    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n    }\n    Set<Class<?>> classes = new LinkedHashSet<Class<?>>\n        (ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n    classes.add(targetClass);\n    for (Class<?> clazz : classes) {\n        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n        for (Method method : methods) {\n            if ((introductionAwareMethodMatcher != null &&\n                    introductionAwareMethodMatcher\n                        .matches(method, targetClass, hasIntroductions)) ||\n                    methodMatcher.matches(method, targetClass)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\nSpring的Pointcut由ClassFilter和MethodMatcher两部分组成，其中前者用以判断给定的类是否在Pointcut的匹配范围内，后者用以在ClassFilter匹配满足的情况下判断给定的方法是否在Pointcut匹配的范围内。\n\n从源码中可以看出，如果ClassFilter匹配得到满足并且Pointcut并不能匹配此类的任意方法，便会**用反射的方法获取targetClass(被检测类)的全部方法逐一交由Pointcut的MethodMatcher进行检测**。\n\n关于Pointcut表达式是如何解析及存储的在此不再展开。\n\n##### Advisor扩展\n\nAbstractAdvisorAutoProxyCreator.extendAdvisors允许子类向Advisor链表中添加自己的Advisor。子类AspectJAwareAdvisorAutoProxyCreator重写了此方法，其逻辑是:\n\n如果Advisor链表中的Advisor含有AspectJ Advice，那么将会把一个ExposeInvocationInterceptor添加到链表的表头，目的在于将MethodInvocation以ThreadLocal的方式暴露给后面所有的Advisor，暂不知道具体的用途。\n\n##### 排序\n\n即sortAdvisors方法，用于对实现了Ordered接口的Advisor进行排序。\n\n#### 创建\n\nAbstractAutoProxyCreator.createProxy(略去非关键代码):\n\n```java\nprotected Object createProxy(\n        Class<?> beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {\n    ProxyFactory proxyFactory = new ProxyFactory();\n    proxyFactory.copyFrom(this);\n    //将interceptor适配为Advisor\n    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n    for (Advisor advisor : advisors) {\n        proxyFactory.addAdvisor(advisor);\n    }\n    return proxyFactory.getProxy(getProxyClassLoader());\n}\n```\n\n##### JDK动态代理 or Cglib\n\n由DefaultAopProxyFactory.createAopProxy方法决定使用何种方式创建代理子类。\n\n```java\n@Override\npublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n    if (config.isOptimize() || config.isProxyTargetClass() ||\n            hasNoUserSuppliedProxyInterfaces(config)) {\n        Class<?> targetClass = config.getTargetClass();\n        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n            return new JdkDynamicAopProxy(config);\n        }\n        return new ObjenesisCglibAopProxy(config);\n    } else {\n        return new JdkDynamicAopProxy(config);\n    }\n}\n```\n\n逻辑很明显，如果指定了(proxy-target-classs设为true)使用Cglib，那么就会使用Cglib的方式，如果没有指定(或为false)，那么先回检测被代理类是否实现了自己的接口，如果实现了，那么就采用JDK动态代理的方式。\n\n##### JDK动态代理\n\nJdkDynamicAopProxy.getProxy:\n\n```java\n@Override\npublic Object getProxy(ClassLoader classLoader) {\n    //找到可以用来进行代理的接口\n    Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n    //用来代理的接口中是否定义了equals或者是hashCode方法?\n    //结果保存在内部equalsDefined和hashCodeDefined两个成员变量中\n    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n```\n\n可以看出，关键的InvocationHandler参数其实就是JdkDynamicAopProxy自身。\n\n其invoke方法较长，源码就不贴了，下面进行分部分说明。\n\n###### equals & hashCode\n\n如果被代理类实现了equals或者是hashCode方法，那么生成的代理子类的equals、hashCode方法实际上执行的是JdkDynamicAopProxy相应方法的逻辑。\n\ninvoke方法部分源码:\n\n```java\nif (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n    // The target does not implement the equals(Object) method itself.\n    return equals(args[0]);\n}\n```\n\n###### 链式调用\n\n对于切点方法，比如前面aop:aspect示例配置中的beforeSend\n\n```xml\n<aop:before method=\"beforeSend\" pointcut-ref=\"pointcut\" />\n```\n\nSpring会创建一个MethodInvocation对象对所有相关的Advisor进行链式调用。invoke相关源码:\n\n```java\nList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\ninvocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\nObject retVal = invocation.proceed();\n```\n\n##### Cglib\n\n同样是对于Advisor的链式调用，不再详细展开。\n\n# aop:scoped-proxy\n\n此配置一般是这样使用:\n\n```xml\n<bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\">\n    <aop:scoped-proxy/>\n</bean>\n<bean id=\"userManager\" class=\"com.foo.UserManager\">\n    <property name=\"userPreferences\" ref=\"userPreferences\"/>\n</bean>\n```\n\n对于ref属性，**只会在userManager初始化时注入一次**。这会造成什么问题呢?以session的Scope为例，因为只会注入一次，所以，**userManager引用的始终是同一个userPreferences对象，即使现在可能已经过时了**。此配置便可以使userManager引用的其实是一个对代理的引用，所以可以始终获取到最新的userPreferences。\n\n其作用和注解@ScopedProxy相同。\n\n其解析由ScopedProxyBeanDefinitionDecorator完成，类图:\n\n![ScopedProxyBeanDefinitionDecorator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScopedProxyBeanDefinitionDecorator.jpg)\n\n## 解析\n\n### 入口\n\n从类图可以看出，ScopedProxyBeanDefinitionDecorator和之前的解析器都不同，它的调用入口不同以往:\n\nDefaultBeanDefinitionDocumentReader.processBeanDefinition:\n\n```java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n    if (bdHolder != null) {\n         // 装饰\n        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n    }\n}\n```\n\nBeanDefinitionParserDelegate.decorateIfRequired:\n\n```java\npublic BeanDefinitionHolder decorateIfRequired(\n        Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) {\n    String namespaceUri = getNamespaceURI(node);\n    if (!isDefaultNamespace(namespaceUri)) {\n        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver()\n            .resolve(namespaceUri);\n        if (handler != null) {\n            return handler.\n                decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));\n        }\n    }\n    return originalDef;\n}\n```\n\n一目了然。\n\n这么做(装饰)的原因就是此标签是用在bean内部的，从decorate的方法签名可以看出，第二个便是父(bean)BeanDefinition，所以叫做装饰。\n\n### 装饰\n\n```java\n@Override\npublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n    boolean proxyTargetClass = true;\n    if (node instanceof Element) {\n        Element ele = (Element) node;\n        if (ele.hasAttribute(PROXY_TARGET_CLASS)) {\n            proxyTargetClass = Boolean.valueOf(ele.getAttribute(PROXY_TARGET_CLASS));\n        }\n    }\n    BeanDefinitionHolder holder =\n            ScopedProxyUtils.\n            createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);\n    String targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());\n    // 空实现\n    parserContext.getReaderContext().fireComponentRegistered(\n            new BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));\n    return holder;\n}\n```\n\n核心便是createScopedProxy方法，其源码较长，但是这个套路之前见识过了，就是一个偷天换日: 创建一个新的BeanDefinition对象，beanName为被代理的bean的名字，被代理的bean名字为scopedTarget.原名字。被代理的bean扔将被注册到容器中。\n\n新的BeanDefintion的beanClass为ScopedProxyFactoryBean，其类图:\n\n![ScopedProxyFactoryBean类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScopedProxyFactoryBean.jpg)\n\n## 代理生成\n\n入口便是setBeanFactory方法:\n\n```java\n@Override\npublic void setBeanFactory(BeanFactory beanFactory) {\n    ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory;\n    this.scopedTargetSource.setBeanFactory(beanFactory);\n    ProxyFactory pf = new ProxyFactory();\n    pf.copyFrom(this);\n    pf.setTargetSource(this.scopedTargetSource);\n\n    Class<?> beanType = beanFactory.getType(this.targetBeanName);\n    if (!isProxyTargetClass() || beanType.isInterface() || \n        Modifier.isPrivate(beanType.getModifiers())) {\n         // JDK动态代理可用的接口\n        pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader()));\n    }\n    // Add an introduction that implements only the methods on ScopedObject.\n    ScopedObject scopedObject = new DefaultScopedObject\n        (cbf, this.scopedTargetSource.getTargetBeanName());\n    pf.addAdvice(new DelegatingIntroductionInterceptor(scopedObject));\n    // Add the AopInfrastructureBean marker to indicate that the scoped proxy\n    // itself is not subject to auto-proxying! Only its target bean is.\n    pf.addInterface(AopInfrastructureBean.class);\n    this.proxy = pf.getProxy(cbf.getBeanClassLoader());\n}\n```\n\n这个套路上面也见过了。\n\n### Advisor\n\n核心的拦截逻辑是通过DelegatingIntroductionInterceptor来完成的，其类图:\n\n![DelegatingIntroductionInterceptor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DelegatingIntroductionInterceptor.jpg)\n\nAdvisedSupport.addAdvice方法将其转化为Advisor:\n\n```java\n@Override\npublic void addAdvice(int pos, Advice advice) throws AopConfigException {\n    if (advice instanceof IntroductionInfo) {\n        // We don\'t need an IntroductionAdvisor for this kind of introduction:\n        // It\'s fully self-describing.\n        addAdvisor(pos, new DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));\n    } else if (advice instanceof DynamicIntroductionAdvice) {\n        // We need an IntroductionAdvisor for this kind of introduction.\n    } else {\n        addAdvisor(pos, new DefaultPointcutAdvisor(advice));\n    }\n}\n```\n\n显然，DelegatingIntroductionInterceptor被包装为DefaultIntroductionAdvisor对象。\n\nDelegatingIntroductionInterceptor到底是个什么东西呢?这其实就引出了Spring的Introduction(引入)概念。\n\n### 引入\n\n通常意义上的Spring AOP一般是在方法层面上进行逻辑的改变，而引入指的是在不修改类源码的情况下，**直接为一个类添加新的功能**。下面是一个引入使用的例子:\n\n[SpringAOP中的IntroductionInterceptor](http://blog.csdn.net/lzghxjt/article/details/51974336)\n\n## 例子\n\n### 自定义Scope\n\n为了便于测试，我们定义一个生存周期仅仅在于一次调用的Scope，源码:\n\n```java\npublic class OneScope implements Scope {\n\n    private int index = 0;\n\n    @Override\n    public Object get(String name, ObjectFactory<?> objectFactory) {\n        System.out.println(\"get被调用\");\n        return new Student(\"skywalker-\" + (index++), index);\n    }\n    //忽略其它方法\n}\n```\n\n将其注册到容器中，有两种方法:\n\n- 在代码中: \n\n  ```java\n  context.getBeanFactory().registerScope(\"one\", new OneScope());\n  ```\n\n- 配置文件:\n\n  ```xml\n  <bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\">\n    <property name=\"scopes\">\n        <map>\n            <entry key=\"one\">\n                <bean class=\"base.scope.OneScope\" />\n            </entry>\n        </map>\n    </property>\n  </bean>\n  ```\n\n### 配置\n\n此时就可以使用我们自己的Scope了:\n\n```xml\n<bean class=\"base.SimpleBean\" id=\"simpleBean\">\n    <property name=\"student\" ref=\"student\" />\n</bean>\n\n<bean id=\"student\" class=\"base.Student\" scope=\"one\">\n    <aop:scoped-proxy />\n</bean>\n```\n\n### 测试\n\n执行以下代码:\n\n```java\nSimpleBean simpleBean = context.getBean(SimpleBean.class);\nSystem.out.println(simpleBean.getStudent().getName());\nSystem.out.println(simpleBean.getStudent().getName());\n```\n\n可以看到以下输出:\n\n```html\nget被调用\nskywalker-0\nget被调用\nskywalker-1\n```\n\n可以得出结论: **当调用被代理的bean的方法时才会触发Scoped的语义，只是获得其对象(getStudent)没有效果**。\n\n## 原理\n\n### doGetBean\n\n从根本上来说在于AbstractBeanFactory.doGetBean，部分源码:\n\n```java\n//scope非prototype和Singleton\nelse {\n    String scopeName = mbd.getScope();\n    final Scope scope = this.scopes.get(scopeName);\n    Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n        @Override\n        public Object getObject() throws BeansException {\n            beforePrototypeCreation(beanName);\n            try {\n                return createBean(beanName, mbd, args);\n            }\n            finally {\n                afterPrototypeCreation(beanName);\n            }\n        }\n    });\n    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n}\n```\n\nscopes是BeanFactory内部的一个 LinkedHashMap<String, Scope>类型的对象。scope.get实际上调用的就是我们的OneSocpe的get方法，没有用到ObjectFactory。\n\n所以，**每调用一次getBean，就会导致一个新的Sudent被创建并返回**。\n\n### 代理子类\n\n还有一个关键的问题，从上面可以知道SimpleBean内部的student引用其实是一个CGLIB代理子类的对象，那么当调用这个代理对象的相应方法(比如getName)时，是怎样导致Student重新创建(或是getBean被调用)的?\n\n### CallbackFilter & Callback\n\n必须首先理解下CGLIB的这两个概念。\n\n#### Callback\n\n**Callback是Cglib所有自定义逻辑(增强)的共同接口**。\n\n其简略类图:\n\n![Callback类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Callback.jpg)\n\n#### CallbackFilter\n\n**在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。**\n\njdk并不支持这么搞，只支持设置一个InvocationHandler处理(拦截)所有的方法。其类图:\n\n![CallbackFilter类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/CallbackFilter.jpg)\n\nCglib的Enhancer可以指定一个Callback数组，而accept方法的返回值是一个int值，其实就是Callback数组的下标，这样便达到了指定回调逻辑的目的。\n\n参考:\n\n[CGLIB介绍与原理](http://blog.csdn.net/zghwaicsdn/article/details/50957474)\n\n### 回调\n\n一般的方法使用的是DynamicAdvisedInterceptor作为回调逻辑，其intercept关键源码:\n\n```java\n@Override\npublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) {\n    Object target = getTarget();\n}\n```\n\ntarget就是被代理对象。\n\ngetTarget:\n\n```java\nprotected Object getTarget() throws Exception {\n    return this.advised.getTargetSource().getTarget();\n}\n```\n\nTargetSource前面说过了，默认是SimpleBeanTargetSource:\n\n```java\n@Override\npublic Object getTarget() throws Exception {\n    return getBeanFactory().getBean(getTargetBeanName());\n}\n```\n\n至此，真相大白。\n\n# aop:aspectj-autoproxy\n\n此标签用以开启对于@AspectJ注解风格AOP的支持。\n\n## 属性\n\n### proxy-target-class\n\n你懂的。\n\n### expose-proxy\n\n是否应该把代理对象暴露给AopContext，默认false。\n\n## 栗子\n\n### 切面\n\n```java\n@Aspect\npublic class AspectDemo {\n    @Pointcut(\"execution(void base.aop.AopDemo.send(..))\")\n    public void beforeSend() {}\n    @Before(\"beforeSend()\")\n    public void before() {\n        System.out.println(\"send之前\");\n    }\n}\n```\n\n### 被代理类\n\n```java\npublic class AopDemo implements AopDemoInter {\n    public void send() {\n        System.out.println(\"send from aopdemo\");\n    }\n    public void receive() {\n        System.out.println(\"receive from aopdemo\");\n    }\n    @Override\n    public void inter() {\n        System.out.println(\"inter\");\n    }\n}\n```\n\n### 配置\n\n```xml\n<aop:aspectj-autoproxy proxy-target-class=\"true\" />\n<bean class=\"base.aop.AopDemo\" />\n<bean class=\"base.aop.annotation.AspectDemo\" />\n```\n\n因为AopDemo实现了AopDemoInter接口，但做实验的send方法又不在此接口里定义，所以只能用cglib的方式代理。\n\n可以看出，**即使标注了@Aspect注解，仍然需要将切面自己配置到Spring容器中。**\n\n## 解析\n\nAspectJAutoProxyBeanDefinitionParser.parse:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    AopNamespaceUtils.\n        registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n    extendBeanDefinition(element, parserContext);\n    return null;\n}\n```\n\n注册最终在AopConfigUtils.registerOrEscalateApcAsRequired方法中完成，创建器实际上是一个AnnotationAwareAspectJAutoProxyCreator类的对象，此类是前面AspectJAwareAdvisorAutoProxyCreator的子类。\n\n## 原理\n\n既然是AspectJAwareAdvisorAutoProxyCreator的子类，那么其代理子类的创建等核心逻辑自然是一样的。这里所需要关注的地方自然是所不一样的地方: 即是如何体现其注解的特性的。\n\n前面说过，AspectJAwareAdvisorAutoProxyCreator通过findCandidateAdvisors方法来找到适用于bean的Advisor，所以注解的特性也是通过重写此方法来体现。\n\nAnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors:\n\n```java\n@Override\nprotected List<Advisor> findCandidateAdvisors() {\n    List<Advisor> advisors = super.findCandidateAdvisors();\n    //这里\n    advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n    return advisors;\n}\n```\n\nbuildAspectJAdvisors方法所做的便是**从容器中得到所有的bean，逐一判断是不是一个Aspect**。那么判断Aspect的依据是什么?\n\nAbstractAspectJAdvisorFactory.isAspect:\n\n```java\n@Override\npublic boolean isAspect(Class<?> clazz) {\n    return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz));\n}\n```\n\n至于其它的实现细节不再探究。\n\n## 总结\n\nSpring对于AspectJ风格AOP的支持停留在外表(注解)上面，内部的实现仍然是自己的东西。\n\n# 拾遗\n\n## AOP切面的坑\n\n1. 定义在private方法上的切面不会被执行，这个很容易理解，毕竟子类不能覆盖父类的私有方法。\n2. 同一个代理子类内部的方法相互调用不会再次执行切面。\n\n这里以Cglib为例对第二点进行说明，cglib的相关核心组件可以参考前面CallbackFilter & Callback部分。对于配置了一个切面的典型场景，Spring内部的执行流程可总结如下图:\n\n![Cglib调用流程]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/cglib_invocation.png)\n\n核心便是对目标方法的调用上，这里由CglibMethodInvocation的invokeJoinpoint实现:\n\n```java\n@Override\nprotected Object invokeJoinpoint() throws Throwable {\n    if (this.publicMethod) {\n        return this.methodProxy.invoke(this.target, this.arguments);\n    } else {\n        return super.invokeJoinpoint();\n    }\n}\n```\n\n如果是非public方法，那么Spring将使用反射的方法对其进行调用，因为反射将其可访问性设为true。MethodProxy是Cglib对方法代理的抽象，这里的关键是**方法调用的对象(目标)是我们的原生类对象，而不是Cglib代理子类的对象，这就从根本上决定了对同类方法的调用不会再次经过切面**。\n\n### 总结\n\n前面aop:aspectj-autoproxy-属性-expose-proxy一节提到了，Spring允许我们将代理子类暴露出来，可以进行如下配置:\n\n```xml\n<aop:config expose-proxy=\"true\">\n    <aop:advisor advice-ref=\"simpleMethodInterceptor\" pointcut=\"execution(* aop.SimpleAopBean.*(..))\" />\n</aop:config>\n```\n\n当我们需要在一个被代理方法中调用同类的方法时(此方法也需要经过切面)，可以这样调用:\n\n```java\npublic void testB() {\n    System.out.println(\"testB执行\");\n    ((SimpleAopBean) AopContext.currentProxy()).testC();\n}\n```\n\n这里其实是一个ThreadLocal，当Cglib代理子类创建调用链之间便会将代理类设置到其中，DynamicAdvisedInterceptor.intercept相关源码:\n\n```java\nif (this.advised.exposeProxy) {\n    // Make invocation available if necessary.\n    oldProxy = AopContext.setCurrentProxy(proxy);\n    setProxyContext = true;\n}\n```\n\n', '', '2', 0, '2020-01-08 17:05:00', '2020-01-08 17:05:00', '2020-01-08 16:54:32', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#%E5%BC%80%E5%A4%B4\">开头</a></li>\n<li><a href=\"#aopconfig\">aop:config</a>\n<ul>\n<li><a href=\"#%E8%A7%A3%E6%9E%90\">解析</a>\n<ul>\n<li><a href=\"#proxy-target-class--expose-proxy\">proxy-target-class &amp; expose-proxy</a></li>\n<li><a href=\"#aoppointcut\">aop:pointcut</a></li>\n<li><a href=\"#aopadvisor\">aop:advisor</a></li>\n<li><a href=\"#aopaspect\">aop:aspect</a>\n<ul>\n<li><a href=\"#aopdeclare-parents\">aop:declare-parents</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a>\n<ul>\n<li><a href=\"#methodlocatingfactorybean\">MethodLocatingFactoryBean</a></li>\n<li><a href=\"#simplebeanfactoryawareaspectinstancefactory\">SimpleBeanFactoryAwareAspectInstanceFactory</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E4%BB%A3%E7%90%86%E5%AD%90%E7%B1%BB%E7%94%9F%E6%88%90\">代理子类生成</a>\n<ul>\n<li><a href=\"#%E5%85%A5%E5%8F%A3\">入口</a></li>\n<li><a href=\"#postprocessbeforeinstantiation\">postProcessBeforeInstantiation</a>\n<ul>\n<li><a href=\"#%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA\">调用时机</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81\">源码</a></li>\n<li><a href=\"#%E5%BA%94%E8%AF%A5%E4%BB%A3%E7%90%86-\">应该代理 ?</a>\n<ul>\n<li><a href=\"#%E5%9F%BA%E7%A1%80%E7%B1%BB%E6%A3%80%E6%B5%8B\">基础类检测</a></li>\n<li><a href=\"#%E8%B7%B3%E8%BF%87%E7%B1%BB%E6%A3%80%E6%B5%8B\">跳过类检测</a>\n<ul>\n<li><a href=\"#aop%E9%80%BB%E8%BE%91\">AOP逻辑</a></li>\n<li><a href=\"#advisor%E5%AF%BB%E6%89%BE\">Advisor寻找</a></li>\n<li><a href=\"#%E9%80%82%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B\">适用性检测</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98\">检测结果缓存</a></li>\n</ul>\n</li>\n<li><a href=\"#targetsource\">TargetSource</a></li>\n</ul>\n</li>\n<li><a href=\"#postprocessafterinitialization\">postProcessAfterInitialization</a>\n<ul>\n<li><a href=\"#advisor%E5%AF%BB%E6%89%BE-1\">Advisor寻找</a>\n<ul>\n<li><a href=\"#%E9%80%82%E7%94%A8%E6%80%A7%E5%88%A4%E6%96%AD\">适用性判断</a>\n<ul>\n<li><a href=\"#%E5%BC%95%E5%85%A5\">引入</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83-1\">其它</a></li>\n</ul>\n</li>\n<li><a href=\"#advisor%E6%89%A9%E5%B1%95\">Advisor扩展</a></li>\n<li><a href=\"#%E6%8E%92%E5%BA%8F\">排序</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA\">创建</a>\n<ul>\n<li><a href=\"#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-or-cglib\">JDK动态代理 or Cglib</a></li>\n<li><a href=\"#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">JDK动态代理</a>\n<ul>\n<li><a href=\"#equals--hashcode\">equals &amp; hashCode</a></li>\n<li><a href=\"#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\">链式调用</a></li>\n</ul>\n</li>\n<li><a href=\"#cglib\">Cglib</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#aopscoped-proxy\">aop:scoped-proxy</a>\n<ul>\n<li><a href=\"#%E8%A7%A3%E6%9E%90-1\">解析</a>\n<ul>\n<li><a href=\"#%E5%85%A5%E5%8F%A3-1\">入口</a></li>\n<li><a href=\"#%E8%A3%85%E9%A5%B0\">装饰</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90\">代理生成</a>\n<ul>\n<li><a href=\"#advisor\">Advisor</a></li>\n<li><a href=\"#%E5%BC%95%E5%85%A5-1\">引入</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BE%8B%E5%AD%90\">例子</a>\n<ul>\n<li><a href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89scope\">自定义Scope</a></li>\n<li><a href=\"#%E9%85%8D%E7%BD%AE\">配置</a></li>\n<li><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8E%9F%E7%90%86\">原理</a>\n<ul>\n<li><a href=\"#dogetbean\">doGetBean</a></li>\n<li><a href=\"#%E4%BB%A3%E7%90%86%E5%AD%90%E7%B1%BB\">代理子类</a></li>\n<li><a href=\"#callbackfilter--callback\">CallbackFilter &amp; Callback</a>\n<ul>\n<li><a href=\"#callback\">Callback</a></li>\n<li><a href=\"#callbackfilter\">CallbackFilter</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9B%9E%E8%B0%83\">回调</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#aopaspectj-autoproxy\">aop:aspectj-autoproxy</a>\n<ul>\n<li><a href=\"#%E5%B1%9E%E6%80%A7\">属性</a>\n<ul>\n<li><a href=\"#proxy-target-class\">proxy-target-class</a></li>\n<li><a href=\"#expose-proxy\">expose-proxy</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A0%97%E5%AD%90\">栗子</a>\n<ul>\n<li><a href=\"#%E5%88%87%E9%9D%A2\">切面</a></li>\n<li><a href=\"#%E8%A2%AB%E4%BB%A3%E7%90%86%E7%B1%BB\">被代理类</a></li>\n<li><a href=\"#%E9%85%8D%E7%BD%AE-1\">配置</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%A7%A3%E6%9E%90-2\">解析</a></li>\n<li><a href=\"#%E5%8E%9F%E7%90%86-1\">原理</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93-1\">总结</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%8B%BE%E9%81%97\">拾遗</a>\n<ul>\n<li><a href=\"#aop%E5%88%87%E9%9D%A2%E7%9A%84%E5%9D%91\">AOP切面的坑</a>\n<ul>\n<li><a href=\"#%E6%80%BB%E7%BB%93-2\">总结</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n<h1>开头</h1>\n<p>aop部分的解析器由AopNamespaceHandler注册，其init方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void init() {\n    registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser());\n    registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser());\n    registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());\n}\n</code></pre>\n<h1>aop:config</h1>\n<p>此标签用以配置pointcut, advisor, aspect，实例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aop:config&gt;\n    &lt;aop:pointcut expression=\"execution(* exam.service..*.*(..))\" id=\"transaction\"/&gt;\n    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"transaction\"/&gt;\n    &lt;aop:aspect ref=\"\" /&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p>ConfigBeanDefinitionParser.parse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    CompositeComponentDefinition compositeDef =\n            new CompositeComponentDefinition(element.getTagName(), \n            parserContext.extractSource(element));\n    parserContext.pushContainingComponent(compositeDef);\n    // 是否生成代理类\n    configureAutoProxyCreator(parserContext, element);\n    List&lt;Element&gt; childElts = DomUtils.getChildElements(element);\n    for (Element elt: childElts) {\n        String localName = parserContext.getDelegate().getLocalName(elt);\n        if (POINTCUT.equals(localName)) {\n            parsePointcut(elt, parserContext);\n        } else if (ADVISOR.equals(localName)) {\n            parseAdvisor(elt, parserContext);\n        } else if (ASPECT.equals(localName)) {\n            parseAspect(elt, parserContext);\n        }\n    }\n    parserContext.popAndRegisterContainingComponent();\n    return null;\n}\n</code></pre>\n<h2>解析</h2>\n<p>解析的过程主要分为以下几个部分。</p>\n<h3>proxy-target-class &amp; expose-proxy</h3>\n<p>对应着aop:config的两个属性，前者代表是否为被代理这生成CGLIB子类，默认false，只为接口生成代理子类(话说如果不生成子类那么怎么拦截?)。后者代表是否将代理bean暴露给用户，如果暴露，可以通过Spring AopContext类获得，默认不暴露。</p>\n<p>解析的过程无非就是属性的读取，不再详细说明。</p>\n<h3>aop:pointcut</h3>\n<p>pointcut的解析是一个生成一个BeanDefinition并将其id, expression等属性保存在BeanDefinition中。注意以下几点:</p>\n<ul>\n<li>BeanDefinition的ID来自于id属性，如果没有，那么自动生成。</li>\n<li>BeanDefinition的class是AspectJExpressionPointcut。</li>\n<li>BeanDefinition的scope为prototype。</li>\n</ul>\n<p>AspectJExpressionPointcut类图:</p>\n<p>![AspectJExpressionPointcut类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJExpressionPointcut.jpg)</p>\n<h3>aop:advisor</h3>\n<p>首先是其所有属性的示例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aop:advisor id=\"\" order=\"\" advice-ref=\"aopAdvice\" pointcut=\"\" pointcut-ref=\"\" /&gt;\n</code></pre>\n<p>advisor概念是Spring独有的，来自于上古时代，应该是较早时候的aop概念的实现: <a href=\"http://aopalliance.sourceforge.net/\">AOP Alliance (Java/J2EE AOP standards)</a>。Spring官方的说法: <a href=\"http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-schema-advisors\">aop-schema-advisors</a>。</p>\n<p>其相关的包/类就在spring-aop下:</p>\n<p>![aopalliance包]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/aopalliance.png)</p>\n<p>advice-ref是必须的属性，<strong>并且这里的advice必须实现org.aopalliance.aop.Advice的子接口</strong>。这些子接口指的什么呢，见Spring官方文档: <a href=\"http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html#aop-api-advice-types\">aop-api-advice-types</a>。比如org.aopalliance.intercept.MethodInterceptor。</p>\n<p>最常见的用途就是结合事务使用:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt;\n    &lt;tx:attributes&gt;\n        &lt;tx:method name=\"get*\" read-only=\"true\" propagation=\"NOT_SUPPORTED\"/&gt;\n        &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"NOT_SUPPORTED\"/&gt;\n        &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n\n&lt;aop:config&gt;\n    &lt;aop:pointcut expression=\"execution(* exam.service..*.*(..))\" id=\"transaction\"/&gt;\n    &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"transaction\"/&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p>解析的套路和楼上类似，只不过此处的beanClass是DefaultBeanFactoryPointcutAdvisor，其类图:</p>\n<p>![DefaultBeanFactoryPointcutAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DefaultBeanFactoryPointcutAdvisor.jpg)</p>\n<p>另外注意对于pointcut和pointcut-ref两者处理的区别，对于pointcut属性，Spring会同样创建一个AspectJExpressionPointcut类型的BeanDefinition，对于pointcut-ref会生成一个RuntimeBeanReference对象指向原pointcut的引用。此类的类图:</p>\n<p>![RuntimeBeanReference类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RuntimeBeanReference.jpg)</p>\n<p>可以看出，这种aop的实现需要实现各种接口，所以不应该再使用此种方式进行aop，除了Spring内部的实现。</p>\n<h3>aop:aspect</h3>\n<p>配置举例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" /&gt;\n&lt;!-- 必须配置，因为被代理的对象必须在Spring容器中 --&gt;\n&lt;bean id=\"aopDemo\" class=\"base.aop.AopDemo\" /&gt;\n&lt;aop:config&gt;\n    &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* base.aop.AopDemo.send())\" /&gt;\n    &lt;aop:aspect ref=\"aopAdvice\"&gt;\n        &lt;aop:before method=\"beforeSend\" pointcut-ref=\"pointcut\" /&gt;\n        &lt;aop:after method=\"afterSend\" pointcut-ref=\"pointcut\" /&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p>解析形成的BeanDefinition结构如下:</p>\n<pre><code data-language=\"html\" class=\"lang-html\">AspectComponentDefinition\n    beanRefArray\n        RuntimeBeanReference(aop:aspect的ref属性)\n    beanDefArray\n        // 被注册\n        RootBeanDefinition(aop:declare-parents)\n            beanClass:&nbsp;DeclareParentsAdvisor\n            ConstructorArg\n                implement-interface\n                types-matching\n                default-impl\n                delegate-ref\n        // 被注册\n        RootBeanDefinition(aop:before,aop:after...)\n            beanClass:&nbsp;AspectJPointcutAdvisor\n            ConstructorArg\n                RootBeanDefinition\n                    beanClass: 由子标签决定\n                    ConstructorArg\n                        RootBeanDefinition\n                            beanClass:&nbsp;MethodLocatingFactoryBean\n                            properties\n                                targetBeanName: aspectName\n                                methodName: method属性\n                        RootBeanDefinition\n                            beanClass:&nbsp;SimpleBeanFactoryAwareAspectInstanceFactory\n                            properties\n                                aspectBeanName: aspectName\n                        //还有pointcut定义和引用...\n</code></pre>\n<p>结构图里面的aspectName来自于aop:aspect的ref属性，此属性是必须配置的，因为Spring要知道aop:before等标签指定的方法是哪个bean/类/对象的方法。</p>\n<h4>aop:declare-parents</h4>\n<p>对于aop:declare-parents子标签，其决定的是代理子类应该实现哪些接口:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aop:declare-parents types-matching=\"\" implement-interface=\"\" /&gt;\n</code></pre>\n<p>此标签最终被解析成为beanClass为DeclareParentsAdvisor的BeanDefinition，并注册到容器中。其类图:</p>\n<p>![DeclareParentsAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DeclareParentsAdvisor.jpg)</p>\n<h4>其它</h4>\n<p>此处的其它指的是aop:before, aop:after等最核心的标签。其最终被解析为beanClass为AspectJPointcutAdvisor的BeanDefinition，类图:</p>\n<p>![AspectJPointcutAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJPointcutAdvisor.jpg)</p>\n<p>正如上面结构图里所描述的，其构造参数为一个BeanDefintion，此对象的beanClass是不确定的，由aop:before/after中的before和after决定，代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) {\n    String elementName = parserContext.getDelegate().getLocalName(adviceElement);\n    if (BEFORE.equals(elementName)) {\n        return AspectJMethodBeforeAdvice.class;\n    } else if (AFTER.equals(elementName)) {\n        return AspectJAfterAdvice.class;\n    } else if (AFTER_RETURNING_ELEMENT.equals(elementName)) {\n        return AspectJAfterReturningAdvice.class;\n    } else if (AFTER_THROWING_ELEMENT.equals(elementName)) {\n        return AspectJAfterThrowingAdvice.class;\n    } else if (AROUND.equals(elementName)) {\n        return AspectJAroundAdvice.class;\n    }\n}\n</code></pre>\n<p>而此BeanDefintion的构造参数又由以下三个部分组成:</p>\n<h5>MethodLocatingFactoryBean</h5>\n<p>第一个便是beanClass为此类型的BeanDefinition。其内部有一个methodName属性，存储的便是标签的method属性的值。其类图:</p>\n<p>![MethodLocatingFactoryBean类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MethodLocatingFactoryBean.jpg)</p>\n<p>这个东西是干什么用的呢?其实是用于在指定的advice(aop:aspect的ref属性)中得到Method对象。入口在setBeanFactory方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void setBeanFactory(BeanFactory beanFactory) {\n    Class&lt;?&gt; beanClass = beanFactory.getType(this.targetBeanName);\n    this.method = BeanUtils.resolveSignature(this.methodName, beanClass);\n}\n</code></pre>\n<h5>SimpleBeanFactoryAwareAspectInstanceFactory</h5>\n<p>其类图:</p>\n<p>![SimpleBeanFactoryAwareAspectInstanceFactory类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/SimpleBeanFactoryAwareAspectInstanceFactory.jpg)</p>\n<p>此类用于在BeanFactory中定位aspect bean，这个bean指的是谁?</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" /&gt;\n</code></pre>\n<p>就是它!查找很简单:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object getAspectInstance() {\n    return this.beanFactory.getBean(this.aspectBeanName);\n}\n</code></pre>\n<h4>总结</h4>\n<p>从整个aop:aspect标签最终被解析为一个AspectJPointcutAdvisor来看，Spring在实现上仍将其作为Advisor的概念。</p>\n<h2>代理子类生成</h2>\n<p>关键在于AspectJAwareAdvisorAutoProxyCreator，此对象在ConfigBeanDefinitionParser的configureAutoProxyCreator方法中注册，其类图:</p>\n<p>![AspectJAwareAdvisorAutoProxyCreator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJAwareAdvisorAutoProxyCreator.jpg)</p>\n<p>那么子类生成的入口在哪里呢?</p>\n<h3>入口</h3>\n<p>从AspectJAwareAdvisorAutoProxyCreator的类图中可以看出，此类实现了SmartInstantiationAwareBeanPostProcessor接口，所以很容易想到入口应该位于此接口及其父接口(BeanPostProcessor)的相关方法中。实际上确实是这样的。</p>\n<h3>postProcessBeforeInstantiation</h3>\n<h4>调用时机</h4>\n<p>先来回顾一下此方法在Bean创建的过程中的调用时机。</p>\n<p>AbstractAutowireCapableBeanFactory.createBean部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">//// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\nObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\nif (bean != null) {\n    return bean;\n}\nObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n</code></pre>\n<p>可以看出，调用发生在Bean实例的创建之前。</p>\n<h4>源码</h4>\n<p>AbstractAutoProxyCreator.postProcessBeforeInstantiation:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {\n    Object cacheKey = getCacheKey(beanClass, beanName);\n    if (beanName == null || !this.targetSourcedBeans.contains(beanName)) {\n        if (this.advisedBeans.containsKey(cacheKey)) {\n            return null;\n        }\n        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {\n            this.advisedBeans.put(cacheKey, Boolean.FALSE);\n            return null;\n        }\n    }\n    if (beanName != null) {\n        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);\n        if (targetSource != null) {\n            this.targetSourcedBeans.add(beanName);\n            Object[] specificInterceptors = \n                getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);\n            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);\n            this.proxyTypes.put(cacheKey, proxy.getClass());\n            return proxy;\n        }\n    }\n    return null;\n}\n</code></pre>\n<p>下面分部分对其进行说明。</p>\n<h4>应该代理 ?</h4>\n<p>Spring首先会对当前的beanClass进行检查(是否应该/可以对其进行代理)。</p>\n<p>不应该代理的类分为两种情况:</p>\n<ul>\n<li>用于实现AOP的Spring基础类，此种情况在isInfrastructureClass方法中完成检测(单词Infrastructure正是基础设施的意思)。</li>\n<li>子类定义的应该跳过的类，默认AbstractAutoProxyCreator的实现直接返回false，即都不应该跳过。</li>\n</ul>\n<h5>基础类检测</h5>\n<p>AbstractAutoProxyCreator.isInfrastructureClass:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {\n    boolean retVal = Advice.class.isAssignableFrom(beanClass) ||\n            Pointcut.class.isAssignableFrom(beanClass) ||\n            Advisor.class.isAssignableFrom(beanClass) ||\n            AopInfrastructureBean.class.isAssignableFrom(beanClass);\n    return retVal;\n}\n</code></pre>\n<p>可以看出，任何Advice、Pointcut、Advisor、AopInfrastructureBean的子类都被当做Spring实现AOP的基础设施类。</p>\n<h5>跳过类检测</h5>\n<p>即shouldSkip方法。前面提到了，AbstractAutoProxyCreator的默认实现直接返回fasle，这一特性被子类AspectJAwareAdvisorAutoProxyCreator重写:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {\n    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\n    for (Advisor advisor : candidateAdvisors) {\n        if (advisor instanceof AspectJPointcutAdvisor) {\n            if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) {\n                return true;\n            }\n        }\n    }\n    return super.shouldSkip(beanClass, beanName);\n}\n</code></pre>\n<p>那么此方法跳过的是谁呢？</p>\n<p>其实就是我们通过aop:aspect标签配置的切面，即:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" /&gt;\n&lt;aop:config&gt;\n    &lt;aop:aspect ref=\"aopAdvice\"&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p>里的aopAdvice。</p>\n<p>从前面的aop:aspect一节中可以知道，Spring对于aop:config的解析其实是把aop:before/after等标签解析成为了AspectJPointcutAdvisor类型的BeanDefinition，而aopAdvice以AbstractAspectJAdvice的类型保存在其中。</p>\n<p>所以可以得出结论: <strong>Spring跳过的是适用于当前bean的Advisor的Advice/Aspect对象</strong>。</p>\n<h6>AOP逻辑</h6>\n<p>![AOP逻辑图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/aop_logic.jpg)</p>\n<p>那么Spring又是如何找到适用于当前bean的Advisor的呢?</p>\n<h6>Advisor寻找</h6>\n<p>关键便是findCandidateAdvisors方法，此方法将逻辑委托给BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public List&lt;Advisor&gt; findAdvisorBeans() {\n    String[] advisorNames = null;\n    synchronized (this) {\n         // 结果缓存\n        advisorNames = this.cachedAdvisorBeanNames;\n        if (advisorNames == null) {\n             // 去容器中寻找\n            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                    this.beanFactory, Advisor.class, true, false);\n            this.cachedAdvisorBeanNames = advisorNames;\n        }\n    }\n    if (advisorNames.length == 0) {\n        return new LinkedList&lt;Advisor&gt;();\n    }\n    List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();\n    for (String name : advisorNames) {\n        if (isEligibleBean(name)) {\n            if (!this.beanFactory.isCurrentlyInCreation(name)) {\n                advisors.add(this.beanFactory.getBean(name, Advisor.class));\n            }\n        }\n    }\n    return advisors;\n}\n</code></pre>\n<p>可以看出，首先是从容器中获取到所有的Advisor示例，然后调用isEligibleBean方法逐一判断Advisor是否适用于当前bean。</p>\n<h6>适用性检测</h6>\n<p>指的便是isEligibleBean方法。最终调用的是AbstractAdvisorAutoProxyCreator的同名方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected boolean isEligibleAdvisorBean(String beanName) {\n    return true;\n}\n</code></pre>\n<p>而AbstractAdvisorAutoProxyCreator的子类AspectJAwareAdvisorAutoProxyCreator并没有覆盖此方法，所以此处会对<strong>容器中所有的Advisor的Advice进行跳过</strong>。</p>\n<h5>检测结果缓存</h5>\n<p>因为postProcessBeforeInstantiation方法会在每个bean初始化之前被调用，所以没有必要每次都真的进行基础类检测和跳过类检测，Spring使用了advisedBeans作为缓存用以提高性能。</p>\n<h4>TargetSource</h4>\n<p>从源码中可以看出，对于自定义的TargetSource，Spring会立即执行代理子类的创建。Spring的代理其实是针对TargetSource的，其类图:</p>\n<p>![TargetSource类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/TargetSource.jpg)</p>\n<p>关于此接口在此不展开叙述。</p>\n<h3>postProcessAfterInitialization</h3>\n<p>AbstractAutoProxyCreator.postProcessAfterInitialization:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName) {\n    if (bean != null) {\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n</code></pre>\n<p>关键便在于wrapIfNecessary方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    //自定义TargetSource，已经进行过代理子类生成\n    if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n    // Create proxy if we have advice.\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        // 创建\n        Object proxy = createProxy(\n                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n</code></pre>\n<p>可以看出，在此方法的开头又进行了基础类以及跳过类的检测，再次不再赘述。</p>\n<h4>Advisor寻找</h4>\n<p>即getAdvicesAndAdvisorsForBean方法，这里进行的便是去容器中寻找适用于当前bean的Advisor，最终调用的是</p>\n<p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {\n    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\n    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n</code></pre>\n<p>findCandidateAdvisors前面已经说过了。</p>\n<h5>适用性判断</h5>\n<p>findAdvisorsThatCanApply最终调用AopUtils.findAdvisorsThatCanApply:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {\n    if (candidateAdvisors.isEmpty()) {\n        return candidateAdvisors;\n    }\n    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor) {\n            // already processed\n            continue;\n        }\n        if (canApply(candidate, clazz, hasIntroductions)) {\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    return eligibleAdvisors;\n}\n</code></pre>\n<p>关键在于canApply方法，从源码中可以看出，对于Advisor的判断分为了IntroductionAdvisor以及非IntroductionAdvisor两种情况。</p>\n<p>这种分开处理导致了<strong>IntroductionAdvisor在Advisor链中总是位于非IntroductionAdvisor前面</strong>。</p>\n<p>canApply(candidate, clazz)其实等价于canApply(candidate, clazz, false):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {\n    if (advisor instanceof IntroductionAdvisor) {\n        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n    }\n    else if (advisor instanceof PointcutAdvisor) {\n        PointcutAdvisor pca = (PointcutAdvisor) advisor;\n        return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n    }\n    else {\n        // It doesn\'t have a pointcut so we assume it applies.\n        return true;\n    }\n}\n</code></pre>\n<p>很明显，对于引入Advisor与其它Advisor是两种不同的判断方式。</p>\n<h6>引入</h6>\n<p>引入的概念在下面aop:scoped-proxy中有提到。因为引入的目的在于动态地向一个类添加另一种功能(接口)，所以只要判断给定的类是否是要引入到的类即可。</p>\n<h6>其它</h6>\n<p>AopUtils.canApply:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {\n    //是否Pointcut可以匹配当前类\n    if (!pc.getClassFilter().matches(targetClass)) {\n        return false;\n    }\n    MethodMatcher methodMatcher = pc.getMethodMatcher();\n    //是否Pointcut可以匹配所有方法\n    if (methodMatcher == MethodMatcher.TRUE) {\n        // No need to iterate the methods if we\'re matching any method anyway...\n        return true;\n    }\n    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n    }\n    Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;\n        (ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n    classes.add(targetClass);\n    for (Class&lt;?&gt; clazz : classes) {\n        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n        for (Method method : methods) {\n            if ((introductionAwareMethodMatcher != null &amp;&amp;\n                    introductionAwareMethodMatcher\n                        .matches(method, targetClass, hasIntroductions)) ||\n                    methodMatcher.matches(method, targetClass)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n</code></pre>\n<p>Spring的Pointcut由ClassFilter和MethodMatcher两部分组成，其中前者用以判断给定的类是否在Pointcut的匹配范围内，后者用以在ClassFilter匹配满足的情况下判断给定的方法是否在Pointcut匹配的范围内。</p>\n<p>从源码中可以看出，如果ClassFilter匹配得到满足并且Pointcut并不能匹配此类的任意方法，便会<strong>用反射的方法获取targetClass(被检测类)的全部方法逐一交由Pointcut的MethodMatcher进行检测</strong>。</p>\n<p>关于Pointcut表达式是如何解析及存储的在此不再展开。</p>\n<h5>Advisor扩展</h5>\n<p>AbstractAdvisorAutoProxyCreator.extendAdvisors允许子类向Advisor链表中添加自己的Advisor。子类AspectJAwareAdvisorAutoProxyCreator重写了此方法，其逻辑是:</p>\n<p>如果Advisor链表中的Advisor含有AspectJ Advice，那么将会把一个ExposeInvocationInterceptor添加到链表的表头，目的在于将MethodInvocation以ThreadLocal的方式暴露给后面所有的Advisor，暂不知道具体的用途。</p>\n<h5>排序</h5>\n<p>即sortAdvisors方法，用于对实现了Ordered接口的Advisor进行排序。</p>\n<h4>创建</h4>\n<p>AbstractAutoProxyCreator.createProxy(略去非关键代码):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Object createProxy(\n        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {\n    ProxyFactory proxyFactory = new ProxyFactory();\n    proxyFactory.copyFrom(this);\n    //将interceptor适配为Advisor\n    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n    for (Advisor advisor : advisors) {\n        proxyFactory.addAdvisor(advisor);\n    }\n    return proxyFactory.getProxy(getProxyClassLoader());\n}\n</code></pre>\n<h5>JDK动态代理 or Cglib</h5>\n<p>由DefaultAopProxyFactory.createAopProxy方法决定使用何种方式创建代理子类。</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n    if (config.isOptimize() || config.isProxyTargetClass() ||\n            hasNoUserSuppliedProxyInterfaces(config)) {\n        Class&lt;?&gt; targetClass = config.getTargetClass();\n        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n            return new JdkDynamicAopProxy(config);\n        }\n        return new ObjenesisCglibAopProxy(config);\n    } else {\n        return new JdkDynamicAopProxy(config);\n    }\n}\n</code></pre>\n<p>逻辑很明显，如果指定了(proxy-target-classs设为true)使用Cglib，那么就会使用Cglib的方式，如果没有指定(或为false)，那么先回检测被代理类是否实现了自己的接口，如果实现了，那么就采用JDK动态代理的方式。</p>\n<h5>JDK动态代理</h5>\n<p>JdkDynamicAopProxy.getProxy:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object getProxy(ClassLoader classLoader) {\n    //找到可以用来进行代理的接口\n    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n    //用来代理的接口中是否定义了equals或者是hashCode方法?\n    //结果保存在内部equalsDefined和hashCodeDefined两个成员变量中\n    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n</code></pre>\n<p>可以看出，关键的InvocationHandler参数其实就是JdkDynamicAopProxy自身。</p>\n<p>其invoke方法较长，源码就不贴了，下面进行分部分说明。</p>\n<h6>equals &amp; hashCode</h6>\n<p>如果被代理类实现了equals或者是hashCode方法，那么生成的代理子类的equals、hashCode方法实际上执行的是JdkDynamicAopProxy相应方法的逻辑。</p>\n<p>invoke方法部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {\n    // The target does not implement the equals(Object) method itself.\n    return equals(args[0]);\n}\n</code></pre>\n<h6>链式调用</h6>\n<p>对于切点方法，比如前面aop:aspect示例配置中的beforeSend</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aop:before method=\"beforeSend\" pointcut-ref=\"pointcut\" /&gt;\n</code></pre>\n<p>Spring会创建一个MethodInvocation对象对所有相关的Advisor进行链式调用。invoke相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\ninvocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\nObject retVal = invocation.proceed();\n</code></pre>\n<h5>Cglib</h5>\n<p>同样是对于Advisor的链式调用，不再详细展开。</p>\n<h1>aop:scoped-proxy</h1>\n<p>此配置一般是这样使用:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"&gt;\n    &lt;aop:scoped-proxy/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"userManager\" class=\"com.foo.UserManager\"&gt;\n    &lt;property name=\"userPreferences\" ref=\"userPreferences\"/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>对于ref属性，<strong>只会在userManager初始化时注入一次</strong>。这会造成什么问题呢?以session的Scope为例，因为只会注入一次，所以，<strong>userManager引用的始终是同一个userPreferences对象，即使现在可能已经过时了</strong>。此配置便可以使userManager引用的其实是一个对代理的引用，所以可以始终获取到最新的userPreferences。</p>\n<p>其作用和注解@ScopedProxy相同。</p>\n<p>其解析由ScopedProxyBeanDefinitionDecorator完成，类图:</p>\n<p>![ScopedProxyBeanDefinitionDecorator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScopedProxyBeanDefinitionDecorator.jpg)</p>\n<h2>解析</h2>\n<h3>入口</h3>\n<p>从类图可以看出，ScopedProxyBeanDefinitionDecorator和之前的解析器都不同，它的调用入口不同以往:</p>\n<p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n    if (bdHolder != null) {\n         // 装饰\n        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n    }\n}\n</code></pre>\n<p>BeanDefinitionParserDelegate.decorateIfRequired:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public BeanDefinitionHolder decorateIfRequired(\n        Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) {\n    String namespaceUri = getNamespaceURI(node);\n    if (!isDefaultNamespace(namespaceUri)) {\n        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver()\n            .resolve(namespaceUri);\n        if (handler != null) {\n            return handler.\n                decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));\n        }\n    }\n    return originalDef;\n}\n</code></pre>\n<p>一目了然。</p>\n<p>这么做(装饰)的原因就是此标签是用在bean内部的，从decorate的方法签名可以看出，第二个便是父(bean)BeanDefinition，所以叫做装饰。</p>\n<h3>装饰</h3>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n    boolean proxyTargetClass = true;\n    if (node instanceof Element) {\n        Element ele = (Element) node;\n        if (ele.hasAttribute(PROXY_TARGET_CLASS)) {\n            proxyTargetClass = Boolean.valueOf(ele.getAttribute(PROXY_TARGET_CLASS));\n        }\n    }\n    BeanDefinitionHolder holder =\n            ScopedProxyUtils.\n            createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);\n    String targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());\n    // 空实现\n    parserContext.getReaderContext().fireComponentRegistered(\n            new BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));\n    return holder;\n}\n</code></pre>\n<p>核心便是createScopedProxy方法，其源码较长，但是这个套路之前见识过了，就是一个偷天换日: 创建一个新的BeanDefinition对象，beanName为被代理的bean的名字，被代理的bean名字为scopedTarget.原名字。被代理的bean扔将被注册到容器中。</p>\n<p>新的BeanDefintion的beanClass为ScopedProxyFactoryBean，其类图:</p>\n<p>![ScopedProxyFactoryBean类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScopedProxyFactoryBean.jpg)</p>\n<h2>代理生成</h2>\n<p>入口便是setBeanFactory方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void setBeanFactory(BeanFactory beanFactory) {\n    ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory;\n    this.scopedTargetSource.setBeanFactory(beanFactory);\n    ProxyFactory pf = new ProxyFactory();\n    pf.copyFrom(this);\n    pf.setTargetSource(this.scopedTargetSource);\n\n    Class&lt;?&gt; beanType = beanFactory.getType(this.targetBeanName);\n    if (!isProxyTargetClass() || beanType.isInterface() || \n        Modifier.isPrivate(beanType.getModifiers())) {\n         // JDK动态代理可用的接口\n        pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader()));\n    }\n    // Add an introduction that implements only the methods on ScopedObject.\n    ScopedObject scopedObject = new DefaultScopedObject\n        (cbf, this.scopedTargetSource.getTargetBeanName());\n    pf.addAdvice(new DelegatingIntroductionInterceptor(scopedObject));\n    // Add the AopInfrastructureBean marker to indicate that the scoped proxy\n    // itself is not subject to auto-proxying! Only its target bean is.\n    pf.addInterface(AopInfrastructureBean.class);\n    this.proxy = pf.getProxy(cbf.getBeanClassLoader());\n}\n</code></pre>\n<p>这个套路上面也见过了。</p>\n<h3>Advisor</h3>\n<p>核心的拦截逻辑是通过DelegatingIntroductionInterceptor来完成的，其类图:</p>\n<p>![DelegatingIntroductionInterceptor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DelegatingIntroductionInterceptor.jpg)</p>\n<p>AdvisedSupport.addAdvice方法将其转化为Advisor:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void addAdvice(int pos, Advice advice) throws AopConfigException {\n    if (advice instanceof IntroductionInfo) {\n        // We don\'t need an IntroductionAdvisor for this kind of introduction:\n        // It\'s fully self-describing.\n        addAdvisor(pos, new DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));\n    } else if (advice instanceof DynamicIntroductionAdvice) {\n        // We need an IntroductionAdvisor for this kind of introduction.\n    } else {\n        addAdvisor(pos, new DefaultPointcutAdvisor(advice));\n    }\n}\n</code></pre>\n<p>显然，DelegatingIntroductionInterceptor被包装为DefaultIntroductionAdvisor对象。</p>\n<p>DelegatingIntroductionInterceptor到底是个什么东西呢?这其实就引出了Spring的Introduction(引入)概念。</p>\n<h3>引入</h3>\n<p>通常意义上的Spring AOP一般是在方法层面上进行逻辑的改变，而引入指的是在不修改类源码的情况下，<strong>直接为一个类添加新的功能</strong>。下面是一个引入使用的例子:</p>\n<p><a href=\"http://blog.csdn.net/lzghxjt/article/details/51974336\">SpringAOP中的IntroductionInterceptor</a></p>\n<h2>例子</h2>\n<h3>自定义Scope</h3>\n<p>为了便于测试，我们定义一个生存周期仅仅在于一次调用的Scope，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public class OneScope implements Scope {\n\n    private int index = 0;\n\n    @Override\n    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {\n        System.out.println(\"get被调用\");\n        return new Student(\"skywalker-\" + (index++), index);\n    }\n    //忽略其它方法\n}\n</code></pre>\n<p>将其注册到容器中，有两种方法:</p>\n<ul>\n<li>\n<p>在代码中:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">context.getBeanFactory().registerScope(\"one\", new OneScope());\n</code></pre>\n</li>\n<li>\n<p>配置文件:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\"&gt;\n  &lt;property name=\"scopes\"&gt;\n      &lt;map&gt;\n          &lt;entry key=\"one\"&gt;\n              &lt;bean class=\"base.scope.OneScope\" /&gt;\n          &lt;/entry&gt;\n      &lt;/map&gt;\n  &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n</ul>\n<h3>配置</h3>\n<p>此时就可以使用我们自己的Scope了:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean class=\"base.SimpleBean\" id=\"simpleBean\"&gt;\n    &lt;property name=\"student\" ref=\"student\" /&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"student\" class=\"base.Student\" scope=\"one\"&gt;\n    &lt;aop:scoped-proxy /&gt;\n&lt;/bean&gt;\n</code></pre>\n<h3>测试</h3>\n<p>执行以下代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">SimpleBean simpleBean = context.getBean(SimpleBean.class);\nSystem.out.println(simpleBean.getStudent().getName());\nSystem.out.println(simpleBean.getStudent().getName());\n</code></pre>\n<p>可以看到以下输出:</p>\n<pre><code data-language=\"html\" class=\"lang-html\">get被调用\nskywalker-0\nget被调用\nskywalker-1\n</code></pre>\n<p>可以得出结论: <strong>当调用被代理的bean的方法时才会触发Scoped的语义，只是获得其对象(getStudent)没有效果</strong>。</p>\n<h2>原理</h2>\n<h3>doGetBean</h3>\n<p>从根本上来说在于AbstractBeanFactory.doGetBean，部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">//scope非prototype和Singleton\nelse {\n    String scopeName = mbd.getScope();\n    final Scope scope = this.scopes.get(scopeName);\n    Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {\n        @Override\n        public Object getObject() throws BeansException {\n            beforePrototypeCreation(beanName);\n            try {\n                return createBean(beanName, mbd, args);\n            }\n            finally {\n                afterPrototypeCreation(beanName);\n            }\n        }\n    });\n    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n}\n</code></pre>\n<p>scopes是BeanFactory内部的一个 LinkedHashMap&lt;String, Scope&gt;类型的对象。scope.get实际上调用的就是我们的OneSocpe的get方法，没有用到ObjectFactory。</p>\n<p>所以，<strong>每调用一次getBean，就会导致一个新的Sudent被创建并返回</strong>。</p>\n<h3>代理子类</h3>\n<p>还有一个关键的问题，从上面可以知道SimpleBean内部的student引用其实是一个CGLIB代理子类的对象，那么当调用这个代理对象的相应方法(比如getName)时，是怎样导致Student重新创建(或是getBean被调用)的?</p>\n<h3>CallbackFilter &amp; Callback</h3>\n<p>必须首先理解下CGLIB的这两个概念。</p>\n<h4>Callback</h4>\n<p><strong>Callback是Cglib所有自定义逻辑(增强)的共同接口</strong>。</p>\n<p>其简略类图:</p>\n<p>![Callback类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Callback.jpg)</p>\n<h4>CallbackFilter</h4>\n<p><strong>在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</strong></p>\n<p>jdk并不支持这么搞，只支持设置一个InvocationHandler处理(拦截)所有的方法。其类图:</p>\n<p>![CallbackFilter类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/CallbackFilter.jpg)</p>\n<p>Cglib的Enhancer可以指定一个Callback数组，而accept方法的返回值是一个int值，其实就是Callback数组的下标，这样便达到了指定回调逻辑的目的。</p>\n<p>参考:</p>\n<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\">CGLIB介绍与原理</a></p>\n<h3>回调</h3>\n<p>一般的方法使用的是DynamicAdvisedInterceptor作为回调逻辑，其intercept关键源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) {\n    Object target = getTarget();\n}\n</code></pre>\n<p>target就是被代理对象。</p>\n<p>getTarget:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Object getTarget() throws Exception {\n    return this.advised.getTargetSource().getTarget();\n}\n</code></pre>\n<p>TargetSource前面说过了，默认是SimpleBeanTargetSource:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object getTarget() throws Exception {\n    return getBeanFactory().getBean(getTargetBeanName());\n}\n</code></pre>\n<p>至此，真相大白。</p>\n<h1>aop:aspectj-autoproxy</h1>\n<p>此标签用以开启对于@AspectJ注解风格AOP的支持。</p>\n<h2>属性</h2>\n<h3>proxy-target-class</h3>\n<p>你懂的。</p>\n<h3>expose-proxy</h3>\n<p>是否应该把代理对象暴露给AopContext，默认false。</p>\n<h2>栗子</h2>\n<h3>切面</h3>\n<pre><code data-language=\"java\" class=\"lang-java\">@Aspect\npublic class AspectDemo {\n    @Pointcut(\"execution(void base.aop.AopDemo.send(..))\")\n    public void beforeSend() {}\n    @Before(\"beforeSend()\")\n    public void before() {\n        System.out.println(\"send之前\");\n    }\n}\n</code></pre>\n<h3>被代理类</h3>\n<pre><code data-language=\"java\" class=\"lang-java\">public class AopDemo implements AopDemoInter {\n    public void send() {\n        System.out.println(\"send from aopdemo\");\n    }\n    public void receive() {\n        System.out.println(\"receive from aopdemo\");\n    }\n    @Override\n    public void inter() {\n        System.out.println(\"inter\");\n    }\n}\n</code></pre>\n<h3>配置</h3>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt;\n&lt;bean class=\"base.aop.AopDemo\" /&gt;\n&lt;bean class=\"base.aop.annotation.AspectDemo\" /&gt;\n</code></pre>\n<p>因为AopDemo实现了AopDemoInter接口，但做实验的send方法又不在此接口里定义，所以只能用cglib的方式代理。</p>\n<p>可以看出，<strong>即使标注了@Aspect注解，仍然需要将切面自己配置到Spring容器中。</strong></p>\n<h2>解析</h2>\n<p>AspectJAutoProxyBeanDefinitionParser.parse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    AopNamespaceUtils.\n        registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n    extendBeanDefinition(element, parserContext);\n    return null;\n}\n</code></pre>\n<p>注册最终在AopConfigUtils.registerOrEscalateApcAsRequired方法中完成，创建器实际上是一个AnnotationAwareAspectJAutoProxyCreator类的对象，此类是前面AspectJAwareAdvisorAutoProxyCreator的子类。</p>\n<h2>原理</h2>\n<p>既然是AspectJAwareAdvisorAutoProxyCreator的子类，那么其代理子类的创建等核心逻辑自然是一样的。这里所需要关注的地方自然是所不一样的地方: 即是如何体现其注解的特性的。</p>\n<p>前面说过，AspectJAwareAdvisorAutoProxyCreator通过findCandidateAdvisors方法来找到适用于bean的Advisor，所以注解的特性也是通过重写此方法来体现。</p>\n<p>AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected List&lt;Advisor&gt; findCandidateAdvisors() {\n    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();\n    //这里\n    advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n    return advisors;\n}\n</code></pre>\n<p>buildAspectJAdvisors方法所做的便是<strong>从容器中得到所有的bean，逐一判断是不是一个Aspect</strong>。那么判断Aspect的依据是什么?</p>\n<p>AbstractAspectJAdvisorFactory.isAspect:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean isAspect(Class&lt;?&gt; clazz) {\n    return (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));\n}\n</code></pre>\n<p>至于其它的实现细节不再探究。</p>\n<h2>总结</h2>\n<p>Spring对于AspectJ风格AOP的支持停留在外表(注解)上面，内部的实现仍然是自己的东西。</p>\n<h1>拾遗</h1>\n<h2>AOP切面的坑</h2>\n<ol>\n<li>定义在private方法上的切面不会被执行，这个很容易理解，毕竟子类不能覆盖父类的私有方法。</li>\n<li>同一个代理子类内部的方法相互调用不会再次执行切面。</li>\n</ol>\n<p>这里以Cglib为例对第二点进行说明，cglib的相关核心组件可以参考前面CallbackFilter &amp; Callback部分。对于配置了一个切面的典型场景，Spring内部的执行流程可总结如下图:</p>\n<p>![Cglib调用流程]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/cglib_invocation.png)</p>\n<p>核心便是对目标方法的调用上，这里由CglibMethodInvocation的invokeJoinpoint实现:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected Object invokeJoinpoint() throws Throwable {\n    if (this.publicMethod) {\n        return this.methodProxy.invoke(this.target, this.arguments);\n    } else {\n        return super.invokeJoinpoint();\n    }\n}\n</code></pre>\n<p>如果是非public方法，那么Spring将使用反射的方法对其进行调用，因为反射将其可访问性设为true。MethodProxy是Cglib对方法代理的抽象，这里的关键是<strong>方法调用的对象(目标)是我们的原生类对象，而不是Cglib代理子类的对象，这就从根本上决定了对同类方法的调用不会再次经过切面</strong>。</p>\n<h3>总结</h3>\n<p>前面aop:aspectj-autoproxy-属性-expose-proxy一节提到了，Spring允许我们将代理子类暴露出来，可以进行如下配置:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aop:config expose-proxy=\"true\"&gt;\n    &lt;aop:advisor advice-ref=\"simpleMethodInterceptor\" pointcut=\"execution(* aop.SimpleAopBean.*(..))\" /&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<p>当我们需要在一个被代理方法中调用同类的方法时(此方法也需要经过切面)，可以这样调用:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void testB() {\n    System.out.println(\"testB执行\");\n    ((SimpleAopBean) AopContext.currentProxy()).testC();\n}\n</code></pre>\n<p>这里其实是一个ThreadLocal，当Cglib代理子类创建调用链之间便会将代理类设置到其中，DynamicAdvisedInterceptor.intercept相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (this.advised.exposeProxy) {\n    // Make invocation available if necessary.\n    oldProxy = AopContext.setCurrentProxy(proxy);\n    setProxyContext = true;\n}\n</code></pre>\n');
INSERT INTO `tb_article` VALUES (315, 'spring-boot笔记', 'http://47.100.57.39/static/uploads/c5/25a4dbacc072dbc5db67555c8a86c4.jpg', 'seaswalker', 'SpringApplication以及run的分析\n', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [SpringApplication](#springapplication)\n  - [web环境检测](#web%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B)\n  - [ApplicationContextInitializer](#applicationcontextinitializer)\n  - [ApplicationListener](#applicationlistener)\n  - [SpringApplicationRunListener](#springapplicationrunlistener)\n- [run](#run)\n  - [starting](#starting)\n  - [环境准备](#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87)\n    - [属性来源](#%E5%B1%9E%E6%80%A7%E6%9D%A5%E6%BA%90)\n    - [profile配置](#profile%E9%85%8D%E7%BD%AE)\n  - [environmentPrepared](#environmentprepared)\n    - [配置文件加载](#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD)\n      - [SpringApplicationJsonEnvironmentPostProcessor](#springapplicationjsonenvironmentpostprocessor)\n      - [CloudFoundryVcapEnvironmentPostProcessor](#cloudfoundryvcapenvironmentpostprocessor)\n      - [ConfigFileApplicationListener](#configfileapplicationlistener)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# SpringApplication\n\n启动程序首先初始化了一个SpringApplication对象。来看一看在它的构造器了发生了什么。\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Object... sources) {\n	this.resourceLoader = resourceLoader;\n	initialize(sources);\n}\n```\n\ninitialize方法:\n\n```java\nprivate void initialize(Object[] sources) {\n	if (sources != null && sources.length > 0) {\n		this.sources.addAll(Arrays.asList(sources));\n	}\n	this.webEnvironment = deduceWebEnvironment();\n	setInitializers((Collection) getSpringFactoriesInstances(\n			ApplicationContextInitializer.class));\n	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n	this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n## web环境检测\n\ndeduceWebEnvironment方法用于检测当前是否是web工程环境，检测的标准也很简单，classpath中必须同时存在下面这两个类:\n\n- javax.servlet.Servlet\n- org.springframework.web.context.ConfigurableWebApplicationContext\n\n## ApplicationContextInitializer\n\n下一步便是检测应当使用哪些ApplicationContextInitializer，这货并不是spring-boot的专属，而是定义在context下，这东西是在喜闻乐见的refesh方法执行之前留给我们进行自定义初始化的钩子。典型的使用的场景是注册我们自己的属性来源、设置激活的profile。\n\n在简单的web应用场景下(没有数据库/mybatis)，共最终引入了下列的类:\n\n![ApplicationContextInitializer]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationContextInitializer.png)\n\n来自于三个jar包:\n\n- spring-boot\n- spring-boot-autoconfigure\n- spring-beans\n\n## ApplicationListener\n\n这货是典型的观察者模式实现，类图:\n\n![ApplicationListener]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationListener.PNG)\n\n在简单的web应用场景下，系统共初始化了这些监听器:\n\n![ApplicationListener]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationListener_used.png)\n\n## SpringApplicationRunListener\n\n就像它长得那样，就是用来监听SpringApplication的run方法的监听器。看看这货用到了哪些实现类:\n\n![SpringApplicationRunListener]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/SpringApplicationRunListener.png)\n\n# run\n\n从这一节开始，就进入了SpringApplication的run方法的势力范围。整个方法的流程总结如下图:\n\n![SpringApplication.run]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/spring_application_run.png)\n\n## starting\n\nSpringApplicationRunListener其实起一个广播器的作用，将消息广播给ApplicationListener一节初始化的10个Listener中的某几个。\n\ndebug可以发现，对启动事件感兴趣的只有LoggingApplicationListener一个。\n\n 当LoggingApplicationListener监听到启动事件时，所作的主要工作便是决定采用哪一个日志框架，其判断逻辑如下:\n\n- 如果系统变量`org.springframework.boot.logging.LoggingSystem`存在，那么由其决定。\n\n- 依次检测classpath中这些类是否存在:\n\n  ```java\n  ch.qos.logback.core.Appender;\n  org.apache.logging.log4j.core.impl.Log4jContextFactory;\n  java.util.logging.LogManager;\n  ```\n\n## 环境准备\n\n相关源码:\n\n```java\nConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n```\n\nSpring里面的Environment到底是个什么东西，详细参考隔壁(Spring.md)Environment接口一节，总结来说，这货就是属性配置来源(比如系统变量)和profile的综合体。\n\n### 属性来源\n\n在web环境下共初始化了以下4个属性来源:\n\n- System.getProperties()\n- System.getenv()\n- servlet-context-init-params\n- servlet-config-init-params\n\n\n有意思的问题：此时servlet-context-init-params和servlet-config-init-params实际上是一个占位符，无法从这两个来源获得任何真实的属性，等到refresh方法执行时才会被真实的来源替换。\n\n### profile配置\n\nSpringApplication.configureProfiles方法:\n\n```java\nprotected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n	environment.getActiveProfiles(); // ensure they are initialized\n	// But these ones should go first (last wins in a property key clash)\n  	// 默认空\n	Set<String> profiles = new LinkedHashSet<String>(this.additionalProfiles);\n	profiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n	environment.setActiveProfiles(profiles.toArray(new String[profiles.size()]));\n}\n```\n\nactive profile取自上一节中的属性来源，key为`spring.profiles.active`.\n\n## environmentPrepared\n\n### 配置文件加载\n\n监听器ConfigFileApplicationListener负责spring-boot配置文件的加载，ConfigFileApplicationListener默认会从以下的位置搜索配置文件:\n\n1. classpath下的application.properties或application.yml\n2. file:./下的application.properties或application.yml\n3. classpath:config目录下的application.properties或application.yml\n4. file:./config目录下的application.properties或application.yml\n\n此监听器是如何加载的?源码:\n\n```java\nprivate void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n	List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();\n	postProcessors.add(this);\n	AnnotationAwareOrderComparator.sort(postProcessors);\n	for (EnvironmentPostProcessor postProcessor : postProcessors) {\n		postProcessor.postProcessEnvironment(event.getEnvironment(),\n				event.getSpringApplication());\n	}\n}\n```\n\n显然核心的加载操作是通过EnvironmentPostProcessor接口实现的，此接口允许我们在context刷新之前自定义配置加载，并且Spring推荐此接口的实现类同时实现Ordered接口。类图:\n\n![EnvironmentPostProcessor]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EnvironmentPostProcessor.png)\n\n加上ConfigFileApplicationListener自己，spring-boot默认共初始化了三个加载器，其它两个是SpringApplicationJsonEnvironmentPostProcessor和CloudFoundryVcapEnvironmentPostProcessor，下面按照其优先级顺序进行说明。\n\n#### SpringApplicationJsonEnvironmentPostProcessor\n\n尝试读取spring.application.json或SPRING_APPLICATION_JSON系统指定的json配置文件，从这里加载的配置具有最高的优先级，当然，默认是没有的。\n\n#### CloudFoundryVcapEnvironmentPostProcessor\n\n从Cloud Foundry加载配置，这是什么东西问度娘。\n\n#### ConfigFileApplicationListener\n\n这里就是加载配置文件加载一节所说的配置文件的过程。\n\n\n\nTODO: 多profile配置文件加载\n\n\n\n\n\n', '', '2', 0, '2020-01-08 17:05:05', '2020-01-08 17:05:05', '2020-01-08 16:57:25', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#springapplication\">SpringApplication</a>\n<ul>\n<li><a href=\"#web%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B\">web环境检测</a></li>\n<li><a href=\"#applicationcontextinitializer\">ApplicationContextInitializer</a></li>\n<li><a href=\"#applicationlistener\">ApplicationListener</a></li>\n<li><a href=\"#springapplicationrunlistener\">SpringApplicationRunListener</a></li>\n</ul>\n</li>\n<li><a href=\"#run\">run</a>\n<ul>\n<li><a href=\"#starting\">starting</a></li>\n<li><a href=\"#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87\">环境准备</a>\n<ul>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E6%9D%A5%E6%BA%90\">属性来源</a></li>\n<li><a href=\"#profile%E9%85%8D%E7%BD%AE\">profile配置</a></li>\n</ul>\n</li>\n<li><a href=\"#environmentprepared\">environmentPrepared</a>\n<ul>\n<li><a href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD\">配置文件加载</a>\n<ul>\n<li><a href=\"#springapplicationjsonenvironmentpostprocessor\">SpringApplicationJsonEnvironmentPostProcessor</a></li>\n<li><a href=\"#cloudfoundryvcapenvironmentpostprocessor\">CloudFoundryVcapEnvironmentPostProcessor</a></li>\n<li><a href=\"#configfileapplicationlistener\">ConfigFileApplicationListener</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n<h1>SpringApplication</h1>\n<p>启动程序首先初始化了一个SpringApplication对象。来看一看在它的构造器了发生了什么。</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public SpringApplication(ResourceLoader resourceLoader, Object... sources) {\n	this.resourceLoader = resourceLoader;\n	initialize(sources);\n}\n</code></pre>\n<p>initialize方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private void initialize(Object[] sources) {\n	if (sources != null &amp;&amp; sources.length &gt; 0) {\n		this.sources.addAll(Arrays.asList(sources));\n	}\n	this.webEnvironment = deduceWebEnvironment();\n	setInitializers((Collection) getSpringFactoriesInstances(\n			ApplicationContextInitializer.class));\n	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n	this.mainApplicationClass = deduceMainApplicationClass();\n}\n</code></pre>\n<h2>web环境检测</h2>\n<p>deduceWebEnvironment方法用于检测当前是否是web工程环境，检测的标准也很简单，classpath中必须同时存在下面这两个类:</p>\n<ul>\n<li>javax.servlet.Servlet</li>\n<li>org.springframework.web.context.ConfigurableWebApplicationContext</li>\n</ul>\n<h2>ApplicationContextInitializer</h2>\n<p>下一步便是检测应当使用哪些ApplicationContextInitializer，这货并不是spring-boot的专属，而是定义在context下，这东西是在喜闻乐见的refesh方法执行之前留给我们进行自定义初始化的钩子。典型的使用的场景是注册我们自己的属性来源、设置激活的profile。</p>\n<p>在简单的web应用场景下(没有数据库/mybatis)，共最终引入了下列的类:</p>\n<p>![ApplicationContextInitializer]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationContextInitializer.png)</p>\n<p>来自于三个jar包:</p>\n<ul>\n<li>spring-boot</li>\n<li>spring-boot-autoconfigure</li>\n<li>spring-beans</li>\n</ul>\n<h2>ApplicationListener</h2>\n<p>这货是典型的观察者模式实现，类图:</p>\n<p>![ApplicationListener]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationListener.PNG)</p>\n<p>在简单的web应用场景下，系统共初始化了这些监听器:</p>\n<p>![ApplicationListener]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationListener_used.png)</p>\n<h2>SpringApplicationRunListener</h2>\n<p>就像它长得那样，就是用来监听SpringApplication的run方法的监听器。看看这货用到了哪些实现类:</p>\n<p>![SpringApplicationRunListener]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/SpringApplicationRunListener.png)</p>\n<h1>run</h1>\n<p>从这一节开始，就进入了SpringApplication的run方法的势力范围。整个方法的流程总结如下图:</p>\n<p>![SpringApplication.run]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/spring_application_run.png)</p>\n<h2>starting</h2>\n<p>SpringApplicationRunListener其实起一个广播器的作用，将消息广播给ApplicationListener一节初始化的10个Listener中的某几个。</p>\n<p>debug可以发现，对启动事件感兴趣的只有LoggingApplicationListener一个。</p>\n<p>当LoggingApplicationListener监听到启动事件时，所作的主要工作便是决定采用哪一个日志框架，其判断逻辑如下:</p>\n<ul>\n<li>\n<p>如果系统变量<code data-backticks=\"1\">org.springframework.boot.logging.LoggingSystem</code>存在，那么由其决定。</p>\n</li>\n<li>\n<p>依次检测classpath中这些类是否存在:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">ch.qos.logback.core.Appender;\norg.apache.logging.log4j.core.impl.Log4jContextFactory;\njava.util.logging.LogManager;\n</code></pre>\n</li>\n</ul>\n<h2>环境准备</h2>\n<p>相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n</code></pre>\n<p>Spring里面的Environment到底是个什么东西，详细参考隔壁(Spring.md)Environment接口一节，总结来说，这货就是属性配置来源(比如系统变量)和profile的综合体。</p>\n<h3>属性来源</h3>\n<p>在web环境下共初始化了以下4个属性来源:</p>\n<ul>\n<li>System.getProperties()</li>\n<li>System.getenv()</li>\n<li>servlet-context-init-params</li>\n<li>servlet-config-init-params</li>\n</ul>\n<p>有意思的问题：此时servlet-context-init-params和servlet-config-init-params实际上是一个占位符，无法从这两个来源获得任何真实的属性，等到refresh方法执行时才会被真实的来源替换。</p>\n<h3>profile配置</h3>\n<p>SpringApplication.configureProfiles方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n	environment.getActiveProfiles(); // ensure they are initialized\n	// But these ones should go first (last wins in a property key clash)\n  	// 默认空\n	Set&lt;String&gt; profiles = new LinkedHashSet&lt;String&gt;(this.additionalProfiles);\n	profiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n	environment.setActiveProfiles(profiles.toArray(new String[profiles.size()]));\n}\n</code></pre>\n<p>active profile取自上一节中的属性来源，key为<code data-backticks=\"1\">spring.profiles.active</code>.</p>\n<h2>environmentPrepared</h2>\n<h3>配置文件加载</h3>\n<p>监听器ConfigFileApplicationListener负责spring-boot配置文件的加载，ConfigFileApplicationListener默认会从以下的位置搜索配置文件:</p>\n<ol>\n<li>classpath下的application.properties或application.yml</li>\n<li>file:./下的application.properties或application.yml</li>\n<li>classpath:config目录下的application.properties或application.yml</li>\n<li>file:./config目录下的application.properties或application.yml</li>\n</ol>\n<p>此监听器是如何加载的?源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n	List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();\n	postProcessors.add(this);\n	AnnotationAwareOrderComparator.sort(postProcessors);\n	for (EnvironmentPostProcessor postProcessor : postProcessors) {\n		postProcessor.postProcessEnvironment(event.getEnvironment(),\n				event.getSpringApplication());\n	}\n}\n</code></pre>\n<p>显然核心的加载操作是通过EnvironmentPostProcessor接口实现的，此接口允许我们在context刷新之前自定义配置加载，并且Spring推荐此接口的实现类同时实现Ordered接口。类图:</p>\n<p>![EnvironmentPostProcessor]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EnvironmentPostProcessor.png)</p>\n<p>加上ConfigFileApplicationListener自己，spring-boot默认共初始化了三个加载器，其它两个是SpringApplicationJsonEnvironmentPostProcessor和CloudFoundryVcapEnvironmentPostProcessor，下面按照其优先级顺序进行说明。</p>\n<h4>SpringApplicationJsonEnvironmentPostProcessor</h4>\n<p>尝试读取spring.application.json或SPRING_APPLICATION_JSON系统指定的json配置文件，从这里加载的配置具有最高的优先级，当然，默认是没有的。</p>\n<h4>CloudFoundryVcapEnvironmentPostProcessor</h4>\n<p>从Cloud Foundry加载配置，这是什么东西问度娘。</p>\n<h4>ConfigFileApplicationListener</h4>\n<p>这里就是加载配置文件加载一节所说的配置文件的过程。</p>\n<p>TODO: 多profile配置文件加载</p>\n');
INSERT INTO `tb_article` VALUES (316, 'spring-context笔记', 'http://47.100.57.39/static/uploads/f2/4929659b5472b48e90e0132e7c2973.jpg', 'seaswalker', 'annotation-config&component-scan...', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [开头](#%E5%BC%80%E5%A4%B4)\n- [annotation-config](#annotation-config)\n  - [BeanPostProcessor注册](#beanpostprocessor%E6%B3%A8%E5%86%8C)\n    - [AnnotationAwareOrderComparator](#annotationawareordercomparator)\n    - [ContextAnnotationAutowireCandidateResolver](#contextannotationautowirecandidateresolver)\n    - [ConfigurationClassPostProcessor](#configurationclasspostprocessor)\n    - [AutowiredAnnotationBeanPostProcessor](#autowiredannotationbeanpostprocessor)\n    - [RequiredAnnotationBeanPostProcessor](#requiredannotationbeanpostprocessor)\n    - [CommonAnnotationBeanPostProcessor](#commonannotationbeanpostprocessor)\n    - [PersistenceAnnotationBeanPostProcessor](#persistenceannotationbeanpostprocessor)\n    - [EventListenerMethodProcessor](#eventlistenermethodprocessor)\n    - [DefaultEventListenerFactory](#defaulteventlistenerfactory)\n  - [逻辑关系整理](#%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%95%B4%E7%90%86)\n  - [运行](#%E8%BF%90%E8%A1%8C)\n    - [ConfigurationClassPostProcessor](#configurationclasspostprocessor-1)\n      - [postProcessBeanDefinitionRegistry](#postprocessbeandefinitionregistry)\n        - [BeanPostProcessor注册](#beanpostprocessor%E6%B3%A8%E5%86%8C-1)\n          - [ImportAwareBeanPostProcessor](#importawarebeanpostprocessor)\n          - [EnhancedConfigurationBeanPostProcessor](#enhancedconfigurationbeanpostprocessor)\n        - [类解析](#%E7%B1%BB%E8%A7%A3%E6%9E%90)\n          - [bean名字生成策略](#bean%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5)\n      - [postProcessBeanFactory](#postprocessbeanfactory)\n    - [AutowiredAnnotationBeanPostProcessor](#autowiredannotationbeanpostprocessor-1)\n      - [postProcessMergedBeanDefinition](#postprocessmergedbeandefinition)\n        - [入口](#%E5%85%A5%E5%8F%A3)\n        - [源码](#%E6%BA%90%E7%A0%81)\n        - [变量扫描](#%E5%8F%98%E9%87%8F%E6%89%AB%E6%8F%8F)\n        - [方法扫描](#%E6%96%B9%E6%B3%95%E6%89%AB%E6%8F%8F)\n          - [bridge方法](#bridge%E6%96%B9%E6%B3%95)\n          - [PropertyDescriptor](#propertydescriptor)\n      - [postProcessPropertyValues](#postprocesspropertyvalues)\n        - [入口](#%E5%85%A5%E5%8F%A3-1)\n        - [注入](#%E6%B3%A8%E5%85%A5)\n          - [Field注入](#field%E6%B3%A8%E5%85%A5)\n          - [方法注入](#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5)\n    - [RequiredAnnotationBeanPostProcessor](#requiredannotationbeanpostprocessor-1)\n      - [postProcessMergedBeanDefinition](#postprocessmergedbeandefinition-1)\n      - [postProcessPropertyValues](#postprocesspropertyvalues-1)\n        - [结果缓存](#%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98)\n        - [PropertyDescriptor](#propertydescriptor-1)\n        - [测试](#%E6%B5%8B%E8%AF%95)\n    - [CommonAnnotationBeanPostProcessor](#commonannotationbeanpostprocessor-1)\n      - [postProcessMergedBeanDefinition](#postprocessmergedbeandefinition-2)\n        - [父类](#%E7%88%B6%E7%B1%BB)\n        - [子类](#%E5%AD%90%E7%B1%BB)\n      - [postProcessPropertyValues](#postprocesspropertyvalues-2)\n      - [postProcessBeforeInitialization](#postprocessbeforeinitialization)\n      - [postProcessBeforeDestruction](#postprocessbeforedestruction)\n    - [EventListenerMethodProcessor](#eventlistenermethodprocessor-1)\n        - [入口](#%E5%85%A5%E5%8F%A3-2)\n        - [源码](#%E6%BA%90%E7%A0%81-1)\n- [component-scan](#component-scan)\n  - [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [use-default-filters](#use-default-filters)\n    - [扫描器:创建 & 初始化](#%E6%89%AB%E6%8F%8F%E5%99%A8%E5%88%9B%E5%BB%BA--%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [resource-pattern](#resource-pattern)\n    - [name-generator](#name-generator)\n    - [scope-resolver](#scope-resolver)\n    - [scoped-proxy](#scoped-proxy)\n    - [exclude-filter/include-filter](#exclude-filterinclude-filter)\n    - [annotation-config](#annotation-config-1)\n  - [扫描](#%E6%89%AB%E6%8F%8F)\n    - [逐包扫描/BeanDefinition解析](#%E9%80%90%E5%8C%85%E6%89%AB%E6%8F%8Fbeandefinition%E8%A7%A3%E6%9E%90)\n    - [@Scope解析](#scope%E8%A7%A3%E6%9E%90)\n    - [bean名字生成](#bean%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90)\n      - [根据注解](#%E6%A0%B9%E6%8D%AE%E6%B3%A8%E8%A7%A3)\n      - [默认策略](#%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5)\n    - [其它注解解析](#%E5%85%B6%E5%AE%83%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90)\n    - [冲突检测](#%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B)\n    - [代理生成](#%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90)\n    - [BeanDefinition注册](#beandefinition%E6%B3%A8%E5%86%8C)\n  - [Component注册](#component%E6%B3%A8%E5%86%8C)\n- [property-override](#property-override)\n  - [作用](#%E4%BD%9C%E7%94%A8)\n  - [类图](#%E7%B1%BB%E5%9B%BE)\n  - [解析](#%E8%A7%A3%E6%9E%90)\n    - [properties-ref](#properties-ref)\n    - [order](#order)\n    - [ignore-resource-not-found](#ignore-resource-not-found)\n    - [ignore-unresolvable](#ignore-unresolvable)\n    - [local-override](#local-override)\n    - [BeanDefinition](#beandefinition)\n  - [运行](#%E8%BF%90%E8%A1%8C-1)\n    - [属性加载](#%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD)\n    - [属性转换](#%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2)\n    - [属性设置](#%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE)\n- [property-placeholder](#property-placeholder)\n  - [解析](#%E8%A7%A3%E6%9E%90-1)\n    - [system-properties-mode](#system-properties-mode)\n    - [value-separator](#value-separator)\n    - [null-value](#null-value)\n    - [trim-values](#trim-values)\n    - [BeanDefinition](#beandefinition-1)\n  - [运行](#%E8%BF%90%E8%A1%8C-2)\n    - [处理](#%E5%A4%84%E7%90%86)\n- [load-time-weaver & spring-configured](#load-time-weaver--spring-configured)\n  - [javaagent](#javaagent)\n  - [解析](#%E8%A7%A3%E6%9E%90-2)\n    - [LoadTimeWeaver](#loadtimeweaver)\n    - [LoadTimeWeaverBeanDefinitionParser](#loadtimeweaverbeandefinitionparser)\n    - [aspectj-weaving](#aspectj-weaving)\n    - [是否开启](#%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF)\n    - [AspectJWeavingEnabler](#aspectjweavingenabler)\n    - [SpringConfiguredBeanDefinitionParser](#springconfiguredbeandefinitionparser)\n      - [切点(pointcut)](#%E5%88%87%E7%82%B9pointcut)\n        - [inConfigurableBean](#inconfigurablebean)\n        - [beanConstruction](#beanconstruction)\n        - [preConstructionCondition](#preconstructioncondition)\n        - [leastSpecificSuperTypeConstruction](#leastspecificsupertypeconstruction)\n        - [preConstructionConfiguration](#preconstructionconfiguration)\n        - [postConstructionCondition](#postconstructioncondition)\n      - [advise](#advise)\n        - [前置](#%E5%89%8D%E7%BD%AE)\n  - [运行](#%E8%BF%90%E8%A1%8C-3)\n    - [LoadTimeWeaverAware](#loadtimeweaveraware)\n    - [BeanClassLoaderAware](#beanclassloaderaware)\n      - [入口](#%E5%85%A5%E5%8F%A3-3)\n      - [setBeanClassLoader](#setbeanclassloader)\n        - [服务器agent](#%E6%9C%8D%E5%8A%A1%E5%99%A8agent)\n        - [Spring agent](#spring-agent)\n        - [反射](#%E5%8F%8D%E5%B0%84)\n        - [总结](#%E6%80%BB%E7%BB%93)\n    - [ClassFileTransformer](#classfiletransformer)\n    - [Aj](#aj)\n      - [缓存](#%E7%BC%93%E5%AD%98)\n      - [WeavingAdaptor初始化](#weavingadaptor%E5%88%9D%E5%A7%8B%E5%8C%96)\n        - [aop.xml](#aopxml)\n          - [解析](#%E8%A7%A3%E6%9E%90-3)\n          - [注册](#%E6%B3%A8%E5%86%8C)\n      - [总结](#%E6%80%BB%E7%BB%93-1)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 开头\n\n入口方法在BeanDefinitionParserDelegate.parseCustomElement：\n\n```java\nreturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n```\n\nparse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    return findParserForElement(element, parserContext).parse(element, parserContext);\n}\n```\n\nfindParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:\n\n```java\nprivate BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n    String localName = parserContext.getDelegate().getLocalName(element);\n    BeanDefinitionParser parser = this.parsers.get(localName);\n    if (parser == null) {\n        parserContext.getReaderContext().fatal(\n            \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element);\n    }\n    return parser;\n}\n```\n\nlocalName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。\n\n# annotation-config\n\nAnnotationConfigBeanDefinitionParser.parse:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    //返回null\n    Object source = parserContext.extractSource(element);\n    // Obtain bean definitions for all relevant BeanPostProcessors.\n    Set<BeanDefinitionHolder> processorDefinitions =\n            AnnotationConfigUtils.\n                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);\n    // Register component for the surrounding <context:annotation-config> element.\n    CompositeComponentDefinition compDefinition = \n        new CompositeComponentDefinition(element.getTagName(), source);\n    parserContext.pushContainingComponent(compDefinition);\n    // Nest the concrete beans in the surrounding component.\n    for (BeanDefinitionHolder processorDefinition : processorDefinitions) {\n        parserContext.registerComponent(new BeanComponentDefinition(processorDefinition));\n    }\n    // Finally register the composite component.\n    // 空实现\n    parserContext.popAndRegisterContainingComponent();\n    return null;\n}\n```\n## BeanPostProcessor注册\n\nAnnotationConfigUtils.registerAnnotationConfigProcessors源码:\n\n```java\n//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n        BeanDefinitionRegistry registry, Object source) {\n    //将registery强转为DefaultListableBeanFactory类型\n    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n    if (beanFactory != null) {\n        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n        }\n        if (!(beanFactory.getAutowireCandidateResolver() instanceof \n            ContextAnnotationAutowireCandidateResolver)) {\n            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n        }\n    }\n\n    Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<BeanDefinitionHolder>(4);\n\n    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n    if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n    if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition();\n        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n                AnnotationConfigUtils.class.getClassLoader()));\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n    }\n    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n    }\n\n    return beanDefs;\n}\n```\n\n### AnnotationAwareOrderComparator\n\n其继承体系如下:\n\n![Comparator继承体系]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Comparator.jpg)\n\n其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:\n\n[Spring 4.2新特性-使用@Order调整配置类加载顺序](http://www.tuicool.com/articles/VnqUv2)\n\n### ContextAnnotationAutowireCandidateResolver\n\n此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:\n\n![ContextAnnotationAutowireCandidateResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ContextAnnotationAutowireCandidateResolver.jpg)\n\n### ConfigurationClassPostProcessor\n\n此类用于处理标注了@Configuration注解的类。类图:\n\n![ConfigurationClassPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ConfigurationClassPostProcessor.jpg)\n\n### AutowiredAnnotationBeanPostProcessor\n\n此类便用于对标注了@Autowire等注解的bean或是方法进行注入。\n\n![AutowiredAnnotationBeanPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AutowiredAnnotationBeanPostProcessor.jpg)\n\n### RequiredAnnotationBeanPostProcessor\n\n对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。\n\n### CommonAnnotationBeanPostProcessor\n\n用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:\n\n```java\nprivate static final boolean jsr250Present =\n    ClassUtils.isPresent(\"javax.annotation.Resource\", AnnotationConfigUtils.class.getClassLoader());\n```\n\n此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:\n\n![CommonAnnotationBeanPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/CommonAnnotationBeanPostProcessor.jpg)\n\n### PersistenceAnnotationBeanPostProcessor\n\n用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:\n\n```java\nprivate static final boolean jpaPresent =	\n    ClassUtils.isPresent(\"javax.persistence.EntityManagerFactory\", \n        AnnotationConfigUtils.class.getClassLoader()) &&\n    //org.springframework.orm包\n    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, \n        AnnotationConfigUtils.class.getClassLoader());\n```\n\nrt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。\n\n### EventListenerMethodProcessor\n\n提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:\n\n![EventListenerMethodProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EventListenerMethodProcessor.jpg)\n\n### DefaultEventListenerFactory\n\n此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:\n\n![DefaultEventListenerFactory类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DefaultEventListenerFactory.jpg)\n\n## 逻辑关系整理\n\n普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:\n\n![CompositeComponentDefinition类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/CompositeComponentDefinition.jpg)\n\n最终形成的数据结构如下图:\n\n![数据结构]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/context_annotation_stack.png)\n\n不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。\n\n## 运行\n\n### ConfigurationClassPostProcessor\n\n本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:\n\n```java\ninvokeBeanFactoryPostProcessors(beanFactory);\n```\n\n注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。\n\n#### postProcessBeanDefinitionRegistry\n\n此方法大体由两部分组成。\n\n##### BeanPostProcessor注册\n\n此部分源码:\n\n```java\n@Override\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n    RootBeanDefinition iabpp = new RootBeanDefinition(ImportAwareBeanPostProcessor.class);\n    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);\n    RootBeanDefinition ecbpp = new RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);\n    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);\n}\n```\n\n###### ImportAwareBeanPostProcessor\n\n是ConfigurationClassPostProcessor的私有内部类。其类图:\n\n![ImportAwareBeanPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ImportAwareBeanPostProcessor.jpg)\n\n此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:\n\n有一个类负责生成Student bean:\n\n```java\n@Configuration\npublic class StudentConfig implements ImportAware {\n    @Bean\n    public Student student() {\n        Student student = new Student();\n        student.setAge(22);\n        student.setName(\"skywalker\");\n        return student;\n    }\n    @Override\n    public void setImportMetadata(AnnotationMetadata importMetadata) {\n        System.out.println(\"importaware\");\n    }\n}\n```\n\n生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:\n\n```java\n@Configuration\n@Import(StudentConfig.class)\npublic class SimpleBeanConfig {\n    @Autowired\n    private StudentConfig studentConfig;\n    @Bean\n    public SimpleBean getSimpleBean() {\n        //bean依赖\n        SimpleBean simpleBean = new SimpleBean(studentConfig.student());\n        return simpleBean;\n    }\n}\n```\n\n启动代码:\n\n```java\npublic static void main(String[] args) {\n    AnnotationConfigApplicationContext context = \n        new AnnotationConfigApplicationContext(SimpleBeanConfig.class);\n    SimpleBean simpleBean = context.getBean(SimpleBean.class);\n    System.out.println(simpleBean.getStudent().getName());\n}\n```\n\n所以ImportAware接口的作用就是**使被引用的配置类可以获得引用类的相关信息**。\n\n###### EnhancedConfigurationBeanPostProcessor\n\n用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。\n\n##### 类解析\n\n这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。\n\n###### bean名字生成策略\n\n对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。\n\nConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:\n\n```java\n// Detect any custom bean name generation strategy supplied through the enclosing application context\nSingletonBeanRegistry singletonRegistry = null;\nif (registry instanceof SingletonBeanRegistry) {\n    singletonRegistry = (SingletonBeanRegistry) registry;\n    if (!this.localBeanNameGeneratorSet && \n        //org.springframework.context.annotation.internalConfigurationBeanNameGenerator\n        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.\n            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n        this.componentScanBeanNameGenerator = generator;\n        this.importBeanNameGenerator = generator;\n    }\n}\n```\n\n默认是一个AnnotationBeanNameGenerator对象，其类图:\n\n![BeanNameGenerator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanNameGenerator.jpg)\n\n那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: **配置解析、BeanDefinition加载之后，Singleton初始化之前**，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。\n\n#### postProcessBeanFactory\n\n此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:\n\n```java\npublic void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {\n    Map<String, AbstractBeanDefinition> configBeanDefs = \n        new LinkedHashMap<String, AbstractBeanDefinition>();\n    //寻找@Configuration的BeanDefinition\n    for (String beanName : beanFactory.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {\n            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        // nothing to enhance -> return immediately\n        return;\n    }\n    ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();\n    for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {\n        AbstractBeanDefinition beanDef = entry.getValue();\n        // If a @Configuration class gets proxied, always proxy the target class\n        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n        // Set enhanced subclass of the user-specified bean class\n        Class<?> configClass = beanDef.resolveBeanClass(this.beanClassLoader);\n        Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);\n        if (configClass != enhancedClass) {\n             //替换\n            beanDef.setBeanClass(enhancedClass);\n        }\n    }\n}\n```\n\nConfigurationClassEnhancer.newEnhancer:\n\n```java\nprivate Enhancer newEnhancer(Class<?> superclass, ClassLoader classLoader) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(superclass);\n    //这里印证了前面EnhancedConfigurationBeanPostProcessor的说明\n    enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});\n    enhancer.setUseFactory(false);\n    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n    enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));\n    //关键\n    enhancer.setCallbackFilter(CALLBACK_FILTER);\n    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());\n    return enhancer;\n}\n```\n\nCALLBACK_FILTER是个什么东西呢:\n\n```java\nprivate static final ConditionalCallbackFilter CALLBACK_FILTER = \n    new ConditionalCallbackFilter(CALLBACKS);\n\nprivate static final Callback[] CALLBACKS = new Callback[] {\n    new BeanMethodInterceptor(),\n    new BeanFactoryAwareMethodInterceptor(),\n    NoOp.INSTANCE\n};\n```\n\n这么做的原因有两个:\n\n- 提供Scope支持:\n\n  我们可以使用@Scope注解来使用注解的方式配置其Scope:\n\n  ```java\n  @Bean\n  @Scope(\"prototype\")\n  public Student student() {\n    Student student = new Student();\n      student.setAge(22);\n      student.setName(\"skywalker\");\n      return student;\n  }\n  ```\n\n  Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。\n\n- 实现EnhancedConfiguration接口\n\n### AutowiredAnnotationBeanPostProcessor\n\n类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。\n\n#### postProcessMergedBeanDefinition\n\n##### 入口\n\n其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:\n\nAbstractAutowireCapableBeanFactory.doCreateBean(简略):\n\n```java\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {\n    // Instantiate the bean.\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n    Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        if (!mbd.postProcessed) {\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            mbd.postProcessed = true;\n        }\n    }\n}	\n```\n\napplyMergedBeanDefinitionPostProcessors:\n\n```java\nprotected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, \n    String beanName) {\n    for (BeanPostProcessor bp : getBeanPostProcessors()) {\n        if (bp instanceof MergedBeanDefinitionPostProcessor) {\n            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;\n            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n        }\n    }\n}\n```\n\n##### 源码\n\n```java\n@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String 	 beanName) {\n    if (beanType != null) {\n        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);\n        metadata.checkConfigMembers(beanDefinition);\n    }\n\n}\n```\n\nfindAutowiringMetadata:\n\n```java\nprivate InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {\n    // Fall back to class name as cache key, for backwards compatibility with custom callers.\n    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n    // Quick check on the concurrent map first, with minimal locking.\n    InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n    if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n        synchronized (this.injectionMetadataCache) {\n            metadata = this.injectionMetadataCache.get(cacheKey);\n            if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n                if (metadata != null) {\n                    metadata.clear(pvs);\n                }\n                metadata = buildAutowiringMetadata(clazz);\n                this.injectionMetadataCache.put(cacheKey, metadata);\n            }\n        }\n    }\n    return metadata;\n}\n```\n\ninjectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:\n\n- 假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。\n- 对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。\n\n可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。\n\n@Autowire注解的扫描在buildAutowiringMetadata方法:\n\n```java\nprivate InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {\n    LinkedList<InjectionMetadata.InjectedElement> elements = \n        new LinkedList<InjectionMetadata.InjectedElement>();\n    Class<?> targetClass = clazz;\n    //循环检测父类\n    do {\n        final LinkedList<InjectionMetadata.InjectedElement> currElements =\n                new LinkedList<InjectionMetadata.InjectedElement>();\n        ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() {\n            @Override\n            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {\n                AnnotationAttributes ann = findAutowiredAnnotation(field);\n                if (ann != null) {\n                      //不支持静态变量\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        return;\n                    }\n                    boolean required = determineRequiredStatus(ann);\n                    currElements.add(new AutowiredFieldElement(field, required));\n                }\n            }\n        });\n        ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n                    return;\n                }\n                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);\n                if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {\n                    if (Modifier.isStatic(method.getModifiers())) {\n                        return;\n                    }\n                    if (method.getParameterTypes().length == 0) {\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"Autowired annotation should be used on \n                                methods with parameters: \" + method);\n                        }\n                    }\n                    boolean required = determineRequiredStatus(ann);\n                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n                    currElements.add(new AutowiredMethodElement(method, required, pd));\n                }\n            }\n        });\n        elements.addAll(0, currElements);\n        targetClass = targetClass.getSuperclass();\n    }\n    while (targetClass != null && targetClass != Object.class);\n    return new InjectionMetadata(clazz, elements);\n}\n```\n\n可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，**Spring注入注解可以配置在此bean的父类上**。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。\n\n##### 变量扫描\n\n之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。\n\nReflectionUtils的实现其实就是访问者模式，其源码:\n\n```java\npublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\n    for (Field field : getDeclaredFields(clazz)) {\n        try {\n            fc.doWith(field);\n        }\n        catch (IllegalAccessException ex) {}\n    }\n}\n```\n\ndetermineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。\n\n##### 方法扫描\n\n###### bridge方法\n\n就是方法扫描的第一行源码:\n\n```java\nMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n```\n\n此句代码的作用是**判断method是否是bridge方法，如果是，寻找其真正的方法。**这里的bridge方法并不是所谓的bridge模式。\n\n有这样的demo代码:\n\n```java\npublic class JavaTest {\n    private class MyList extends ArrayList {\n        //注意父类的返回类型是Object\n        @Override\n        public String get(int index) {\n            return \"\";\n        }\n    }\n    public static void main(String[] args) {\n        for (Method method : MyList.class.getDeclaredMethods()) {\n            System.out.println(\"name: \" + method.getName() + \", return: \" + method.getReturnType());\n        }\n    }\n}\n```\n\n子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:\n\n```html\nname: get, return: class java.lang.String\nname: get, return: class java.lang.Object\n```\n\n通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:\n\n```java\n/**\n * Returns {@code true} if this method is a bridge\n * method; returns {@code false} otherwise.\n *\n * @return true if and only if this method is a bridge\n * method as defined by the Java Language Specification.\n * @since 1.5\n */\npublic boolean isBridge() {\n    return (getModifiers() & Modifier.BRIDGE) != 0;\n}\n```\n\n可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。\n\n可以参考: [Java那些不为人知的特殊方法](http://ifeve.com/syntethic-and-bridge-methods/)\n\n到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。\n\n###### PropertyDescriptor\n\n用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。\n\n#### postProcessPropertyValues\n\n##### 入口\n\nAbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。\n\n##### 注入\n\n源码:\n\n```java\npublic void processInjection(Object bean) throws BeansException {\n    Class<?> clazz = bean.getClass();\n     // 查找缓存\n    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null);\n    metadata.inject(bean, null, null);\n}\n```\n\n根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。\n\n###### Field注入\n\n实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。\n\n###### 方法注入\n\n实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。\n\n### RequiredAnnotationBeanPostProcessor\n\n上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。\n\n#### postProcessMergedBeanDefinition\n\n空实现，就是这么任性:\n\n```java\n@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String 	beanName) {\n}\n```\n\n#### postProcessPropertyValues\n\n源码:\n\n```java\n@Override\npublic PropertyValues postProcessPropertyValues(\n        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)\n        throws BeansException {\n    if (!this.validatedBeanNames.contains(beanName)) {\n        if (!shouldSkip(this.beanFactory, beanName)) {\n            List<String> invalidProperties = new ArrayList<String>();\n            for (PropertyDescriptor pd : pds) {\n                if (isRequiredProperty(pd) && !pvs.contains(pd.getName())) {\n                    invalidProperties.add(pd.getName());\n                }\n            }\n            if (!invalidProperties.isEmpty()) {\n                throw new BeanInitializationException(buildExceptionMessage\n                    (invalidProperties, beanName));\n            }\n        }\n        this.validatedBeanNames.add(beanName);\n    }\n    return pvs;\n}\n```\n\n##### 结果缓存\n\nvalidatedBeanNames是一个Set<String>类型，对于已经检查过的bean，将其name加入Set，防止做无用功。\n\n##### PropertyDescriptor\n\n从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?\n\nAbstractAutowireCapableBeanFactory.populateBean相关代码:\n\n```java\nPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\nif (hasInstAwareBpps) {\n    for (BeanPostProcessor bp : getBeanPostProcessors()) {\n        if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n            if (pvs == null) {\n                return;\n            }\n        }\n    }\n}\n```\n\nfilterPropertyDescriptorsForDependencyCheck单参数方法:\n\n```java\nprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) {\n    List<PropertyDescriptor> pds =\n            new LinkedList<PropertyDescriptor>(Arrays.asList(bw.getPropertyDescriptors()));\n    for (Iterator<PropertyDescriptor> it = pds.iterator(); it.hasNext();) {\n        PropertyDescriptor pd = it.next();\n        if (isExcludedFromDependencyCheck(pd)) {\n            it.remove();\n        }\n    }\n    return pds.toArray(new PropertyDescriptor[pds.size()]);\n}\n```\n\n可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?\n\nBeanWrapperImpl.getPropertyDescriptors:\n\n```java\n@Override\npublic PropertyDescriptor[] getPropertyDescriptors() {\n    return getCachedIntrospectionResults().getPropertyDescriptors();\n}\nprivate CachedIntrospectionResults getCachedIntrospectionResults() {\n    Assert.state(getWrappedInstance() != null, \"BeanWrapper does not hold a bean instance\");\n    if (this.cachedIntrospectionResults == null) {\n        this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());\n    }\n    return this.cachedIntrospectionResults;\n}\n```\n\n所以，这时BeanWrapper便会把自己\"内省\"一遍。这从侧面说明@Reqired注解只对setter方法有效。\n\n##### 测试\n\n有一个bean如下:\n\n```java\n@Component(\"simpleBean\")\npublic class SimpleBean {\n    @Autowired(required = false)\n    private Student student;\n\n    public SimpleBean() {}\n\n    public SimpleBean(Student student) {\n        this.student = student;\n    }\n    public Student getStudent() {\n        return student;\n    }\n    @Required\n    public void setStudent(Student student) {\n        this.student = student;\n    }\n}\n```\n\n注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:\n\n![@Required测试]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/@required_test.png)\n\n### CommonAnnotationBeanPostProcessor\n\n从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。\n\n#### postProcessMergedBeanDefinition\n\n此方法的执行入口以及调用时机上面已经说过了。其源码:\n\n```java\n@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String 	 beanName) {\n    super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);\n    if (beanType != null) {\n        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);\n        metadata.checkConfigMembers(beanDefinition);\n    }\n}\n```\n\n##### 父类\n\n可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:\n\n```java\n@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String 	 beanName) {\n    if (beanType != null) {\n        LifecycleMetadata metadata = findLifecycleMetadata(beanType);\n        metadata.checkConfigMembers(beanDefinition);\n    }\n}\n```\n\nfindLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是**遍历所有method寻找初始化和销毁方法标记**。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:\n\n```java\npublic CommonAnnotationBeanPostProcessor() {\n    setInitAnnotationType(PostConstruct.class);\n    setDestroyAnnotationType(PreDestroy.class);\n}\n```\n\n这两个标签来自于javax.annotation包。那么怎么自定义呢?\n\nCommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:\n\n```xml\n<bean class=\"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor\">\n    <property name=\"initAnnotationType\" value=\"annotation.Init\" />\n</bean>\n```\n\nInit是一个很简单的自定义注解:\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Init {}\n```\n\n在自己的bean中使用此注解:\n\n```java\n@Init\npublic void init() {\n    System.out.println(\"Init!\");\n}\n```\n\n运行Spring便可以看到效果。\n\n另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，**Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持**。为了达到只有一个实例的目的，需要为前面的配置加上ID。\n\n##### 子类\n\nfindResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。\n\n#### postProcessPropertyValues\n\n源码:\n\n```java\n@Override\npublic PropertyValues postProcessPropertyValues(\n        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {\n    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n    metadata.inject(bean, beanName, pvs);\n    return pvs;\n}\n```\n\n套路很明显了。\n\n#### postProcessBeforeInitialization\n\n实现在父类InitDestroyAnnotationBeanPostProcessor：\n\n```java\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n    metadata.invokeInitMethods(bean, beanName);\n    return bean;\n}\n```\n\ninvokeInitMethods:\n\n```java\npublic void invokeInitMethods(Object target, String beanName) throws Throwable {\n    Collection<LifecycleElement> initMethodsToIterate =\n            (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods);\n    if (!initMethodsToIterate.isEmpty()) {\n        for (LifecycleElement element : initMethodsToIterate) {\n             // 反射调用\n            element.invoke(target);\n        }\n    }\n}\n```\n\n不过从源码来看应该支持多个init方法。\n\n#### postProcessBeforeDestruction\n\n反射调用销毁方法，没啥说的了。\n\n### EventListenerMethodProcessor\n\n就一个值得关注的方法: afterSingletonsInstantiated。\n\n##### 入口\n\nDefaultListableBeanFactory.preInstantiateSingletons相关源码:\n\n```java\n// Trigger post-initialization callback for all applicable beans...\nfor (String beanName : beanNames) {\n    Object singletonInstance = getSingleton(beanName);\n    if (singletonInstance instanceof SmartInitializingSingleton) {\n        final SmartInitializingSingleton smartSingleton = \n            (SmartInitializingSingleton) singletonInstance;\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                @Override\n                public Object run() {\n                    smartSingleton.afterSingletonsInstantiated();\n                    return null;\n                }\n            }, getAccessControlContext());\n        } else {\n            smartSingleton.afterSingletonsInstantiated();\n        }\n    }\n}\n```\n\n##### 源码\n\n略过。\n\n# component-scan\n\nComponentScanBeanDefinitionParser.parse源码:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    // base-package属性\n    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n    // 解析占位符\n    basePackage = parserContext.getReaderContext().getEnvironment()\n        .resolvePlaceholders(basePackage);\n    //分割成数据\n    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n    // Actually scan for bean definitions and register them.\n    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n    Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);\n    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);\n    return null;\n}\n```\n\n## 初始化\n\n此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:\n\n```java\nprotected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n    boolean useDefaultFilters = true;\n    if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n    }\n\n    // Delegate bean definition registration to scanner class.\n    ClassPathBeanDefinitionScanner scanner = createScanner\n        (parserContext.getReaderContext(), useDefaultFilters);\n    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());\n    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());\n    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());\n    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());\n\n    if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {\n        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));\n    }\n        \n    parseBeanNameGenerator(element, scanner);\n\n    parseScope(element, scanner);\n\n    parseTypeFilters(element, scanner, parserContext);\n    return scanner;\n}\n```\n\n下面开始按顺序分部分说明。\n\n### use-default-filters\n\ncomponent-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。\n\n### 扫描器:创建 & 初始化\n\n就是createScanner方法和下面那一坨setter方法，没啥好说的。\n\n### resource-pattern\n\n用以配置扫描器扫描的路径，默认`**/*.class`。\n\n### name-generator\n\n可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。\n\n### scope-resolver\n\n指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:\n\n![ScopeMetadataResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScopeMetadataResolver.jpg)\n\n默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。\n\n### scoped-proxy\n\n此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。\n\n### exclude-filter/include-filter\n\n用法示例:\n\n```xml\n<context:component-scan base-package=\"base\">\n    <context:exclude-filter type=\"annotation\" expression=\"javax.annotation.Resource\" />\n</context:component-scan>\n```\n\nparseTypeFilters方法负责此部分的解析，只贴部分源码:\n\n```java\nif (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n    scanner.addIncludeFilter(typeFilter);\n} else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n    scanner.addExcludeFilter(typeFilter);\n}\n```\n\n### annotation-config\n\n此属性等同于<context:annotation-config />配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。\n\n## 扫描\n\n入口方法便是ClassPathBeanDefinitionScanner.doScan:\n\n```java\nprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    Assert.notEmpty(basePackages, \"At least one base package must be specified\");\n    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<BeanDefinitionHolder>();\n    for (String basePackage : basePackages) {\n         // 逐包扫描\n        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);\n        for (BeanDefinition candidate : candidates) {\n            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n            candidate.setScope(scopeMetadata.getScopeName());\n            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n            if (candidate instanceof AbstractBeanDefinition) {\n                 // 为BeanDefinition设置默认的属性\n                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n            }\n            if (candidate instanceof AnnotatedBeanDefinition) {\n                AnnotationConfigUtils.processCommonDefinitionAnnotations\n                    ((AnnotatedBeanDefinition) candidate);\n            }\n            if (checkCandidate(beanName, candidate)) {\n                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode\n                    (scopeMetadata, definitionHolder, this.registry);\n                beanDefinitions.add(definitionHolder);\n                registerBeanDefinition(definitionHolder, this.registry);\n            }\n        }\n    }\n    return beanDefinitions;\n}\n```\n\n### 逐包扫描/BeanDefinition解析\n\n扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:\n\n![MetadataReader类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MetadataReader.jpg)\n\n对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:\n\n```java\nSimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException {\n    InputStream is = new BufferedInputStream(resource.getInputStream());\n    ClassReader classReader;\n    classReader = new ClassReader(is);\n\n    AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);\n    classReader.accept(visitor, ClassReader.SKIP_DEBUG);\n\n    this.annotationMetadata = visitor;\n    // (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)\n    this.classMetadata = visitor;\n    this.resource = resource;\n}\n```\n\n解析的关键便在于AnnotationMetadataReadingVisitor，其类图:\n\n![AnnotationMetadataReadingVisitor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AnnotationMetadataReadingVisitor.jpg)\n\n核心在于其visitAnnotation方法:\n\n```java\n@Override\npublic AnnotationVisitor visitAnnotation(final String desc, boolean visible) {\n    String className = Type.getType(desc).getClassName();\n    this.annotationSet.add(className);\n    return new AnnotationAttributesReadingVisitor(\n        className, this.attributesMap, this.metaAnnotationMap, this.classLoader);\n}\n```\n\n返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:\n\n![ScannedGenericBeanDefinition类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScannedGenericBeanDefinition.jpg)\n\n### @Scope解析\n\nAnnotationScopeMetadataResolver.resolveScopeMetadata:\n\n```java\n@Override\npublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {\n    ScopeMetadata metadata = new ScopeMetadata();\n    if (definition instanceof AnnotatedBeanDefinition) {\n        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;\n         // 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类\n        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(\n                annDef.getMetadata(), this.scopeAnnotationType);\n        if (attributes != null) {\n             // @Scope值\n            metadata.setScopeName(attributes.getString(\"value\"));\n            ScopedProxyMode proxyMode = attributes.getEnum(\"proxyMode\");\n            if (proxyMode == null || proxyMode == ScopedProxyMode.DEFAULT) {\n                proxyMode = this.defaultProxyMode;\n            }\n            metadata.setScopedProxyMode(proxyMode);\n        }\n    }\n    return metadata;\n}\n```\n\nproxyMode和xml的scoped-proxy属性是一个概念:\n\n```java\n@Scope(value = \"singleton\", proxyMode = ScopedProxyMode.DEFAULT)\n```\n\n**XML的属性是全局的配置，这个是局部(针对单个bean)的配置**，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。\n\n### bean名字生成\n\nAnnotationBeanNameGenerator.generateBeanName:\n\n```java\n@Override\npublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n    if (definition instanceof AnnotatedBeanDefinition) {\n        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n        if (StringUtils.hasText(beanName)) {\n            // Explicit bean name found.\n            return beanName;\n        }\n    }\n    // Fallback: generate a unique default bean name.\n    return buildDefaultBeanName(definition, registry);\n}\n```\n\n#### 根据注解\n\n默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:\n\n```java\nprotected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) {\n    AnnotationMetadata amd = annotatedDef.getMetadata();\n    Set<String> types = amd.getAnnotationTypes();\n    String beanName = null;\n     // 遍历当前bean拥有的所有类级注解\n    for (String type : types) {\n         // 获取此注解所有的属性\n        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);\n        if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {\n            Object value = attributes.get(\"value\");\n            if (value instanceof String) {\n                String strVal = (String) value;\n                if (StringUtils.hasLength(strVal)) {\n                    if (beanName != null && !strVal.equals(beanName)) {\n                        throw new IllegalStateException();\n                    }\n                    beanName = strVal;\n                }\n            }\n        }\n    }\n    return beanName;\n}\n```\n\nisStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:\n\n```java\nprotected boolean isStereotypeWithNameValue(String annotationType,\n        Set<String> metaAnnotationTypes, Map<String, Object> attributes) {\n    // org.springframework.stereotype.Component\n    boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||\n        (metaAnnotationTypes != null && metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||\n        annotationType.equals(\"javax.annotation.ManagedBean\") ||\n        annotationType.equals(\"javax.inject.Named\");\n    return (isStereotype && attributes != null && attributes.containsKey(\"value\"));\n}\n```\n\nmetaAnnotationTypes用以判断元注解，针对这种情况:\n\n```java\n@Component\npublic @interface Controller {}\n```\n\n可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。\n\n#### 默认策略\n\n如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：\n\n```java\nprotected String buildDefaultBeanName(BeanDefinition definition) {\n    // base.SimpleBean -> SimpleBean\n    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());\n    //SimpleBean -> simpleBean\n    return Introspector.decapitalize(shortClassName);\n}\n```\n\n注意，对于内部类: OuterClassName.InnerClassName -> outerClassName.InnerClassName.\n\n### 其它注解解析\n\n入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:\n\n```java\n@Lazy\n@Primary\n@DependsOn(\"student\")\n@Role(BeanDefinition.ROLE_APPLICATION)\n@Description(\"This is a simple bean.\")\npublic class SimpleBean {}\n```\n\n这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个\"hint\"，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。\n\n### 冲突检测\n\nSpring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:\n\n```java\nprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) {\n    // 没有同名的，直接返回\n    if (!this.registry.containsBeanDefinition(beanName)) {\n        return true;\n    }\n    BeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n    if (originatingDef != null) {\n        existingDef = originatingDef;\n    }\n    if (isCompatible(beanDefinition, existingDef)) {\n        return false;\n    }\n    throw new ConflictingBeanDefinitionException(\"冲突啦!\");\n}\n```\n\nisCompatible用于判断和之前的BeanDefinition是否兼容:\n\n```java\nprotected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n    //// explicitly registered overriding bean\n    return (!(existingDefinition instanceof ScannedGenericBeanDefinition) || \n            //// scanned same file twice\n            newDefinition.getSource().equals(existingDefinition.getSource()) || \n            // scanned equivalent class twice			\n            newDefinition.equals(existingDefinition));  \n}\n```\n\n可以看出，**如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。**\n\n### 代理生成\n\n入口: ClassPathBeanDefinitionScanner.doScan:\n\n```java\nBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\ndefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n```\n\nAnnotationConfigUtils.applyScopedProxyMode:\n\n```java\nstatic BeanDefinitionHolder applyScopedProxyMode(\n        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) {\n    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();\n    // 基本都是从这里跑了\n    if (scopedProxyMode.equals(ScopedProxyMode.NO)) {\n        return definition;\n    }\n    boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);\n    return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);\n}\n```\n\n最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:\n\n- 这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。\n- 被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。\n- 将被代理者以scopedTarget.原名字注册到容器，返回代理者。\n- 代理者和被代理者同时存在于容器中。\n\n可以看出，这其实是一个偷天换日的过程。\n\n做个实验:\n\n```java\npublic class Boostrap {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));\n         System.out.println(bean.getClass().getName());\n         context.close();\n    }\n}\n```\n\nSimpleBean已开启代理，输出的结果:\n\n```html\nbase.SimpleBean$$EnhancerBySpringCGLIB$$27256c61\n```\n\n那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?\n\nDefaultListableBeanFactory.getBean(Class<T> requiredType, Object... args)部分源码:\n\n```java\nString[] beanNames = getBeanNamesForType(requiredType);\n//不止一个满足条件(代理者和被代理者)\nif (beanNames.length > 1) {\n    ArrayList<String> autowireCandidates = new ArrayList<String>();\n    for (String beanName : beanNames) {\n         // here\n        if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {\n            autowireCandidates.add(beanName);\n        }\n    }\n    if (autowireCandidates.size() > 0) {\n        beanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);\n    }\n}\n```\n\n可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。\n\n### BeanDefinition注册\n\n你懂的。\n\n## Component注册\n\n套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。\n\n# property-override\n\n## 作用\n\n允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:\n\n定义如下的属性文件(property.properties):\n\n```properties\nstudent.name=dog\n```\n\n格式为: bean名字.属性名字=值。由如下的bean:\n\n```xml\n<bean id=\"student\" class=\"base.Student\">\n    <property name=\"name\" value=\"skywalker\" />\n    <property name=\"age\" value=\"30\" />\n</bean>\n```\n\n进行如下的配置:\n\n```xml\n<context:property-override location=\"property.properties\" />\n```\n\n运行如下的代码:\n\n```java\npublic static void main(String[] args) {\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));\n    System.out.println(bean.getStudent().getName());\n    context.close();\n}\n```\n\n打印的便是dog，而不是skywalker。\n\n## 类图\n\n具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:\n\n![PropertyOverrideBeanDefinitionParser类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertyOverrideBeanDefinitionParser.jpg)\n\n## 解析\n\n解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: \n\nAbstractPropertyLoadingBeanDefinitionParser.doParse:\n\n```java\n@Override\nprotected void doParse(Element element, BeanDefinitionBuilder builder) {\n    String location = element.getAttribute(\"location\");\n    if (StringUtils.hasLength(location)) {\n        String[] locations = StringUtils.commaDelimitedListToStringArray(location);\n        builder.addPropertyValue(\"locations\", locations);\n    }\n    String propertiesRef = element.getAttribute(\"properties-ref\");\n    if (StringUtils.hasLength(propertiesRef)) {\n        builder.addPropertyReference(\"properties\", propertiesRef);\n    }\n    String fileEncoding = element.getAttribute(\"file-encoding\");\n    if (StringUtils.hasLength(fileEncoding)) {\n        builder.addPropertyValue(\"fileEncoding\", fileEncoding);\n    }\n    String order = element.getAttribute(\"order\");\n    if (StringUtils.hasLength(order)) {\n        builder.addPropertyValue(\"order\", Integer.valueOf(order));\n    }\n    builder.addPropertyValue(\"ignoreResourceNotFound\",\n            Boolean.valueOf(element.getAttribute(\"ignore-resource-not-found\")));\n    builder.addPropertyValue(\"localOverride\",\n            Boolean.valueOf(element.getAttribute(\"local-override\")));\n    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n}\n```\n\n### properties-ref\n\n此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:\n\n```xml\n<context:property-override  properties-ref=\"property\" />\n    \n<bean id=\"property\" class=\"java.util.Properties\">\n    <constructor-arg>\n        <props>\n            <prop key=\"student.name\">cat</prop>\n        </props>\n    </constructor-arg>\n</bean>\n```\n\n这样便可以看到结果。\n\n### order\n\n此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。\n\n### ignore-resource-not-found\n\n如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。\n\n### ignore-unresolvable\n\n如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。\n\n### local-override\n\n这个属性让我很迷惑。Spring说是此选项决定\"local\"的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:\n\n```java\nprotected Properties[] localProperties;\n\n/**\n * Set local properties, e.g. via the \"props\" tag in XML bean definitions.\n * These can be considered defaults, to be overridden by properties\n * loaded from files.\n */\npublic void setProperties(Properties properties) {\n    this.localProperties = new Properties[] {properties};\n}\n```\n\n可以看出，这应该就是Spring所说的\"local\"属性。好，我们来注入一下:\n\n```xml\n<context:property-override  location=\"property.properties\" local-override=\"false\" />\n\n<bean class=\"org.springframework.beans.factory.config.PropertyOverrideConfigurer\">\n    <property name=\"properties\">\n        <array>\n            <props>\n                <prop key=\"student.name\">cat</prop>\n            </props>\n        </array>\n    </property>\n</bean>\n```\n\n然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向\"local\"注入?(context:property-override不允许子标签存在)\n\n### BeanDefinition\n\n保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:\n\n![PropertyOverrideConfigurer类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertyOverrideConfigurer.jpg)\n\n## 运行\n\n入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):\n\n```java\n@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    try {\n         // 属性加载\n        Properties mergedProps = mergeProperties();\n\n        // Convert the merged properties, if necessary.\n        convertProperties(mergedProps);\n\n        // Let the subclass process the properties.\n        processProperties(beanFactory, mergedProps);\n    }\n    catch (IOException ex) {\n        throw new BeanInitializationException(\"Could not load properties\", ex);\n    }\n}\n```\n\n### 属性加载\n\nPropertiesLoaderSupport.mergeProperties:\n\n```java\nprotected Properties mergeProperties() throws IOException {\n    Properties result = new Properties();\n    if (this.localOverride) {\n        // Load properties from file upfront, to let local properties override.\n        loadProperties(result);\n    }\n    if (this.localProperties != null) {\n        for (Properties localProp : this.localProperties) {\n            CollectionUtils.mergePropertiesIntoMap(localProp, result);\n        }\n    }\n    if (!this.localOverride) {\n        // Load properties from file afterwards, to let those properties override.\n        loadProperties(result);\n    }\n    return result;\n}\n```\n\n可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。\n\n### 属性转换\n\nconvertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。\n\n### 属性设置\n\n就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:\n\n```java\nprotected void applyPropertyValue(\n        ConfigurableListableBeanFactory factory, String beanName, String property, String value) {\n\n    BeanDefinition bd = factory.getBeanDefinition(beanName);\n    while (bd.getOriginatingBeanDefinition() != null) {\n        bd = bd.getOriginatingBeanDefinition();\n    }\n    PropertyValue pv = new PropertyValue(property, value);\n    pv.setOptional(this.ignoreInvalidKeys);\n    bd.getPropertyValues().addPropertyValue(pv);\n}\n```\n\naddPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。\n\n# property-placeholder\n\n这个怎么用已经喜闻乐见了\n\n## 解析\n\n解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。\n\nPropertyPlaceholderBeanDefinitionParser.doParse:\n\n```java\n@Override\nprotected void doParse(Element element, BeanDefinitionBuilder builder) {\n    super.doParse(element, builder);\n    builder.addPropertyValue(\"ignoreUnresolvablePlaceholders\",\n            Boolean.valueOf(element.getAttribute(\"ignore-unresolvable\")));\n    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);\n    if (StringUtils.hasLength(systemPropertiesModeName) &&\n            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) {\n        builder.addPropertyValue(\"systemPropertiesModeName\", \"SYSTEM_PROPERTIES_MODE_\"\n            + systemPropertiesModeName);\n    }\n    if (element.hasAttribute(\"value-separator\")) {\n        builder.addPropertyValue(\"valueSeparator\", element.getAttribute(\"value-separator\"));\n    }\n    if (element.hasAttribute(\"trim-values\")) {\n        builder.addPropertyValue(\"trimValues\", element.getAttribute(\"trim-values\"));\n    }\n    if (element.hasAttribute(\"null-value\")) {\n        builder.addPropertyValue(\"nullValue\", element.getAttribute(\"null-value\"));\n    }\n}\n```\n\n### system-properties-mode\n\nSpring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。\n\n### value-separator\n\n用于配置默认的值的分隔符:\n\n```xml\n<bean id=\"student\" class=\"base.Student\">\n    <property name=\"name\" value=\"${student.name:skywalker}\" />\n</bean>\n```\n\n如果属性文件里没有student.name，那么就是skywalker。默认就是:。\n\n### null-value\n\n遇到哪些值应该当做空处理，比如可以把空串\"\"设为这个，默认不对任何值进行处理。\n\n### trim-values\n\n是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。\n\n### BeanDefinition\n\n这次是PropertySourcesPlaceholderConfigurer，其类图:\n\n![PropertySourcesPlaceholderConfigurer类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertySourcesPlaceholderConfigurer.jpg)\n\n## 运行\n\nPropertySourcesPlaceholderConfigurer.postProcessBeanFactory：\n\n```java\n@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    if (this.propertySources == null) {\n        this.propertySources = new MutablePropertySources();\n        if (this.environment != null) {\n            this.propertySources.addLast(\n                new PropertySource<Environment>(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, \n                    this.environment) {\n                    @Override\n                    public String getProperty(String key) {\n                        return this.source.getProperty(key);\n                    }\n                }\n            );\n        }\n        PropertySource<?> localPropertySource =\n                new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());\n        if (this.localOverride) {\n            this.propertySources.addFirst(localPropertySource);\n        }\n        else {\n            this.propertySources.addLast(localPropertySource);\n        }\n    }\n    processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));\n    this.appliedPropertySources = this.propertySources;\n}\n```\n\n从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:\n\n不使用property-placeholder标签，以显式的bean定义代替。\n\n### 处理\n\n处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。\n\n# load-time-weaver & spring-configured\n\n这两个配置是紧密相关的，所以在一起说了。\n\nload-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。\n\n可以参考:\n\n[Spring之LoadTimeWeaver——一个需求引发的思考](http://sexycoding.iteye.com/blog/1062372)\n\n[Spring LoadTimeWeaver 的那些事儿](http://www.iteye.com/topic/481813)\n\n## javaagent\n\n要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:\n\n-javaagent:D:\\Software\\maven-repos\\org\\springframework\\spring-agent\\2.5.6.SEC03\\spring-agent-2.5.6.SEC03.jar\n\n此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:\n\nPremain-Class: org.springframework.instrument.InstrumentationSavingAge\n nt\n\nSpring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:\n\n```java\npublic class InstrumentationSavingAgent {\n\n    private static volatile Instrumentation instrumentation;\n\n    public static void premain(String agentArgs, Instrumentation inst) {\n        instrumentation = inst;\n    }\n\n    public static Instrumentation getInstrumentation() {\n        return instrumentation;\n    }\n}	\n```\n\n所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。\n\n## 解析\n\n解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。\n\n### LoadTimeWeaver\n\n此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:\n\n![LoadTimeWeaver继承体系]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/LoadTimeWeaver.jpg)\n\nLoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:\n\n```java\n@Override\nprotected String getBeanClassName(Element element) {\n    // 如果配置了weaver-class属性，那么使用其值\n    if (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) {\n        return element.getAttribute(WEAVER_CLASS_ATTRIBUTE);\n    }\n    // org.springframework.context.weaving.DefaultContextLoadTimeWeaver\n    return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;\n}\n```\n\n那么这个BeanDefinition的id/name又是什么呢?\n\nLoadTimeWeaverBeanDefinitionParser.resolveId:\n\n```java\n@Override\nprotected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext 	parserContext) {\n    // loadTimeWeaver\n    return ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;\n}\n```\n\nDefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。\n\n### LoadTimeWeaverBeanDefinitionParser\n\nLoadTimeWeaverBeanDefinitionParser.doParse:\n\n```java\n@Override\nprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    if (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) {\n        if (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) {\n            RootBeanDefinition def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);\n            parserContext.registerBeanComponent(\n                    new BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));\n        }\n        if (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) {\n            new SpringConfiguredBeanDefinitionParser().parse(element, parserContext);\n        }\n    }\n}\n```\n\n### aspectj-weaving\n\n这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。\n\n此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。\n\n### 是否开启\n\nisAspectJWeavingEnabled方法用于判断是否启用:\n\n```java\nprotected boolean isAspectJWeavingEnabled(String value, ParserContext parserContext) {\n    if (\"on\".equals(value)) {\n        return true;\n    } else if (\"off\".equals(value)) {\n        return false;\n    } else {\n        // 寻找aop.xml\n        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();\n        return (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != null);\n    }\n}\n```\n\n### AspectJWeavingEnabler\n\n从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:\n\n![AspectJWeavingEnabler类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJWeavingEnabler.jpg)\n\n### SpringConfiguredBeanDefinitionParser\n\n如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:\n\n```java\nregisterBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n```\n\n其parse方法:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    // org.springframework.context.config.internalBeanConfigurerAspect\n    if (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition();\n         // org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\n        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);\n        def.setFactoryMethodName(\"aspectOf\");\n        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        def.setSource(parserContext.extractSource(element));\n        parserContext.registerBeanComponent(new BeanComponentDefinition\n            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));\n    }\n    return null;\n}\n```\n\n很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:\n\n![AnnotationBeanConfigurerAspect类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AnnotationBeanConfigurerAspect.jpg)\n\nAnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。\n\n下面就去aj文件中看看到底定义了哪些pointcut以及advise。\n\n语法可以参考:\n\n[Spring 之AOP AspectJ切入点详解](http://jinnianshilongnian.iteye.com/blog/1415606)\n\n#### 切点(pointcut)\n\n##### inConfigurableBean\n\n在AnnotationBeanConfigurerAspect中定义，源码:\n\n```java\npublic pointcut inConfigurableBean() : @this(Configurable);\n```\n\n@this没找到相关说明，结合@以及this的语义，猜测是匹配**带有@Configurable注解(以及作为元注解)的类**。\n\n##### beanConstruction\n\n源码:\n\n```java\npublic pointcut beanConstruction(Object bean) :\n            initialization(ConfigurableObject+.new(..)) && this(bean);\n```\n\ninitialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。\n\n##### preConstructionCondition\n\n```java\nprivate pointcut preConstructionCondition() :\n            leastSpecificSuperTypeConstruction() && preConstructionConfiguration();\n```\n\n由两个pointcut与运算而来。\n\n##### leastSpecificSuperTypeConstruction\n\n```java\npublic pointcut leastSpecificSuperTypeConstruction() : initialization(ConfigurableObject.new(..));\n```\n\n##### preConstructionConfiguration\n\n```java\npublic pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*);\nprivate pointcut preConstructionConfigurationSupport(Configurable c) : @this(c) && if (c.preConstruction());\n```\n\npreConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。\n\n##### postConstructionCondition\n\n```java\nprivate pointcut postConstructionCondition() :\n            mostSpecificSubTypeConstruction() && !preConstructionConfiguration();\n```\n\nmostSpecificSubTypeConstruction:\n\n```java\npublic pointcut mostSpecificSubTypeConstruction() :\n            if (thisJoinPoint.getSignature().getDeclaringType() == thisJoinPoint.getThis().getClass());\n```\n\nadvise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。\n\n#### advise\n\n##### 前置\n\n```java\nbefore(Object bean) :\n    beanConstruction(bean) && preConstructionCondition() && inConfigurableBean()  {\n    configureBean(bean);\n}\n```\n\n## 运行\n\nAspectJWeavingEnabler.postProcessBeanFactory:\n\n```java\n@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    enableAspectJWeaving(this.loadTimeWeaver, this.beanClassLoader);\n}\n```\n\nenableAspectJWeaving:\n\n```java\npublic static void enableAspectJWeaving(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader) {\n    // 不为空\n    if (weaverToUse == null) {\n        if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n            weaverToUse = new InstrumentationLoadTimeWeaver(beanClassLoader);\n        }\n        else {\n            throw new IllegalStateException(\"No LoadTimeWeaver available\");\n        }\n    }\n    weaverToUse.addTransformer(\n            new AspectJClassBypassingClassFileTransformer(new ClassPreProcessorAgentAdapter()));\n}\n```\n\n### LoadTimeWeaverAware\n\nAspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?\n\n当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:\n\n```java\n// loadTimeWeaver\nif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n    // Set a temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n}\n```\n\n很明显，关键在于LoadTimeWeaverAwareProcessor，类图:\n\n![LoadTimeWeaverAwareProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/LoadTimeWeaverAwareProcessor.jpg)\n\npostProcessBeforeInitialization方法:\n\n```java\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n    if (bean instanceof LoadTimeWeaverAware) {\n        LoadTimeWeaver ltw = this.loadTimeWeaver;\n        if (ltw == null) {\n            Assert.state(this.beanFactory != null,\n                \"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n             // 去容器找 \n            ltw = this.beanFactory.getBean(\n                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n        }\n        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);\n    }\n    return bean;\n}\n```\n\n可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。\n\nBeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:\n\nBeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:\n\nAbstractApplicationContext.refresh:\n\n```java\n// Invoke factory processors registered as beans in the context.\ninvokeBeanFactoryPostProcessors(beanFactory);\n// Register bean processors that intercept bean creation.\nregisterBeanPostProcessors(beanFactory);\n```\n\n那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?\n\nAbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:\n\n```java\n@Override\npublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) {\n    Object result = existingBean;\n    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n        result = beanProcessor.postProcessBeforeInitialization(result, beanName);\n        if (result == null) {\n            return result;\n        }\n    }\n    return result;\n}\n```\n\ngetBeanPostProcessors:\n\n```java\npublic List<BeanPostProcessor> getBeanPostProcessors() {\n    return this.beanPostProcessors;\n}\n```\n\n可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:\n\n```java\nbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n```\n\n直接将实例添加到BeanFactory中，所以可以得出结论:\n\n**我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加**。\n\n### BeanClassLoaderAware\n\n#### 入口\n\nDefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?\n\nAbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:\n\n```java\nprivate void invokeAwareMethods(final String beanName, final Object bean) {\n    if (bean instanceof Aware) {\n        if (bean instanceof BeanNameAware) {\n            ((BeanNameAware) bean).setBeanName(beanName);\n        }\n        if (bean instanceof BeanClassLoaderAware) {\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        }\n        if (bean instanceof BeanFactoryAware) {\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        }\n    }\n}\n```\n\n#### setBeanClassLoader\n\n这个方法很关键，对instrument的获取就是在这里。源码:\n\n```java\n@Override\npublic void setBeanClassLoader(ClassLoader classLoader) {\n    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);\n    if (serverSpecificLoadTimeWeaver != null) {\n        this.loadTimeWeaver = serverSpecificLoadTimeWeaver;\n    } else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n        this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);\n    } else {\n        this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);\n    }\n}\n```\n\n很明显分为三部分。\n\n##### 服务器agent\n\nSpring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:\n\n> ```\n> Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.\n> ```\n\ncreateServerSpecificLoadTimeWeaver源码:\n\n```java\nprotected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) {\n    String name = classLoader.getClass().getName();\n    if (name.startsWith(\"weblogic\")) {\n        return new WebLogicLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"org.glassfish\")) {\n        return new GlassFishLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"org.apache.catalina\")) {\n        return new TomcatLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"org.jboss\")) {\n        return new JBossLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"com.ibm\")) {\n        return new WebSphereLoadTimeWeaver(classLoader);\n    }\n    return null;\n}\n```\n\n可以看出，**对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现**。\n\n这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。\n\n##### Spring agent\n\n这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：\n\n```java\npublic static boolean isInstrumentationAvailable() {\n    return (getInstrumentation() != null);\n}\n\nprivate static Instrumentation getInstrumentation() {\n    if (AGENT_CLASS_PRESENT) {\n        return InstrumentationAccessor.getInstrumentation();\n    } else {\n        return null;\n    }\n}\n```\n\nAGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。\n\nInstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:\n\n```java\nprivate static class InstrumentationAccessor {\n    public static Instrumentation getInstrumentation() {\n        return InstrumentationSavingAgent.getInstrumentation();\n    }\n}\n```\n\n这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。\n\n##### 反射\n\n在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW...)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:\n\n```java\npublic ReflectiveLoadTimeWeaver() {\n    this(ClassUtils.getDefaultClassLoader());\n}\n\npublic ReflectiveLoadTimeWeaver(ClassLoader classLoader) {\n    Assert.notNull(classLoader, \"ClassLoader must not be null\");\n    this.classLoader = classLoader;\n    this.addTransformerMethod = ClassUtils.getMethodIfAvailable(\n            this.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);\n    if (this.addTransformerMethod == null) {\n        throw new IllegalStateException();\n    }\n}\n```\n\n##### 总结\n\n其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:\n\n[Chapter 5. Load-Time Weaving](http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving)\n\n### ClassFileTransformer\n\n从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。\n\nAspectJClassBypassingClassFileTransformer.transform:\n\n```java\n@Override\npublic byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n        ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n    // aspectj自身的类无需检测(织入)，直接跳过\n    if (className.startsWith(\"org.aspectj\") || className.startsWith(\"org/aspectj\")) {\n        return classfileBuffer;\n    }\n    return this.delegate.transform(loader, className, classBeingRedefined, \n        protectionDomain, classfileBuffer);\n}\n```\n\ndelegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:\n\n![ClassPreProcessorAgentAdapter类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ClassPreProcessorAgentAdapter.jpg)\n\n根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.\n\n### Aj\n\nAj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。\n\n####  缓存\n\nAj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。\n\n#### WeavingAdaptor初始化\n\n初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。\n\n##### aop.xml\n\n###### 解析\n\naop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:\n\n以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:\n\n```xml\n<aspectj>\n    <aspects>\n        <aspect name=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\"/>\n        <aspect name=\"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect\"/>\n        <aspect name=\"org.springframework.transaction.aspectj.AnnotationTransactionAspect\"/>\n        <aspect name=\"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect\"/>\n        <aspect name=\"org.springframework.cache.aspectj.AnnotationCacheAspect\"/>\n        <aspect name=\"org.springframework.cache.aspectj.JCacheCacheAspect\"/>\n    </aspects>\n</aspectj>\n```\n\n那么解析后的结果:\n\n![aop.xml解析结果]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/aop_xml_parse.png)\n\n###### 注册\n\n入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:\n\n```java\nprivate boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List<Definition> definitions) {\n    //对应<weaver options=\"-verbose\">\n    registerOptions(weaver, loader, definitions);\n    //对应<exclude>标签\n    registerAspectExclude(weaver, loader, definitions);\n    //对应<include>标签\n    registerAspectInclude(weaver, loader, definitions);\n    // <aspect>\n    success = registerAspects(weaver, loader, definitions);\n    registerIncludeExclude(weaver, loader, definitions);\n    //对应<dump>标签\n    registerDump(weaver, loader, definitions);\n    //忽略返回\n}\n```\n\n#### 总结\n\nSpring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。\n\n\n\n', '', '2', 0, '2020-01-08 17:05:11', '2020-01-08 17:05:11', '2020-01-08 17:00:09', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#%E5%BC%80%E5%A4%B4\">开头</a></li>\n<li><a href=\"#annotation-config\">annotation-config</a>\n<ul>\n<li><a href=\"#beanpostprocessor%E6%B3%A8%E5%86%8C\">BeanPostProcessor注册</a>\n<ul>\n<li><a href=\"#annotationawareordercomparator\">AnnotationAwareOrderComparator</a></li>\n<li><a href=\"#contextannotationautowirecandidateresolver\">ContextAnnotationAutowireCandidateResolver</a></li>\n<li><a href=\"#configurationclasspostprocessor\">ConfigurationClassPostProcessor</a></li>\n<li><a href=\"#autowiredannotationbeanpostprocessor\">AutowiredAnnotationBeanPostProcessor</a></li>\n<li><a href=\"#requiredannotationbeanpostprocessor\">RequiredAnnotationBeanPostProcessor</a></li>\n<li><a href=\"#commonannotationbeanpostprocessor\">CommonAnnotationBeanPostProcessor</a></li>\n<li><a href=\"#persistenceannotationbeanpostprocessor\">PersistenceAnnotationBeanPostProcessor</a></li>\n<li><a href=\"#eventlistenermethodprocessor\">EventListenerMethodProcessor</a></li>\n<li><a href=\"#defaulteventlistenerfactory\">DefaultEventListenerFactory</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%95%B4%E7%90%86\">逻辑关系整理</a></li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C\">运行</a>\n<ul>\n<li><a href=\"#configurationclasspostprocessor-1\">ConfigurationClassPostProcessor</a>\n<ul>\n<li><a href=\"#postprocessbeandefinitionregistry\">postProcessBeanDefinitionRegistry</a>\n<ul>\n<li><a href=\"#beanpostprocessor%E6%B3%A8%E5%86%8C-1\">BeanPostProcessor注册</a>\n<ul>\n<li><a href=\"#importawarebeanpostprocessor\">ImportAwareBeanPostProcessor</a></li>\n<li><a href=\"#enhancedconfigurationbeanpostprocessor\">EnhancedConfigurationBeanPostProcessor</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%B1%BB%E8%A7%A3%E6%9E%90\">类解析</a>\n<ul>\n<li><a href=\"#bean%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5\">bean名字生成策略</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#postprocessbeanfactory\">postProcessBeanFactory</a></li>\n</ul>\n</li>\n<li><a href=\"#autowiredannotationbeanpostprocessor-1\">AutowiredAnnotationBeanPostProcessor</a>\n<ul>\n<li><a href=\"#postprocessmergedbeandefinition\">postProcessMergedBeanDefinition</a>\n<ul>\n<li><a href=\"#%E5%85%A5%E5%8F%A3\">入口</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81\">源码</a></li>\n<li><a href=\"#%E5%8F%98%E9%87%8F%E6%89%AB%E6%8F%8F\">变量扫描</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E6%89%AB%E6%8F%8F\">方法扫描</a>\n<ul>\n<li><a href=\"#bridge%E6%96%B9%E6%B3%95\">bridge方法</a></li>\n<li><a href=\"#propertydescriptor\">PropertyDescriptor</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#postprocesspropertyvalues\">postProcessPropertyValues</a>\n<ul>\n<li><a href=\"#%E5%85%A5%E5%8F%A3-1\">入口</a></li>\n<li><a href=\"#%E6%B3%A8%E5%85%A5\">注入</a>\n<ul>\n<li><a href=\"#field%E6%B3%A8%E5%85%A5\">Field注入</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5\">方法注入</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#requiredannotationbeanpostprocessor-1\">RequiredAnnotationBeanPostProcessor</a>\n<ul>\n<li><a href=\"#postprocessmergedbeandefinition-1\">postProcessMergedBeanDefinition</a></li>\n<li><a href=\"#postprocesspropertyvalues-1\">postProcessPropertyValues</a>\n<ul>\n<li><a href=\"#%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98\">结果缓存</a></li>\n<li><a href=\"#propertydescriptor-1\">PropertyDescriptor</a></li>\n<li><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#commonannotationbeanpostprocessor-1\">CommonAnnotationBeanPostProcessor</a>\n<ul>\n<li><a href=\"#postprocessmergedbeandefinition-2\">postProcessMergedBeanDefinition</a>\n<ul>\n<li><a href=\"#%E7%88%B6%E7%B1%BB\">父类</a></li>\n<li><a href=\"#%E5%AD%90%E7%B1%BB\">子类</a></li>\n</ul>\n</li>\n<li><a href=\"#postprocesspropertyvalues-2\">postProcessPropertyValues</a></li>\n<li><a href=\"#postprocessbeforeinitialization\">postProcessBeforeInitialization</a></li>\n<li><a href=\"#postprocessbeforedestruction\">postProcessBeforeDestruction</a></li>\n</ul>\n</li>\n<li><a href=\"#eventlistenermethodprocessor-1\">EventListenerMethodProcessor</a>\n<ul>\n<li><a href=\"#%E5%85%A5%E5%8F%A3-2\">入口</a></li>\n<li><a href=\"#%E6%BA%90%E7%A0%81-1\">源码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#component-scan\">component-scan</a>\n<ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\">初始化</a>\n<ul>\n<li><a href=\"#use-default-filters\">use-default-filters</a></li>\n<li><a href=\"#%E6%89%AB%E6%8F%8F%E5%99%A8%E5%88%9B%E5%BB%BA--%E5%88%9D%E5%A7%8B%E5%8C%96\">扫描器:创建 &amp; 初始化</a></li>\n<li><a href=\"#resource-pattern\">resource-pattern</a></li>\n<li><a href=\"#name-generator\">name-generator</a></li>\n<li><a href=\"#scope-resolver\">scope-resolver</a></li>\n<li><a href=\"#scoped-proxy\">scoped-proxy</a></li>\n<li><a href=\"#exclude-filterinclude-filter\">exclude-filter/include-filter</a></li>\n<li><a href=\"#annotation-config-1\">annotation-config</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%89%AB%E6%8F%8F\">扫描</a>\n<ul>\n<li><a href=\"#%E9%80%90%E5%8C%85%E6%89%AB%E6%8F%8Fbeandefinition%E8%A7%A3%E6%9E%90\">逐包扫描/BeanDefinition解析</a></li>\n<li><a href=\"#scope%E8%A7%A3%E6%9E%90\">@Scope解析</a></li>\n<li><a href=\"#bean%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90\">bean名字生成</a>\n<ul>\n<li><a href=\"#%E6%A0%B9%E6%8D%AE%E6%B3%A8%E8%A7%A3\">根据注解</a></li>\n<li><a href=\"#%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5\">默认策略</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90\">其它注解解析</a></li>\n<li><a href=\"#%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B\">冲突检测</a></li>\n<li><a href=\"#%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90\">代理生成</a></li>\n<li><a href=\"#beandefinition%E6%B3%A8%E5%86%8C\">BeanDefinition注册</a></li>\n</ul>\n</li>\n<li><a href=\"#component%E6%B3%A8%E5%86%8C\">Component注册</a></li>\n</ul>\n</li>\n<li><a href=\"#property-override\">property-override</a>\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8\">作用</a></li>\n<li><a href=\"#%E7%B1%BB%E5%9B%BE\">类图</a></li>\n<li><a href=\"#%E8%A7%A3%E6%9E%90\">解析</a>\n<ul>\n<li><a href=\"#properties-ref\">properties-ref</a></li>\n<li><a href=\"#order\">order</a></li>\n<li><a href=\"#ignore-resource-not-found\">ignore-resource-not-found</a></li>\n<li><a href=\"#ignore-unresolvable\">ignore-unresolvable</a></li>\n<li><a href=\"#local-override\">local-override</a></li>\n<li><a href=\"#beandefinition\">BeanDefinition</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C-1\">运行</a>\n<ul>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD\">属性加载</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2\">属性转换</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE\">属性设置</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#property-placeholder\">property-placeholder</a>\n<ul>\n<li><a href=\"#%E8%A7%A3%E6%9E%90-1\">解析</a>\n<ul>\n<li><a href=\"#system-properties-mode\">system-properties-mode</a></li>\n<li><a href=\"#value-separator\">value-separator</a></li>\n<li><a href=\"#null-value\">null-value</a></li>\n<li><a href=\"#trim-values\">trim-values</a></li>\n<li><a href=\"#beandefinition-1\">BeanDefinition</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C-2\">运行</a>\n<ul>\n<li><a href=\"#%E5%A4%84%E7%90%86\">处理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#load-time-weaver--spring-configured\">load-time-weaver &amp; spring-configured</a>\n<ul>\n<li><a href=\"#javaagent\">javaagent</a></li>\n<li><a href=\"#%E8%A7%A3%E6%9E%90-2\">解析</a>\n<ul>\n<li><a href=\"#loadtimeweaver\">LoadTimeWeaver</a></li>\n<li><a href=\"#loadtimeweaverbeandefinitionparser\">LoadTimeWeaverBeanDefinitionParser</a></li>\n<li><a href=\"#aspectj-weaving\">aspectj-weaving</a></li>\n<li><a href=\"#%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF\">是否开启</a></li>\n<li><a href=\"#aspectjweavingenabler\">AspectJWeavingEnabler</a></li>\n<li><a href=\"#springconfiguredbeandefinitionparser\">SpringConfiguredBeanDefinitionParser</a>\n<ul>\n<li><a href=\"#%E5%88%87%E7%82%B9pointcut\">切点(pointcut)</a>\n<ul>\n<li><a href=\"#inconfigurablebean\">inConfigurableBean</a></li>\n<li><a href=\"#beanconstruction\">beanConstruction</a></li>\n<li><a href=\"#preconstructioncondition\">preConstructionCondition</a></li>\n<li><a href=\"#leastspecificsupertypeconstruction\">leastSpecificSuperTypeConstruction</a></li>\n<li><a href=\"#preconstructionconfiguration\">preConstructionConfiguration</a></li>\n<li><a href=\"#postconstructioncondition\">postConstructionCondition</a></li>\n</ul>\n</li>\n<li><a href=\"#advise\">advise</a>\n<ul>\n<li><a href=\"#%E5%89%8D%E7%BD%AE\">前置</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C-3\">运行</a>\n<ul>\n<li><a href=\"#loadtimeweaveraware\">LoadTimeWeaverAware</a></li>\n<li><a href=\"#beanclassloaderaware\">BeanClassLoaderAware</a>\n<ul>\n<li><a href=\"#%E5%85%A5%E5%8F%A3-3\">入口</a></li>\n<li><a href=\"#setbeanclassloader\">setBeanClassLoader</a>\n<ul>\n<li><a href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8agent\">服务器agent</a></li>\n<li><a href=\"#spring-agent\">Spring agent</a></li>\n<li><a href=\"#%E5%8F%8D%E5%B0%84\">反射</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#classfiletransformer\">ClassFileTransformer</a></li>\n<li><a href=\"#aj\">Aj</a>\n<ul>\n<li><a href=\"#%E7%BC%93%E5%AD%98\">缓存</a></li>\n<li><a href=\"#weavingadaptor%E5%88%9D%E5%A7%8B%E5%8C%96\">WeavingAdaptor初始化</a>\n<ul>\n<li><a href=\"#aopxml\">aop.xml</a>\n<ul>\n<li><a href=\"#%E8%A7%A3%E6%9E%90-3\">解析</a></li>\n<li><a href=\"#%E6%B3%A8%E5%86%8C\">注册</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%80%BB%E7%BB%93-1\">总结</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n<h1>开头</h1>\n<p>入口方法在BeanDefinitionParserDelegate.parseCustomElement：</p>\n<pre><code data-language=\"java\" class=\"lang-java\">return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n</code></pre>\n<p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    return findParserForElement(element, parserContext).parse(element, parserContext);\n}\n</code></pre>\n<p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n    String localName = parserContext.getDelegate().getLocalName(element);\n    BeanDefinitionParser parser = this.parsers.get(localName);\n    if (parser == null) {\n        parserContext.getReaderContext().fatal(\n            \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element);\n    }\n    return parser;\n}\n</code></pre>\n<p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p>\n<h1>annotation-config</h1>\n<p>AnnotationConfigBeanDefinitionParser.parse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    //返回null\n    Object source = parserContext.extractSource(element);\n    // Obtain bean definitions for all relevant BeanPostProcessors.\n    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =\n            AnnotationConfigUtils.\n                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);\n    // Register component for the surrounding &lt;context:annotation-config&gt; element.\n    CompositeComponentDefinition compDefinition = \n        new CompositeComponentDefinition(element.getTagName(), source);\n    parserContext.pushContainingComponent(compDefinition);\n    // Nest the concrete beans in the surrounding component.\n    for (BeanDefinitionHolder processorDefinition : processorDefinitions) {\n        parserContext.registerComponent(new BeanComponentDefinition(processorDefinition));\n    }\n    // Finally register the composite component.\n    // 空实现\n    parserContext.popAndRegisterContainingComponent();\n    return null;\n}\n</code></pre>\n<h2>BeanPostProcessor注册</h2>\n<p>AnnotationConfigUtils.registerAnnotationConfigProcessors源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null\npublic static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(\n        BeanDefinitionRegistry registry, Object source) {\n    //将registery强转为DefaultListableBeanFactory类型\n    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n    if (beanFactory != null) {\n        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n        }\n        if (!(beanFactory.getAutowireCandidateResolver() instanceof \n            ContextAnnotationAutowireCandidateResolver)) {\n            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n        }\n    }\n\n    Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4);\n\n    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n    if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n    if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition();\n        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n                AnnotationConfigUtils.class.getClassLoader()));\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n    }\n    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n    }\n\n    return beanDefs;\n}\n</code></pre>\n<h3>AnnotationAwareOrderComparator</h3>\n<p>其继承体系如下:</p>\n<p>![Comparator继承体系]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Comparator.jpg)</p>\n<p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p>\n<p><a href=\"http://www.tuicool.com/articles/VnqUv2\">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p>\n<h3>ContextAnnotationAutowireCandidateResolver</h3>\n<p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p>\n<p>![ContextAnnotationAutowireCandidateResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ContextAnnotationAutowireCandidateResolver.jpg)</p>\n<h3>ConfigurationClassPostProcessor</h3>\n<p>此类用于处理标注了@Configuration注解的类。类图:</p>\n<p>![ConfigurationClassPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ConfigurationClassPostProcessor.jpg)</p>\n<h3>AutowiredAnnotationBeanPostProcessor</h3>\n<p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p>\n<p>![AutowiredAnnotationBeanPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AutowiredAnnotationBeanPostProcessor.jpg)</p>\n<h3>RequiredAnnotationBeanPostProcessor</h3>\n<p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p>\n<h3>CommonAnnotationBeanPostProcessor</h3>\n<p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static final boolean jsr250Present =\n    ClassUtils.isPresent(\"javax.annotation.Resource\", AnnotationConfigUtils.class.getClassLoader());\n</code></pre>\n<p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p>\n<p>![CommonAnnotationBeanPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/CommonAnnotationBeanPostProcessor.jpg)</p>\n<h3>PersistenceAnnotationBeanPostProcessor</h3>\n<p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static final boolean jpaPresent =	\n    ClassUtils.isPresent(\"javax.persistence.EntityManagerFactory\", \n        AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;\n    //org.springframework.orm包\n    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, \n        AnnotationConfigUtils.class.getClassLoader());\n</code></pre>\n<p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p>\n<h3>EventListenerMethodProcessor</h3>\n<p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p>\n<p>![EventListenerMethodProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/EventListenerMethodProcessor.jpg)</p>\n<h3>DefaultEventListenerFactory</h3>\n<p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p>\n<p>![DefaultEventListenerFactory类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DefaultEventListenerFactory.jpg)</p>\n<h2>逻辑关系整理</h2>\n<p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p>\n<p>![CompositeComponentDefinition类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/CompositeComponentDefinition.jpg)</p>\n<p>最终形成的数据结构如下图:</p>\n<p>![数据结构]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/context_annotation_stack.png)</p>\n<p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p>\n<h2>运行</h2>\n<h3>ConfigurationClassPostProcessor</h3>\n<p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">invokeBeanFactoryPostProcessors(beanFactory);\n</code></pre>\n<p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p>\n<h4>postProcessBeanDefinitionRegistry</h4>\n<p>此方法大体由两部分组成。</p>\n<h5>BeanPostProcessor注册</h5>\n<p>此部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n    RootBeanDefinition iabpp = new RootBeanDefinition(ImportAwareBeanPostProcessor.class);\n    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);\n    RootBeanDefinition ecbpp = new RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);\n    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);\n}\n</code></pre>\n<h6>ImportAwareBeanPostProcessor</h6>\n<p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p>\n<p>![ImportAwareBeanPostProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ImportAwareBeanPostProcessor.jpg)</p>\n<p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p>\n<p>有一个类负责生成Student bean:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Configuration\npublic class StudentConfig implements ImportAware {\n    @Bean\n    public Student student() {\n        Student student = new Student();\n        student.setAge(22);\n        student.setName(\"skywalker\");\n        return student;\n    }\n    @Override\n    public void setImportMetadata(AnnotationMetadata importMetadata) {\n        System.out.println(\"importaware\");\n    }\n}\n</code></pre>\n<p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Configuration\n@Import(StudentConfig.class)\npublic class SimpleBeanConfig {\n    @Autowired\n    private StudentConfig studentConfig;\n    @Bean\n    public SimpleBean getSimpleBean() {\n        //bean依赖\n        SimpleBean simpleBean = new SimpleBean(studentConfig.student());\n        return simpleBean;\n    }\n}\n</code></pre>\n<p>启动代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static void main(String[] args) {\n    AnnotationConfigApplicationContext context = \n        new AnnotationConfigApplicationContext(SimpleBeanConfig.class);\n    SimpleBean simpleBean = context.getBean(SimpleBean.class);\n    System.out.println(simpleBean.getStudent().getName());\n}\n</code></pre>\n<p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p>\n<h6>EnhancedConfigurationBeanPostProcessor</h6>\n<p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p>\n<h5>类解析</h5>\n<p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p>\n<h6>bean名字生成策略</h6>\n<p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p>\n<p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">// Detect any custom bean name generation strategy supplied through the enclosing application context\nSingletonBeanRegistry singletonRegistry = null;\nif (registry instanceof SingletonBeanRegistry) {\n    singletonRegistry = (SingletonBeanRegistry) registry;\n    if (!this.localBeanNameGeneratorSet &amp;&amp; \n        //org.springframework.context.annotation.internalConfigurationBeanNameGenerator\n        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.\n            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n        this.componentScanBeanNameGenerator = generator;\n        this.importBeanNameGenerator = generator;\n    }\n}\n</code></pre>\n<p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p>\n<p>![BeanNameGenerator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanNameGenerator.jpg)</p>\n<p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p>\n<h4>postProcessBeanFactory</h4>\n<p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {\n    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = \n        new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();\n    //寻找@Configuration的BeanDefinition\n    for (String beanName : beanFactory.getBeanDefinitionNames()) {\n        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {\n            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        // nothing to enhance -&gt; return immediately\n        return;\n    }\n    ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();\n    for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) {\n        AbstractBeanDefinition beanDef = entry.getValue();\n        // If a @Configuration class gets proxied, always proxy the target class\n        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n        // Set enhanced subclass of the user-specified bean class\n        Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);\n        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);\n        if (configClass != enhancedClass) {\n             //替换\n            beanDef.setBeanClass(enhancedClass);\n        }\n    }\n}\n</code></pre>\n<p>ConfigurationClassEnhancer.newEnhancer:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private Enhancer newEnhancer(Class&lt;?&gt; superclass, ClassLoader classLoader) {\n    Enhancer enhancer = new Enhancer();\n    enhancer.setSuperclass(superclass);\n    //这里印证了前面EnhancedConfigurationBeanPostProcessor的说明\n    enhancer.setInterfaces(new Class&lt;?&gt;[] {EnhancedConfiguration.class});\n    enhancer.setUseFactory(false);\n    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n    enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));\n    //关键\n    enhancer.setCallbackFilter(CALLBACK_FILTER);\n    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());\n    return enhancer;\n}\n</code></pre>\n<p>CALLBACK_FILTER是个什么东西呢:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static final ConditionalCallbackFilter CALLBACK_FILTER = \n    new ConditionalCallbackFilter(CALLBACKS);\n\nprivate static final Callback[] CALLBACKS = new Callback[] {\n    new BeanMethodInterceptor(),\n    new BeanFactoryAwareMethodInterceptor(),\n    NoOp.INSTANCE\n};\n</code></pre>\n<p>这么做的原因有两个:</p>\n<ul>\n<li>\n<p>提供Scope支持:</p>\n<p>我们可以使用@Scope注解来使用注解的方式配置其Scope:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Bean\n@Scope(\"prototype\")\npublic Student student() {\n  Student student = new Student();\n    student.setAge(22);\n    student.setName(\"skywalker\");\n    return student;\n}\n</code></pre>\n<p>Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p>\n</li>\n<li>\n<p>实现EnhancedConfiguration接口</p>\n</li>\n</ul>\n<h3>AutowiredAnnotationBeanPostProcessor</h3>\n<p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p>\n<h4>postProcessMergedBeanDefinition</h4>\n<h5>入口</h5>\n<p>其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:</p>\n<p>AbstractAutowireCapableBeanFactory.doCreateBean(简略):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {\n    // Instantiate the bean.\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n    Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        if (!mbd.postProcessed) {\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            mbd.postProcessed = true;\n        }\n    }\n}	\n</code></pre>\n<p>applyMergedBeanDefinitionPostProcessors:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, \n    String beanName) {\n    for (BeanPostProcessor bp : getBeanPostProcessors()) {\n        if (bp instanceof MergedBeanDefinitionPostProcessor) {\n            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;\n            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n        }\n    }\n}\n</code></pre>\n<h5>源码</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName) {\n    if (beanType != null) {\n        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);\n        metadata.checkConfigMembers(beanDefinition);\n    }\n\n}\n</code></pre>\n<p>findAutowiringMetadata:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs) {\n    // Fall back to class name as cache key, for backwards compatibility with custom callers.\n    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n    // Quick check on the concurrent map first, with minimal locking.\n    InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n    if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n        synchronized (this.injectionMetadataCache) {\n            metadata = this.injectionMetadataCache.get(cacheKey);\n            if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n                if (metadata != null) {\n                    metadata.clear(pvs);\n                }\n                metadata = buildAutowiringMetadata(clazz);\n                this.injectionMetadataCache.put(cacheKey, metadata);\n            }\n        }\n    }\n    return metadata;\n}\n</code></pre>\n<p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p>\n<ul>\n<li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li>\n<li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li>\n</ul>\n<p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p>\n<p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) {\n    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = \n        new LinkedList&lt;InjectionMetadata.InjectedElement&gt;();\n    Class&lt;?&gt; targetClass = clazz;\n    //循环检测父类\n    do {\n        final LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =\n                new LinkedList&lt;InjectionMetadata.InjectedElement&gt;();\n        ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() {\n            @Override\n            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {\n                AnnotationAttributes ann = findAutowiredAnnotation(field);\n                if (ann != null) {\n                      //不支持静态变量\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        return;\n                    }\n                    boolean required = determineRequiredStatus(ann);\n                    currElements.add(new AutowiredFieldElement(field, required));\n                }\n            }\n        });\n        ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n                    return;\n                }\n                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);\n                if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {\n                    if (Modifier.isStatic(method.getModifiers())) {\n                        return;\n                    }\n                    if (method.getParameterTypes().length == 0) {\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"Autowired annotation should be used on \n                                methods with parameters: \" + method);\n                        }\n                    }\n                    boolean required = determineRequiredStatus(ann);\n                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n                    currElements.add(new AutowiredMethodElement(method, required, pd));\n                }\n            }\n        });\n        elements.addAll(0, currElements);\n        targetClass = targetClass.getSuperclass();\n    }\n    while (targetClass != null &amp;&amp; targetClass != Object.class);\n    return new InjectionMetadata(clazz, elements);\n}\n</code></pre>\n<p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p>\n<h5>变量扫描</h5>\n<p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p>\n<p>ReflectionUtils的实现其实就是访问者模式，其源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static void doWithLocalFields(Class&lt;?&gt; clazz, FieldCallback fc) {\n    for (Field field : getDeclaredFields(clazz)) {\n        try {\n            fc.doWith(field);\n        }\n        catch (IllegalAccessException ex) {}\n    }\n}\n</code></pre>\n<p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p>\n<h5>方法扫描</h5>\n<h6>bridge方法</h6>\n<p>就是方法扫描的第一行源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n</code></pre>\n<p>此句代码的作用是**判断method是否是bridge方法，如果是，寻找其真正的方法。**这里的bridge方法并不是所谓的bridge模式。</p>\n<p>有这样的demo代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public class JavaTest {\n    private class MyList extends ArrayList {\n        //注意父类的返回类型是Object\n        @Override\n        public String get(int index) {\n            return \"\";\n        }\n    }\n    public static void main(String[] args) {\n        for (Method method : MyList.class.getDeclaredMethods()) {\n            System.out.println(\"name: \" + method.getName() + \", return: \" + method.getReturnType());\n        }\n    }\n}\n</code></pre>\n<p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p>\n<pre><code data-language=\"html\" class=\"lang-html\">name: get, return: class java.lang.String\nname: get, return: class java.lang.Object\n</code></pre>\n<p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">/**\n * Returns {@code true} if this method is a bridge\n * method; returns {@code false} otherwise.\n *\n * @return true if and only if this method is a bridge\n * method as defined by the Java Language Specification.\n * @since 1.5\n */\npublic boolean isBridge() {\n    return (getModifiers() &amp; Modifier.BRIDGE) != 0;\n}\n</code></pre>\n<p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p>\n<p>可以参考: <a href=\"http://ifeve.com/syntethic-and-bridge-methods/\">Java那些不为人知的特殊方法</a></p>\n<p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p>\n<h6>PropertyDescriptor</h6>\n<p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p>\n<h4>postProcessPropertyValues</h4>\n<h5>入口</h5>\n<p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p>\n<h5>注入</h5>\n<p>源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void processInjection(Object bean) throws BeansException {\n    Class&lt;?&gt; clazz = bean.getClass();\n     // 查找缓存\n    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null);\n    metadata.inject(bean, null, null);\n}\n</code></pre>\n<p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p>\n<h6>Field注入</h6>\n<p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p>\n<h6>方法注入</h6>\n<p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p>\n<h3>RequiredAnnotationBeanPostProcessor</h3>\n<p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p>\n<h4>postProcessMergedBeanDefinition</h4>\n<p>空实现，就是这么任性:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	beanName) {\n}\n</code></pre>\n<h4>postProcessPropertyValues</h4>\n<p>源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic PropertyValues postProcessPropertyValues(\n        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)\n        throws BeansException {\n    if (!this.validatedBeanNames.contains(beanName)) {\n        if (!shouldSkip(this.beanFactory, beanName)) {\n            List&lt;String&gt; invalidProperties = new ArrayList&lt;String&gt;();\n            for (PropertyDescriptor pd : pds) {\n                if (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) {\n                    invalidProperties.add(pd.getName());\n                }\n            }\n            if (!invalidProperties.isEmpty()) {\n                throw new BeanInitializationException(buildExceptionMessage\n                    (invalidProperties, beanName));\n            }\n        }\n        this.validatedBeanNames.add(beanName);\n    }\n    return pvs;\n}\n</code></pre>\n<h5>结果缓存</h5>\n<p>validatedBeanNames是一个Set<string data-tomark-pass=\"\">类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</string></p>\n<h5>PropertyDescriptor</h5>\n<p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p>\n<p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\nif (hasInstAwareBpps) {\n    for (BeanPostProcessor bp : getBeanPostProcessors()) {\n        if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n            if (pvs == null) {\n                return;\n            }\n        }\n    }\n}\n</code></pre>\n<p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) {\n    List&lt;PropertyDescriptor&gt; pds =\n            new LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));\n    for (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) {\n        PropertyDescriptor pd = it.next();\n        if (isExcludedFromDependencyCheck(pd)) {\n            it.remove();\n        }\n    }\n    return pds.toArray(new PropertyDescriptor[pds.size()]);\n}\n</code></pre>\n<p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p>\n<p>BeanWrapperImpl.getPropertyDescriptors:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic PropertyDescriptor[] getPropertyDescriptors() {\n    return getCachedIntrospectionResults().getPropertyDescriptors();\n}\nprivate CachedIntrospectionResults getCachedIntrospectionResults() {\n    Assert.state(getWrappedInstance() != null, \"BeanWrapper does not hold a bean instance\");\n    if (this.cachedIntrospectionResults == null) {\n        this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());\n    }\n    return this.cachedIntrospectionResults;\n}\n</code></pre>\n<p>所以，这时BeanWrapper便会把自己\"内省\"一遍。这从侧面说明@Reqired注解只对setter方法有效。</p>\n<h5>测试</h5>\n<p>有一个bean如下:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Component(\"simpleBean\")\npublic class SimpleBean {\n    @Autowired(required = false)\n    private Student student;\n\n    public SimpleBean() {}\n\n    public SimpleBean(Student student) {\n        this.student = student;\n    }\n    public Student getStudent() {\n        return student;\n    }\n    @Required\n    public void setStudent(Student student) {\n        this.student = student;\n    }\n}\n</code></pre>\n<p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p>\n<p>![@Required测试]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/@required_test.png)</p>\n<h3>CommonAnnotationBeanPostProcessor</h3>\n<p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p>\n<h4>postProcessMergedBeanDefinition</h4>\n<p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName) {\n    super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);\n    if (beanType != null) {\n        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);\n        metadata.checkConfigMembers(beanDefinition);\n    }\n}\n</code></pre>\n<h5>父类</h5>\n<p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName) {\n    if (beanType != null) {\n        LifecycleMetadata metadata = findLifecycleMetadata(beanType);\n        metadata.checkConfigMembers(beanDefinition);\n    }\n}\n</code></pre>\n<p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public CommonAnnotationBeanPostProcessor() {\n    setInitAnnotationType(PostConstruct.class);\n    setDestroyAnnotationType(PreDestroy.class);\n}\n</code></pre>\n<p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p>\n<p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean class=\"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor\"&gt;\n    &lt;property name=\"initAnnotationType\" value=\"annotation.Init\" /&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>Init是一个很简单的自定义注解:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Init {}\n</code></pre>\n<p>在自己的bean中使用此注解:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Init\npublic void init() {\n    System.out.println(\"Init!\");\n}\n</code></pre>\n<p>运行Spring便可以看到效果。</p>\n<p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p>\n<h5>子类</h5>\n<p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p>\n<h4>postProcessPropertyValues</h4>\n<p>源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic PropertyValues postProcessPropertyValues(\n        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {\n    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n    metadata.inject(bean, beanName, pvs);\n    return pvs;\n}\n</code></pre>\n<p>套路很明显了。</p>\n<h4>postProcessBeforeInitialization</h4>\n<p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n    metadata.invokeInitMethods(bean, beanName);\n    return bean;\n}\n</code></pre>\n<p>invokeInitMethods:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void invokeInitMethods(Object target, String beanName) throws Throwable {\n    Collection&lt;LifecycleElement&gt; initMethodsToIterate =\n            (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods);\n    if (!initMethodsToIterate.isEmpty()) {\n        for (LifecycleElement element : initMethodsToIterate) {\n             // 反射调用\n            element.invoke(target);\n        }\n    }\n}\n</code></pre>\n<p>不过从源码来看应该支持多个init方法。</p>\n<h4>postProcessBeforeDestruction</h4>\n<p>反射调用销毁方法，没啥说的了。</p>\n<h3>EventListenerMethodProcessor</h3>\n<p>就一个值得关注的方法: afterSingletonsInstantiated。</p>\n<h5>入口</h5>\n<p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">// Trigger post-initialization callback for all applicable beans...\nfor (String beanName : beanNames) {\n    Object singletonInstance = getSingleton(beanName);\n    if (singletonInstance instanceof SmartInitializingSingleton) {\n        final SmartInitializingSingleton smartSingleton = \n            (SmartInitializingSingleton) singletonInstance;\n        if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {\n                @Override\n                public Object run() {\n                    smartSingleton.afterSingletonsInstantiated();\n                    return null;\n                }\n            }, getAccessControlContext());\n        } else {\n            smartSingleton.afterSingletonsInstantiated();\n        }\n    }\n}\n</code></pre>\n<h5>源码</h5>\n<p>略过。</p>\n<h1>component-scan</h1>\n<p>ComponentScanBeanDefinitionParser.parse源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    // base-package属性\n    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n    // 解析占位符\n    basePackage = parserContext.getReaderContext().getEnvironment()\n        .resolvePlaceholders(basePackage);\n    //分割成数据\n    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n    // Actually scan for bean definitions and register them.\n    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);\n    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);\n    return null;\n}\n</code></pre>\n<h2>初始化</h2>\n<p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n    boolean useDefaultFilters = true;\n    if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n    }\n\n    // Delegate bean definition registration to scanner class.\n    ClassPathBeanDefinitionScanner scanner = createScanner\n        (parserContext.getReaderContext(), useDefaultFilters);\n    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());\n    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());\n    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());\n    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());\n\n    if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {\n        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));\n    }\n        \n    parseBeanNameGenerator(element, scanner);\n\n    parseScope(element, scanner);\n\n    parseTypeFilters(element, scanner, parserContext);\n    return scanner;\n}\n</code></pre>\n<p>下面开始按顺序分部分说明。</p>\n<h3>use-default-filters</h3>\n<p>component-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p>\n<h3>扫描器:创建 &amp; 初始化</h3>\n<p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p>\n<h3>resource-pattern</h3>\n<p>用以配置扫描器扫描的路径，默认<code data-backticks=\"1\">**/*.class</code>。</p>\n<h3>name-generator</h3>\n<p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p>\n<h3>scope-resolver</h3>\n<p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p>\n<p>![ScopeMetadataResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScopeMetadataResolver.jpg)</p>\n<p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p>\n<h3>scoped-proxy</h3>\n<p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p>\n<h3>exclude-filter/include-filter</h3>\n<p>用法示例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;context:component-scan base-package=\"base\"&gt;\n    &lt;context:exclude-filter type=\"annotation\" expression=\"javax.annotation.Resource\" /&gt;\n&lt;/context:component-scan&gt;\n</code></pre>\n<p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n    scanner.addIncludeFilter(typeFilter);\n} else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n    scanner.addExcludeFilter(typeFilter);\n}\n</code></pre>\n<h3>annotation-config</h3>\n<p>此属性等同于&lt;context:annotation-config /&gt;配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。</p>\n<h2>扫描</h2>\n<p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {\n    Assert.notEmpty(basePackages, \"At least one base package must be specified\");\n    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;();\n    for (String basePackage : basePackages) {\n         // 逐包扫描\n        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);\n        for (BeanDefinition candidate : candidates) {\n            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n            candidate.setScope(scopeMetadata.getScopeName());\n            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n            if (candidate instanceof AbstractBeanDefinition) {\n                 // 为BeanDefinition设置默认的属性\n                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n            }\n            if (candidate instanceof AnnotatedBeanDefinition) {\n                AnnotationConfigUtils.processCommonDefinitionAnnotations\n                    ((AnnotatedBeanDefinition) candidate);\n            }\n            if (checkCandidate(beanName, candidate)) {\n                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode\n                    (scopeMetadata, definitionHolder, this.registry);\n                beanDefinitions.add(definitionHolder);\n                registerBeanDefinition(definitionHolder, this.registry);\n            }\n        }\n    }\n    return beanDefinitions;\n}\n</code></pre>\n<h3>逐包扫描/BeanDefinition解析</h3>\n<p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p>\n<p>![MetadataReader类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MetadataReader.jpg)</p>\n<p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException {\n    InputStream is = new BufferedInputStream(resource.getInputStream());\n    ClassReader classReader;\n    classReader = new ClassReader(is);\n\n    AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);\n    classReader.accept(visitor, ClassReader.SKIP_DEBUG);\n\n    this.annotationMetadata = visitor;\n    // (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)\n    this.classMetadata = visitor;\n    this.resource = resource;\n}\n</code></pre>\n<p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p>\n<p>![AnnotationMetadataReadingVisitor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AnnotationMetadataReadingVisitor.jpg)</p>\n<p>核心在于其visitAnnotation方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic AnnotationVisitor visitAnnotation(final String desc, boolean visible) {\n    String className = Type.getType(desc).getClassName();\n    this.annotationSet.add(className);\n    return new AnnotationAttributesReadingVisitor(\n        className, this.attributesMap, this.metaAnnotationMap, this.classLoader);\n}\n</code></pre>\n<p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p>\n<p>![ScannedGenericBeanDefinition类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ScannedGenericBeanDefinition.jpg)</p>\n<h3>@Scope解析</h3>\n<p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {\n    ScopeMetadata metadata = new ScopeMetadata();\n    if (definition instanceof AnnotatedBeanDefinition) {\n        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;\n         // 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类\n        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(\n                annDef.getMetadata(), this.scopeAnnotationType);\n        if (attributes != null) {\n             // @Scope值\n            metadata.setScopeName(attributes.getString(\"value\"));\n            ScopedProxyMode proxyMode = attributes.getEnum(\"proxyMode\");\n            if (proxyMode == null || proxyMode == ScopedProxyMode.DEFAULT) {\n                proxyMode = this.defaultProxyMode;\n            }\n            metadata.setScopedProxyMode(proxyMode);\n        }\n    }\n    return metadata;\n}\n</code></pre>\n<p>proxyMode和xml的scoped-proxy属性是一个概念:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Scope(value = \"singleton\", proxyMode = ScopedProxyMode.DEFAULT)\n</code></pre>\n<p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p>\n<h3>bean名字生成</h3>\n<p>AnnotationBeanNameGenerator.generateBeanName:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n    if (definition instanceof AnnotatedBeanDefinition) {\n        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n        if (StringUtils.hasText(beanName)) {\n            // Explicit bean name found.\n            return beanName;\n        }\n    }\n    // Fallback: generate a unique default bean name.\n    return buildDefaultBeanName(definition, registry);\n}\n</code></pre>\n<h4>根据注解</h4>\n<p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) {\n    AnnotationMetadata amd = annotatedDef.getMetadata();\n    Set&lt;String&gt; types = amd.getAnnotationTypes();\n    String beanName = null;\n     // 遍历当前bean拥有的所有类级注解\n    for (String type : types) {\n         // 获取此注解所有的属性\n        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);\n        if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {\n            Object value = attributes.get(\"value\");\n            if (value instanceof String) {\n                String strVal = (String) value;\n                if (StringUtils.hasLength(strVal)) {\n                    if (beanName != null &amp;&amp; !strVal.equals(beanName)) {\n                        throw new IllegalStateException();\n                    }\n                    beanName = strVal;\n                }\n            }\n        }\n    }\n    return beanName;\n}\n</code></pre>\n<p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected boolean isStereotypeWithNameValue(String annotationType,\n        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes) {\n    // org.springframework.stereotype.Component\n    boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||\n        (metaAnnotationTypes != null &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||\n        annotationType.equals(\"javax.annotation.ManagedBean\") ||\n        annotationType.equals(\"javax.inject.Named\");\n    return (isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(\"value\"));\n}\n</code></pre>\n<p>metaAnnotationTypes用以判断元注解，针对这种情况:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Component\npublic @interface Controller {}\n</code></pre>\n<p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p>\n<h4>默认策略</h4>\n<p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected String buildDefaultBeanName(BeanDefinition definition) {\n    // base.SimpleBean -&gt; SimpleBean\n    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());\n    //SimpleBean -&gt; simpleBean\n    return Introspector.decapitalize(shortClassName);\n}\n</code></pre>\n<p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p>\n<h3>其它注解解析</h3>\n<p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Lazy\n@Primary\n@DependsOn(\"student\")\n@Role(BeanDefinition.ROLE_APPLICATION)\n@Description(\"This is a simple bean.\")\npublic class SimpleBean {}\n</code></pre>\n<p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个\"hint\"，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p>\n<h3>冲突检测</h3>\n<p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) {\n    // 没有同名的，直接返回\n    if (!this.registry.containsBeanDefinition(beanName)) {\n        return true;\n    }\n    BeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n    if (originatingDef != null) {\n        existingDef = originatingDef;\n    }\n    if (isCompatible(beanDefinition, existingDef)) {\n        return false;\n    }\n    throw new ConflictingBeanDefinitionException(\"冲突啦!\");\n}\n</code></pre>\n<p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n    //// explicitly registered overriding bean\n    return (!(existingDefinition instanceof ScannedGenericBeanDefinition) || \n            //// scanned same file twice\n            newDefinition.getSource().equals(existingDefinition.getSource()) || \n            // scanned equivalent class twice			\n            newDefinition.equals(existingDefinition));  \n}\n</code></pre>\n<p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。</strong></p>\n<h3>代理生成</h3>\n<p>入口: ClassPathBeanDefinitionScanner.doScan:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\ndefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n</code></pre>\n<p>AnnotationConfigUtils.applyScopedProxyMode:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">static BeanDefinitionHolder applyScopedProxyMode(\n        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) {\n    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();\n    // 基本都是从这里跑了\n    if (scopedProxyMode.equals(ScopedProxyMode.NO)) {\n        return definition;\n    }\n    boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);\n    return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);\n}\n</code></pre>\n<p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p>\n<ul>\n<li>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</li>\n<li>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</li>\n<li>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</li>\n<li>代理者和被代理者同时存在于容器中。</li>\n</ul>\n<p>可以看出，这其实是一个偷天换日的过程。</p>\n<p>做个实验:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public class Boostrap {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));\n         System.out.println(bean.getClass().getName());\n         context.close();\n    }\n}\n</code></pre>\n<p>SimpleBean已开启代理，输出的结果:</p>\n<pre><code data-language=\"html\" class=\"lang-html\">base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61\n</code></pre>\n<p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p>\n<p>DefaultListableBeanFactory.getBean(Class<t data-tomark-pass=\"\"> requiredType, Object... args)部分源码:</t></p>\n<pre><code data-language=\"java\" class=\"lang-java\">String[] beanNames = getBeanNamesForType(requiredType);\n//不止一个满足条件(代理者和被代理者)\nif (beanNames.length &gt; 1) {\n    ArrayList&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;();\n    for (String beanName : beanNames) {\n         // here\n        if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {\n            autowireCandidates.add(beanName);\n        }\n    }\n    if (autowireCandidates.size() &gt; 0) {\n        beanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);\n    }\n}\n</code></pre>\n<p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p>\n<h3>BeanDefinition注册</h3>\n<p>你懂的。</p>\n<h2>Component注册</h2>\n<p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p>\n<h1>property-override</h1>\n<h2>作用</h2>\n<p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p>\n<p>定义如下的属性文件(property.properties):</p>\n<pre><code data-language=\"properties\" class=\"lang-properties\">student.name=dog\n</code></pre>\n<p>格式为: bean名字.属性名字=值。由如下的bean:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"student\" class=\"base.Student\"&gt;\n    &lt;property name=\"name\" value=\"skywalker\" /&gt;\n    &lt;property name=\"age\" value=\"30\" /&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>进行如下的配置:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;context:property-override location=\"property.properties\" /&gt;\n</code></pre>\n<p>运行如下的代码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static void main(String[] args) {\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));\n    System.out.println(bean.getStudent().getName());\n    context.close();\n}\n</code></pre>\n<p>打印的便是dog，而不是skywalker。</p>\n<h2>类图</h2>\n<p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p>\n<p>![PropertyOverrideBeanDefinitionParser类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertyOverrideBeanDefinitionParser.jpg)</p>\n<h2>解析</h2>\n<p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码:</p>\n<p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void doParse(Element element, BeanDefinitionBuilder builder) {\n    String location = element.getAttribute(\"location\");\n    if (StringUtils.hasLength(location)) {\n        String[] locations = StringUtils.commaDelimitedListToStringArray(location);\n        builder.addPropertyValue(\"locations\", locations);\n    }\n    String propertiesRef = element.getAttribute(\"properties-ref\");\n    if (StringUtils.hasLength(propertiesRef)) {\n        builder.addPropertyReference(\"properties\", propertiesRef);\n    }\n    String fileEncoding = element.getAttribute(\"file-encoding\");\n    if (StringUtils.hasLength(fileEncoding)) {\n        builder.addPropertyValue(\"fileEncoding\", fileEncoding);\n    }\n    String order = element.getAttribute(\"order\");\n    if (StringUtils.hasLength(order)) {\n        builder.addPropertyValue(\"order\", Integer.valueOf(order));\n    }\n    builder.addPropertyValue(\"ignoreResourceNotFound\",\n            Boolean.valueOf(element.getAttribute(\"ignore-resource-not-found\")));\n    builder.addPropertyValue(\"localOverride\",\n            Boolean.valueOf(element.getAttribute(\"local-override\")));\n    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n}\n</code></pre>\n<h3>properties-ref</h3>\n<p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;context:property-override  properties-ref=\"property\" /&gt;\n    \n&lt;bean id=\"property\" class=\"java.util.Properties\"&gt;\n    &lt;constructor-arg&gt;\n        &lt;props&gt;\n            &lt;prop key=\"student.name\"&gt;cat&lt;/prop&gt;\n        &lt;/props&gt;\n    &lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>这样便可以看到结果。</p>\n<h3>order</h3>\n<p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p>\n<h3>ignore-resource-not-found</h3>\n<p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p>\n<h3>ignore-unresolvable</h3>\n<p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p>\n<h3>local-override</h3>\n<p>这个属性让我很迷惑。Spring说是此选项决定\"local\"的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Properties[] localProperties;\n\n/**\n * Set local properties, e.g. via the \"props\" tag in XML bean definitions.\n * These can be considered defaults, to be overridden by properties\n * loaded from files.\n */\npublic void setProperties(Properties properties) {\n    this.localProperties = new Properties[] {properties};\n}\n</code></pre>\n<p>可以看出，这应该就是Spring所说的\"local\"属性。好，我们来注入一下:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;context:property-override  location=\"property.properties\" local-override=\"false\" /&gt;\n\n&lt;bean class=\"org.springframework.beans.factory.config.PropertyOverrideConfigurer\"&gt;\n    &lt;property name=\"properties\"&gt;\n        &lt;array&gt;\n            &lt;props&gt;\n                &lt;prop key=\"student.name\"&gt;cat&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/array&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向\"local\"注入?(context:property-override不允许子标签存在)</p>\n<h3>BeanDefinition</h3>\n<p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p>\n<p>![PropertyOverrideConfigurer类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertyOverrideConfigurer.jpg)</p>\n<h2>运行</h2>\n<p>入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    try {\n         // 属性加载\n        Properties mergedProps = mergeProperties();\n\n        // Convert the merged properties, if necessary.\n        convertProperties(mergedProps);\n\n        // Let the subclass process the properties.\n        processProperties(beanFactory, mergedProps);\n    }\n    catch (IOException ex) {\n        throw new BeanInitializationException(\"Could not load properties\", ex);\n    }\n}\n</code></pre>\n<h3>属性加载</h3>\n<p>PropertiesLoaderSupport.mergeProperties:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Properties mergeProperties() throws IOException {\n    Properties result = new Properties();\n    if (this.localOverride) {\n        // Load properties from file upfront, to let local properties override.\n        loadProperties(result);\n    }\n    if (this.localProperties != null) {\n        for (Properties localProp : this.localProperties) {\n            CollectionUtils.mergePropertiesIntoMap(localProp, result);\n        }\n    }\n    if (!this.localOverride) {\n        // Load properties from file afterwards, to let those properties override.\n        loadProperties(result);\n    }\n    return result;\n}\n</code></pre>\n<p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p>\n<h3>属性转换</h3>\n<p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p>\n<h3>属性设置</h3>\n<p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void applyPropertyValue(\n        ConfigurableListableBeanFactory factory, String beanName, String property, String value) {\n\n    BeanDefinition bd = factory.getBeanDefinition(beanName);\n    while (bd.getOriginatingBeanDefinition() != null) {\n        bd = bd.getOriginatingBeanDefinition();\n    }\n    PropertyValue pv = new PropertyValue(property, value);\n    pv.setOptional(this.ignoreInvalidKeys);\n    bd.getPropertyValues().addPropertyValue(pv);\n}\n</code></pre>\n<p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p>\n<h1>property-placeholder</h1>\n<p>这个怎么用已经喜闻乐见了</p>\n<h2>解析</h2>\n<p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p>\n<p>PropertyPlaceholderBeanDefinitionParser.doParse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void doParse(Element element, BeanDefinitionBuilder builder) {\n    super.doParse(element, builder);\n    builder.addPropertyValue(\"ignoreUnresolvablePlaceholders\",\n            Boolean.valueOf(element.getAttribute(\"ignore-unresolvable\")));\n    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);\n    if (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;\n            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) {\n        builder.addPropertyValue(\"systemPropertiesModeName\", \"SYSTEM_PROPERTIES_MODE_\"\n            + systemPropertiesModeName);\n    }\n    if (element.hasAttribute(\"value-separator\")) {\n        builder.addPropertyValue(\"valueSeparator\", element.getAttribute(\"value-separator\"));\n    }\n    if (element.hasAttribute(\"trim-values\")) {\n        builder.addPropertyValue(\"trimValues\", element.getAttribute(\"trim-values\"));\n    }\n    if (element.hasAttribute(\"null-value\")) {\n        builder.addPropertyValue(\"nullValue\", element.getAttribute(\"null-value\"));\n    }\n}\n</code></pre>\n<h3>system-properties-mode</h3>\n<p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p>\n<h3>value-separator</h3>\n<p>用于配置默认的值的分隔符:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"student\" class=\"base.Student\"&gt;\n    &lt;property name=\"name\" value=\"${student.name:skywalker}\" /&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p>\n<h3>null-value</h3>\n<p>遇到哪些值应该当做空处理，比如可以把空串\"\"设为这个，默认不对任何值进行处理。</p>\n<h3>trim-values</h3>\n<p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p>\n<h3>BeanDefinition</h3>\n<p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p>\n<p>![PropertySourcesPlaceholderConfigurer类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/PropertySourcesPlaceholderConfigurer.jpg)</p>\n<h2>运行</h2>\n<p>PropertySourcesPlaceholderConfigurer.postProcessBeanFactory：</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    if (this.propertySources == null) {\n        this.propertySources = new MutablePropertySources();\n        if (this.environment != null) {\n            this.propertySources.addLast(\n                new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, \n                    this.environment) {\n                    @Override\n                    public String getProperty(String key) {\n                        return this.source.getProperty(key);\n                    }\n                }\n            );\n        }\n        PropertySource&lt;?&gt; localPropertySource =\n                new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());\n        if (this.localOverride) {\n            this.propertySources.addFirst(localPropertySource);\n        }\n        else {\n            this.propertySources.addLast(localPropertySource);\n        }\n    }\n    processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));\n    this.appliedPropertySources = this.propertySources;\n}\n</code></pre>\n<p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p>\n<p>不使用property-placeholder标签，以显式的bean定义代替。</p>\n<h3>处理</h3>\n<p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p>\n<h1>load-time-weaver &amp; spring-configured</h1>\n<p>这两个配置是紧密相关的，所以在一起说了。</p>\n<p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p>\n<p>可以参考:</p>\n<p><a href=\"http://sexycoding.iteye.com/blog/1062372\">Spring之LoadTimeWeaver——一个需求引发的思考</a></p>\n<p><a href=\"http://www.iteye.com/topic/481813\">Spring LoadTimeWeaver 的那些事儿</a></p>\n<h2>javaagent</h2>\n<p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p>\n<p>-javaagent:D:\\Software\\maven-repos\\org\\springframework\\spring-agent\\2.5.6.SEC03\\spring-agent-2.5.6.SEC03.jar</p>\n<p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p>\n<p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge<br>\nnt</p>\n<p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public class InstrumentationSavingAgent {\n\n    private static volatile Instrumentation instrumentation;\n\n    public static void premain(String agentArgs, Instrumentation inst) {\n        instrumentation = inst;\n    }\n\n    public static Instrumentation getInstrumentation() {\n        return instrumentation;\n    }\n}	\n</code></pre>\n<p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p>\n<h2>解析</h2>\n<p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p>\n<h3>LoadTimeWeaver</h3>\n<p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p>\n<p>![LoadTimeWeaver继承体系]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/LoadTimeWeaver.jpg)</p>\n<p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected String getBeanClassName(Element element) {\n    // 如果配置了weaver-class属性，那么使用其值\n    if (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) {\n        return element.getAttribute(WEAVER_CLASS_ATTRIBUTE);\n    }\n    // org.springframework.context.weaving.DefaultContextLoadTimeWeaver\n    return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;\n}\n</code></pre>\n<p>那么这个BeanDefinition的id/name又是什么呢?</p>\n<p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext 	parserContext) {\n    // loadTimeWeaver\n    return ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;\n}\n</code></pre>\n<p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p>\n<h3>LoadTimeWeaverBeanDefinitionParser</h3>\n<p>LoadTimeWeaverBeanDefinitionParser.doParse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    if (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) {\n        if (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) {\n            RootBeanDefinition def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);\n            parserContext.registerBeanComponent(\n                    new BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));\n        }\n        if (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) {\n            new SpringConfiguredBeanDefinitionParser().parse(element, parserContext);\n        }\n    }\n}\n</code></pre>\n<h3>aspectj-weaving</h3>\n<p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p>\n<p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p>\n<h3>是否开启</h3>\n<p>isAspectJWeavingEnabled方法用于判断是否启用:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected boolean isAspectJWeavingEnabled(String value, ParserContext parserContext) {\n    if (\"on\".equals(value)) {\n        return true;\n    } else if (\"off\".equals(value)) {\n        return false;\n    } else {\n        // 寻找aop.xml\n        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();\n        return (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != null);\n    }\n}\n</code></pre>\n<h3>AspectJWeavingEnabler</h3>\n<p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p>\n<p>![AspectJWeavingEnabler类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AspectJWeavingEnabler.jpg)</p>\n<h3>SpringConfiguredBeanDefinitionParser</h3>\n<p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n</code></pre>\n<p>其parse方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    // org.springframework.context.config.internalBeanConfigurerAspect\n    if (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition();\n         // org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\n        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);\n        def.setFactoryMethodName(\"aspectOf\");\n        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        def.setSource(parserContext.extractSource(element));\n        parserContext.registerBeanComponent(new BeanComponentDefinition\n            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));\n    }\n    return null;\n}\n</code></pre>\n<p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p>\n<p>![AnnotationBeanConfigurerAspect类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/AnnotationBeanConfigurerAspect.jpg)</p>\n<p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p>\n<p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p>\n<p>语法可以参考:</p>\n<p><a href=\"http://jinnianshilongnian.iteye.com/blog/1415606\">Spring 之AOP AspectJ切入点详解</a></p>\n<h4>切点(pointcut)</h4>\n<h5>inConfigurableBean</h5>\n<p>在AnnotationBeanConfigurerAspect中定义，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public pointcut inConfigurableBean() : @this(Configurable);\n</code></pre>\n<p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p>\n<h5>beanConstruction</h5>\n<p>源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public pointcut beanConstruction(Object bean) :\n            initialization(ConfigurableObject+.new(..)) &amp;&amp; this(bean);\n</code></pre>\n<p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p>\n<h5>preConstructionCondition</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">private pointcut preConstructionCondition() :\n            leastSpecificSuperTypeConstruction() &amp;&amp; preConstructionConfiguration();\n</code></pre>\n<p>由两个pointcut与运算而来。</p>\n<h5>leastSpecificSuperTypeConstruction</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">public pointcut leastSpecificSuperTypeConstruction() : initialization(ConfigurableObject.new(..));\n</code></pre>\n<h5>preConstructionConfiguration</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">public pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*);\nprivate pointcut preConstructionConfigurationSupport(Configurable c) : @this(c) &amp;&amp; if (c.preConstruction());\n</code></pre>\n<p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p>\n<h5>postConstructionCondition</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">private pointcut postConstructionCondition() :\n            mostSpecificSubTypeConstruction() &amp;&amp; !preConstructionConfiguration();\n</code></pre>\n<p>mostSpecificSubTypeConstruction:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public pointcut mostSpecificSubTypeConstruction() :\n            if (thisJoinPoint.getSignature().getDeclaringType() == thisJoinPoint.getThis().getClass());\n</code></pre>\n<p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p>\n<h4>advise</h4>\n<h5>前置</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">before(Object bean) :\n    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  {\n    configureBean(bean);\n}\n</code></pre>\n<h2>运行</h2>\n<p>AspectJWeavingEnabler.postProcessBeanFactory:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    enableAspectJWeaving(this.loadTimeWeaver, this.beanClassLoader);\n}\n</code></pre>\n<p>enableAspectJWeaving:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static void enableAspectJWeaving(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader) {\n    // 不为空\n    if (weaverToUse == null) {\n        if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n            weaverToUse = new InstrumentationLoadTimeWeaver(beanClassLoader);\n        }\n        else {\n            throw new IllegalStateException(\"No LoadTimeWeaver available\");\n        }\n    }\n    weaverToUse.addTransformer(\n            new AspectJClassBypassingClassFileTransformer(new ClassPreProcessorAgentAdapter()));\n}\n</code></pre>\n<h3>LoadTimeWeaverAware</h3>\n<p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p>\n<p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">// loadTimeWeaver\nif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n    // Set a temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n}\n</code></pre>\n<p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p>\n<p>![LoadTimeWeaverAwareProcessor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/LoadTimeWeaverAwareProcessor.jpg)</p>\n<p>postProcessBeforeInitialization方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n    if (bean instanceof LoadTimeWeaverAware) {\n        LoadTimeWeaver ltw = this.loadTimeWeaver;\n        if (ltw == null) {\n            Assert.state(this.beanFactory != null,\n                \"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n             // 去容器找 \n            ltw = this.beanFactory.getBean(\n                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n        }\n        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);\n    }\n    return bean;\n}\n</code></pre>\n<p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p>\n<p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p>\n<p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p>\n<p>AbstractApplicationContext.refresh:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">// Invoke factory processors registered as beans in the context.\ninvokeBeanFactoryPostProcessors(beanFactory);\n// Register bean processors that intercept bean creation.\nregisterBeanPostProcessors(beanFactory);\n</code></pre>\n<p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p>\n<p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) {\n    Object result = existingBean;\n    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n        result = beanProcessor.postProcessBeforeInitialization(result, beanName);\n        if (result == null) {\n            return result;\n        }\n    }\n    return result;\n}\n</code></pre>\n<p>getBeanPostProcessors:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() {\n    return this.beanPostProcessors;\n}\n</code></pre>\n<p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n</code></pre>\n<p>直接将实例添加到BeanFactory中，所以可以得出结论:</p>\n<p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p>\n<h3>BeanClassLoaderAware</h3>\n<h4>入口</h4>\n<p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p>\n<p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private void invokeAwareMethods(final String beanName, final Object bean) {\n    if (bean instanceof Aware) {\n        if (bean instanceof BeanNameAware) {\n            ((BeanNameAware) bean).setBeanName(beanName);\n        }\n        if (bean instanceof BeanClassLoaderAware) {\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        }\n        if (bean instanceof BeanFactoryAware) {\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        }\n    }\n}\n</code></pre>\n<h4>setBeanClassLoader</h4>\n<p>这个方法很关键，对instrument的获取就是在这里。源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void setBeanClassLoader(ClassLoader classLoader) {\n    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);\n    if (serverSpecificLoadTimeWeaver != null) {\n        this.loadTimeWeaver = serverSpecificLoadTimeWeaver;\n    } else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n        this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);\n    } else {\n        this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);\n    }\n}\n</code></pre>\n<p>很明显分为三部分。</p>\n<h5>服务器agent</h5>\n<p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p>\n<blockquote>\n<pre><code>Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.\n</code></pre>\n</blockquote>\n<p>createServerSpecificLoadTimeWeaver源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) {\n    String name = classLoader.getClass().getName();\n    if (name.startsWith(\"weblogic\")) {\n        return new WebLogicLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"org.glassfish\")) {\n        return new GlassFishLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"org.apache.catalina\")) {\n        return new TomcatLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"org.jboss\")) {\n        return new JBossLoadTimeWeaver(classLoader);\n    } else if (name.startsWith(\"com.ibm\")) {\n        return new WebSphereLoadTimeWeaver(classLoader);\n    }\n    return null;\n}\n</code></pre>\n<p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p>\n<p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p>\n<h5>Spring agent</h5>\n<p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static boolean isInstrumentationAvailable() {\n    return (getInstrumentation() != null);\n}\n\nprivate static Instrumentation getInstrumentation() {\n    if (AGENT_CLASS_PRESENT) {\n        return InstrumentationAccessor.getInstrumentation();\n    } else {\n        return null;\n    }\n}\n</code></pre>\n<p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p>\n<p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static class InstrumentationAccessor {\n    public static Instrumentation getInstrumentation() {\n        return InstrumentationSavingAgent.getInstrumentation();\n    }\n}\n</code></pre>\n<p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p>\n<h5>反射</h5>\n<p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW...)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public ReflectiveLoadTimeWeaver() {\n    this(ClassUtils.getDefaultClassLoader());\n}\n\npublic ReflectiveLoadTimeWeaver(ClassLoader classLoader) {\n    Assert.notNull(classLoader, \"ClassLoader must not be null\");\n    this.classLoader = classLoader;\n    this.addTransformerMethod = ClassUtils.getMethodIfAvailable(\n            this.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);\n    if (this.addTransformerMethod == null) {\n        throw new IllegalStateException();\n    }\n}\n</code></pre>\n<h5>总结</h5>\n<p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p>\n<p><a href=\"http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving\">Chapter 5. Load-Time Weaving</a></p>\n<h3>ClassFileTransformer</h3>\n<p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p>\n<p>AspectJClassBypassingClassFileTransformer.transform:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,\n        ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n    // aspectj自身的类无需检测(织入)，直接跳过\n    if (className.startsWith(\"org.aspectj\") || className.startsWith(\"org/aspectj\")) {\n        return classfileBuffer;\n    }\n    return this.delegate.transform(loader, className, classBeingRedefined, \n        protectionDomain, classfileBuffer);\n}\n</code></pre>\n<p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p>\n<p>![ClassPreProcessorAgentAdapter类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ClassPreProcessorAgentAdapter.jpg)</p>\n<p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p>\n<h3>Aj</h3>\n<p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p>\n<h4>缓存</h4>\n<p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p>\n<h4>WeavingAdaptor初始化</h4>\n<p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p>\n<h5>aop.xml</h5>\n<h6>解析</h6>\n<p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p>\n<p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;aspectj&gt;\n    &lt;aspects&gt;\n        &lt;aspect name=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\"/&gt;\n        &lt;aspect name=\"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect\"/&gt;\n        &lt;aspect name=\"org.springframework.transaction.aspectj.AnnotationTransactionAspect\"/&gt;\n        &lt;aspect name=\"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect\"/&gt;\n        &lt;aspect name=\"org.springframework.cache.aspectj.AnnotationCacheAspect\"/&gt;\n        &lt;aspect name=\"org.springframework.cache.aspectj.JCacheCacheAspect\"/&gt;\n    &lt;/aspects&gt;\n&lt;/aspectj&gt;\n</code></pre>\n<p>那么解析后的结果:</p>\n<p>![aop.xml解析结果]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/aop_xml_parse.png)</p>\n<h6>注册</h6>\n<p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List&lt;Definition&gt; definitions) {\n    //对应&lt;weaver options=\"-verbose\"&gt;\n    registerOptions(weaver, loader, definitions);\n    //对应&lt;exclude&gt;标签\n    registerAspectExclude(weaver, loader, definitions);\n    //对应&lt;include&gt;标签\n    registerAspectInclude(weaver, loader, definitions);\n    // &lt;aspect&gt;\n    success = registerAspects(weaver, loader, definitions);\n    registerIncludeExclude(weaver, loader, definitions);\n    //对应&lt;dump&gt;标签\n    registerDump(weaver, loader, definitions);\n    //忽略返回\n}\n</code></pre>\n<h4>总结</h4>\n<p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>\n');
INSERT INTO `tb_article` VALUES (317, 'spring-mvc笔记', 'http://47.100.57.39/static/uploads/16/36231773f6704edcf1f68fdd38ee49.jpg', 'seaswalker', 'spring-mvc', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [初始化](#%E5%88%9D%E5%A7%8B%E5%8C%96)\n  - [容器初始化](#%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [根容器查找](#%E6%A0%B9%E5%AE%B9%E5%99%A8%E6%9F%A5%E6%89%BE)\n    - [容器创建](#%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA)\n      - [ApplicationContextInitializer](#applicationcontextinitializer)\n      - [配置解析](#%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90)\n        - [注解驱动](#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8)\n        - [静态资源处理](#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86)\n        - [拦截器](#%E6%8B%A6%E6%88%AA%E5%99%A8)\n        - [视图](#%E8%A7%86%E5%9B%BE)\n      - [Scope/处理器注册](#scope%E5%A4%84%E7%90%86%E5%99%A8%E6%B3%A8%E5%86%8C)\n  - [MVC初始化](#mvc%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [文件上传支持](#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%AF%E6%8C%81)\n    - [地区解析器](#%E5%9C%B0%E5%8C%BA%E8%A7%A3%E6%9E%90%E5%99%A8)\n    - [主题解析器](#%E4%B8%BB%E9%A2%98%E8%A7%A3%E6%9E%90%E5%99%A8)\n    - [HandlerMapping检查](#handlermapping%E6%A3%80%E6%9F%A5)\n    - [HandlerAdapter检查](#handleradapter%E6%A3%80%E6%9F%A5)\n    - [HandlerExceptionResolver检查](#handlerexceptionresolver%E6%A3%80%E6%9F%A5)\n    - [RequestToViewNameTranslator](#requesttoviewnametranslator)\n    - [ViewResolver检查](#viewresolver%E6%A3%80%E6%9F%A5)\n    - [FlashMapManager](#flashmapmanager)\n  - [HandlerMapping初始化](#handlermapping%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [RequestMappingHandlerMapping](#requestmappinghandlermapping)\n      - [跨域请求](#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82)\n      - [拦截器初始化](#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96)\n  - [HandlerAdapter初始化](#handleradapter%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [@ControllerAdvice](#controlleradvice)\n    - [参数解析器](#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8)\n    - [@InitBinder支持](#initbinder%E6%94%AF%E6%8C%81)\n    - [返回结果解析器](#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90%E5%99%A8)\n- [请求响应](#%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94)\n  - [请求上下文](#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87)\n  - [请求分发](#%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91)\n    - [处理器查找](#%E5%A4%84%E7%90%86%E5%99%A8%E6%9F%A5%E6%89%BE)\n    - [适配器查找](#%E9%80%82%E9%85%8D%E5%99%A8%E6%9F%A5%E6%89%BE)\n  - [请求处理](#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86)\n    - [Session同步](#session%E5%90%8C%E6%AD%A5)\n    - [参数解析](#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90)\n      - [策略模式](#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F)\n      - [自定义参数](#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0)\n          - [参数名是从哪里来的](#%E5%8F%82%E6%95%B0%E5%90%8D%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5%E7%9A%84)\n      - [Model](#model)\n      - [总结](#%E6%80%BB%E7%BB%93)\n    - [返回值解析](#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90)\n    - [视图渲染](#%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93)\n      - [ModelAndView](#modelandview)\n      - [渲染](#%E6%B8%B2%E6%9F%93)\n        - [ViewResolver](#viewresolver)\n        - [View](#view)\n- [拾遗](#%E6%8B%BE%E9%81%97)\n  - [@ResponseBody](#responsebody)\n    - [HttpMessageConverter](#httpmessageconverter)\n      - [自定义](#%E8%87%AA%E5%AE%9A%E4%B9%89)\n      - [默认](#%E9%BB%98%E8%AE%A4)\n    - [转换](#%E8%BD%AC%E6%8D%A2)\n  - [参数解析 & 结果转换](#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90--%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2)\n  - [\"纯\"对象参数接收](#%E7%BA%AF%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6)\n    - [参数对象构造](#%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0)\n    - [参数绑定](#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A)\n    - [参数校验](#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C)\n      - [JSR校验](#jsr%E6%A0%A1%E9%AA%8C)\n      - [自定义校验器](#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E5%99%A8)\n      - [一个有意思的问题](#%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 初始化\n\nspring-mvc的核心便是DispatcherServlet，所以初始化也是围绕其展开的。类图:\n\n![DispatcherServlet类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DispatcherServlet.jpg)\n\nServlet标准定义了init方法是其生命周期的初始化方法。\n\nHttpServletBean.init:\n\n```java\n@Override\npublic final void init() throws ServletException {\n    // Set bean properties from init parameters.\n    PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n    //包装DispatcherServlet，准备放入容器\n    BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n    //用以加载spring-mvc配置文件\n    ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n    bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n    //没有子类实现此方法\n    initBeanWrapper(bw);\n    bw.setPropertyValues(pvs, true);\n    // Let subclasses do whatever initialization they like.\n    initServletBean();\n}\n```\n\n主要逻辑一目了然。注意**setPropertyValues方法会导致对DispatcherServlet相关setter方法的调用，所以当进行容器初始化时从init-param中读取的参数已被设置到DispatcherServlet的相关字段(Field)中**。\n\n## 容器初始化\n\nFrameworkServlet.initServletBean简略版源码:\n\n```java\n@Override\nprotected final void initServletBean() {\n    this.webApplicationContext = initWebApplicationContext();\n    //空实现，且没有子类覆盖\n    initFrameworkServlet()\n}\n```\n\nFrameworkServlet.initWebApplicationContext:\n\n```java\nprotected WebApplicationContext initWebApplicationContext() {\n    //根容器查找\n    WebApplicationContext rootContext =\n            WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n    if (this.webApplicationContext != null) {\n        //有可能DispatcherServlet被作为Spring bean初始化，且webApplicationContext已被注入进来\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                if (cwac.getParent() == null) {\n                    cwac.setParent(rootContext);\n                }\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        //是否已经存在于ServletContext中\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        wac = createWebApplicationContext(rootContext);\n    }\n    if (!this.refreshEventReceived) {\n        onRefresh(wac);\n    }\n    if (this.publishContext) {\n        String attrName = getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    }\n    return wac;\n}\n```\n\n下面分部分展开。\n\n### 根容器查找\n\nspring-mvc支持Spring容器与MVC容器共存，此时，Spring容器即根容器，mvc容器将根容器视为父容器。\n\nSpring容器(根容器)以下列形式进行配置(web.xml):\n\n```xml\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n```\n\n根据Servlet规范，各组件的加载 顺序如下:\n\nlistener -> filter -> servlet\n\nWebApplicationContextUtils.getWebApplicationContext:\n\n```java\nString ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \".ROOT\";\npublic static WebApplicationContext getWebApplicationContext(ServletContext sc) {\n    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n}\n```\n\n两参数方法:\n\n```java\npublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n    Object attr = sc.getAttribute(attrName);\n    if (attr == null) {\n        return null;\n    }\n    return (WebApplicationContext) attr;\n}\n```\n\n可以得出结论:\n\n**如果Spring根容器存在，那么它被保存在ServletContext中，其key为`WebApplicationContext.class.getName() + \".ROOT\"`。**\n\n### 容器创建\n\nFrameworkServlet.createWebApplicationContext:\n\n```java\nprotected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {\n    Class<?> contextClass = getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException();\n    }\n    ConfigurableWebApplicationContext wac =\n            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n    wac.setEnvironment(getEnvironment());\n    wac.setParent(parent);\n    wac.setConfigLocation(getContextConfigLocation());\n    configureAndRefreshWebApplicationContext(wac);\n    return wac;\n}\n```\n\n通过对getContextClass方法的调用，Spring允许我们自定义容器的类型，即我们可以在web.xml中如下配置:\n\n```xml\n<servlet>\n    <servlet-name>SpringMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!-- 配置文件位置 -->\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:spring-servlet.xml</param-value>\n    </init-param>\n    <!-- 容器类型 -->\n    <init-param>\n        <param-name>contextClass</param-name>\n        <param-value>java.lang.Object</param-value>\n    </init-param>\n</servlet>\n```\n\nconfigureAndRefreshWebApplicationContext核心源码:\n\n```java\nprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {\n    applyInitializers(wac);\n    wac.refresh();\n}\n```\n\n#### ApplicationContextInitializer\n\nApplicationContextInitializer允许我们在Spring(mvc)容器初始化之前干点坏事，可以通过init-param传入:\n\n```xml\n<init-param>\n    <param-name>contextInitializerClasses</param-name>\n    <param-value>坏事儿</param-value>\n</init-param>\n```\n\napplyInitializers方法正是要触发这些坏事儿。类图:\n\n![ApplicationContextInitializer类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationContextInitializer.jpg)\n\n#### 配置解析\n\n\"配置\"指的便是spring-servlet.xml:\n\n```xml\n<context:component-scan base-package=\"controller\"/>\n<mvc:annotation-driven/>\n<!-- 启用对静态资源使用默认servlet处理，非REST方式不需要 -->\n<mvc:default-servlet-handler/>\n<!-- 配置视图 -->\n<bean class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\">\n    <!-- viewClass属性必不可少 -->\n    <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"></property>\n    <property name=\"prefix\" value=\"/WEB-INF/\"></property>\n    <property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n```\n\n而解析的入口便在于对refresh方法的调用，此方法位于AbstractApplicationContext，这一点在spring-core时已经见过了，下面我们重点关注不同于spring-core的地方。\n\n对于spring-mvc来说，其容器默认为XmlWebApplicationContext，部分类图:\n\n![XmlWebApplicationContext类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/XmlWebApplicationContext.jpg)\n\nXmlWebApplicationContext通过重写loadBeanDefinitions方法改变了bean加载行为，使其指向spring-servlet.xml。\n\nspring-servlet.xml中不同于spring-core的地方便在于引入了mvc命名空间，正如spring-core中笔记中所说的那样，**Spring用过jar包/META-INFO中的.handlers文件定义针对不同的命名空间所使用的解析器**。\n\nmvc命名空间的解析器为MvcNamespaceHandler，部分源码:\n\n```java\n@Override\npublic void init() {\n    registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());\n    registerBeanDefinitionParser(\"default-servlet-handler\", \n                                 new DefaultServletHandlerBeanDefinitionParser());\n    registerBeanDefinitionParser(\"interceptors\", new IanterceptorsBeanDefinitionParser());\n    registerBeanDefinitionParser(\"view-resolvers\", new ViewResolversBeanDefinitionParser());\n}\n```\n\n老样子，按部分展开。\n\n##### 注解驱动\n\n其parse方法负责向Sprng容器注册一些必要的组件，整理如下图:\n\n![mvc-annotation]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/mvc-annotation.png)\n\n##### 静态资源处理\n\n即:\n\n```xml\n<mvc:default-servlet-handler/>\n```\n\nDefaultServletHandlerBeanDefinitionParser.parse负责向容器注册以下三个组件:\n\n- DefaultServletHttpRequestHandler\n- SimpleUrlHandlerMapping\n- HttpRequestHandlerAdapter\n\n#####  拦截器\n\nInterceptorsBeanDefinitionParser.parse方法负责**将每一项`mvc:interceptor`配置解析为一个MappedInterceptor bean并注册到容器中**。\n\n##### 视图\n\n有两种方式向Spring容器注册视图:\n\n- 以前采用较土的方式:\n\n  ```xml\n  <bean class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\">\n    <!-- viewClass属性必不可少 -->\n      <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"></property>\n      <property name=\"prefix\" value=\"/WEB-INF/\"></property>\n      <property name=\"suffix\" value=\".jsp\"></property>\n  </bean>\n  ```\n\n- 通过特定的标签:\n\n  ```xml\n  <mvc:view-resolvers>\n    <mvc:jsp view-class=\"\" />\n  </mvc:view-resolvers>\n  ```\n\n从这里可以推测出: 拦截器同样支持第一种方式，Spring在查找时应该会查询某一接口的子类。\n\nViewResolversBeanDefinitionParser.parse方法的作用便是将每一个视图解析为ViewResolver并注册到容器。\n\n#### Scope/处理器注册\n\nAbstractRefreshableWebApplicationContext.postProcessBeanFactory:\n\n```java\n@Override\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    beanFactory.addBeanPostProcessor(\n        new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, \n        this.servletContext, this.servletConfig);\n}\n```\n\nServletContextAwareProcessor用以向实现了ServletContextAware的bean注册ServletContext。\n\nregisterWebApplicationScopes用以注册\"request\", \"session\", \"globalSession\", \"application\"四种scope，scope是个什么东西以及如何自定义，在spring-core中已经进行过说明了。\n\nregisterEnvironmentBeans用以将servletContext、servletConfig以及各种启动参数注册到Spring容器中。\n\n## MVC初始化\n\n入口位于DispatcherServlet的initStrategies方法(经由onRefresh调用):\n\n```java\nprotected void initStrategies(ApplicationContext context) {\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n}\n```\n\n显然，这里就是spring-mvc的核心了。\n\n### 文件上传支持\n\ninitMultipartResolver核心源码:\n\n```java\nprivate void initMultipartResolver(ApplicationContext context) {\n    try {\n        this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);\n    } catch (NoSuchBeanDefinitionException ex) {\n        // Default is no multipart resolver.\n        this.multipartResolver = null;\n    }\n}\n```\n\nMultipartResolver用于开启Spring MVC文件上传功能，其类图:\n\n![MultipartResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MultipartResolver.jpg)\n\n也就是说，如果我们要使用文件上传功能，须在容器中注册一个MultipartResolver bean。当然，默认是没有的。\n\n### 地区解析器\n\nLocaleResolver接口定义了Spring MVC如何获取客户端(浏览器)的地区，initLocaleResolver方法在容器中寻找此bean，如果没有，注册AcceptHeaderLocaleResolver，即根据request的请求头**Accept-Language**获取地区。\n\nspring-mvc采用了属性文件的方式配置默认策略(即bean)，此文件位于spring-mvc的jar包的org.springframework.web.servlet下。\n\n### 主题解析器\n\nThemeResolver接口配合Spring标签库使用可以通过动态决定使用的css以及图片的方式达到换肤的效果，其类图:\n\n![ThemeResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ThemeResolver.jpg)\n\n如果容器中不存在叫做themeResolver的bean，initThemeResolver方法将向容器中注册FixedThemeResolver，此bean只能提供一套默认的主题，名为theme。\n\n### HandlerMapping检查\n\ninitHandlerMappings方法用于确保容器中**至少含有一个HandlerMapping对象**。从前面配置解析-注解驱动一节中可以看出，注解驱动导致已经注册了两个此对象。\n\n如果没有开启注解驱动，那么将会使用默认的HandlerMapping，相关源码:\n\n```java\nif (this.handlerMappings == null) {\n    this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"No HandlerMappings found in servlet \'\" + getServletName() + \"\': using default\");\n    }\n}\n```\n\n前面提到了，默认的策略由DispatcherServlet.properties决定，**目前是BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping**。\n\n### HandlerAdapter检查\n\n套路和上面完全一样，默认使用HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter。\n\n### HandlerExceptionResolver检查\n\n套路和上面完全一样，默认使用AnnotationMethodHandlerExceptionResolver、ResponseStatusExceptionResolver、DefaultHandlerExceptionResolver。\n\n### RequestToViewNameTranslator\n\ninitRequestToViewNameTranslator方法回向容器中注册一个DefaultRequestToViewNameTranslator对象，此接口用以完成从HttpServletRequest到视图名的解析，其使用场景是**给定的URL无法匹配任何控制器时**。\n\nDefaultRequestToViewNameTranslator的转换例子:\n\nhttp://localhost:8080/gamecast/display.html -> display(视图)\n\n其类图:\n\n![RequestToViewNameTranslator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RequestToViewNameTranslator.jpg)\n\n### ViewResolver检查\n\n熟悉的套路，默认使用InternalResourceViewResolver。\n\n### FlashMapManager\n\ninitFlashMapManager方法会向容器注册SessionFlashMapManager对象，类图:\n\n![FlashMapManager类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/FlashMapManager.jpg)\n\n此接口和FlashMap搭配使用，用于在**请求重定向时保存/传递参数**。\n\n## HandlerMapping初始化\n\n此接口用以根据请求的URL寻找合适的处理器。从前面配置解析一节可以看出，我们的容器中有三个HandlerMapping实现，下面以RequestMappingHandlerMapping位代表进行说明。\n\n### RequestMappingHandlerMapping\n\n此实现根据@Controller和@RequestMapping注解完成解析。类图(忽略部分接口):\n\n![RequestMappingHandlerMapping类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RequestMappingHandlerMapping.jpg)\n\n初始化的入口位于AbstractHandlerMethodMapping的afterPropertiesSet方法和AbstractHandlerMapping的initApplicationContext方法，afterPropertiesSet调用了initHandlerMethods:\n\n```java\nprotected void initHandlerMethods() {\n    //获取容器中所有的bean\n    String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?\n            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class)             :getApplicationContext().getBeanNamesForType(Object.class));\n    for (String beanName : beanNames) {\n        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n            Class<?> beanType = null;\n            beanType = getApplicationContext().getType(beanName);\n             //isHandler方法的原理:\n             //判断类上有没有@Controller注解或者是@RequestMapping注解\n            if (beanType != null && isHandler(beanType)) {\n                detectHandlerMethods(beanName);\n            }\n        }\n    }\n    //空实现\n    handlerMethodsInitialized(getHandlerMethods());\n}\n```\n\ndetectHandlerMethods方法将反射遍历类中所有的public方法，如果方法上含有@RequestMapping注解，那么将方法上的路径与类上的基础路径(如果有)进行合并，之后将映射(匹配关系)注册到MappingRegistry中。\n\n注意，**类上的@RequestMapping注解只能作为基路径存在，也就是说，如果类里面没有任何的方法级@RequestMapping注解，那么类上的注解是没有意义的**。这一点可以从实验和源码上得到证实。\n\n下面我们关注一下映射关系是如何保存(注册)的。\n\n内部类AbstractHandlerMethodMapping.MappingRegistry是映射的载体，类图:\n\n![MappingRegistry类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MappingRegistry.jpg)\n\n其register方法简略版源码:\n\n```java\npublic void register(T mapping, Object handler, Method method) {\n    //包装bean和方法\n    HandlerMethod handlerMethod = createHandlerMethod(handler, method);\n    this.mappingLookup.put(mapping, handlerMethod);\n    List<String> directUrls = getDirectUrls(mapping);\n    for (String url : directUrls) {\n        this.urlLookup.add(url, mapping);\n    }\n    String name = null;\n    if (getNamingStrategy() != null) {\n        name = getNamingStrategy().getName(handlerMethod, mapping);\n        addMappingName(name, handlerMethod);\n    }\n    CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n    if (corsConfig != null) {\n        this.corsLookup.put(handlerMethod, corsConfig);\n    }\n    this.registry.put(mapping, new MappingRegistration<T>(mapping, handlerMethod, directUrls, name));\n}\n```\n\nmapping其实是一个RequestMappingInfo对象，可以将其看做是**@RequestMapping注解各种属性的一个封装**。最终由RequestMappingInfo.createRequestMappingInfo方法创建，源码:\n\n```java\nprotected RequestMappingInfo createRequestMappingInfo(\n        RequestMapping requestMapping, RequestCondition<?> customCondition) {\n    return RequestMappingInfo\n            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n            .methods(requestMapping.method())\n            .params(requestMapping.params())\n            .headers(requestMapping.headers())\n            .consumes(requestMapping.consumes())\n            .produces(requestMapping.produces())\n            .mappingName(requestMapping.name())\n            .customCondition(customCondition)\n            .options(this.config)\n            .build();\n}\n```\n\n这就很明显了，具体每种属性什么意义可以参考@RequestMapping源码。\n\nregister方法中urlLookup其实就是将paths属性中的每个path都与处理器做映射。\n\ngetNamingStrategy方法得到的是一个HandlerMethodMappingNamingStrategy接口的实例，此接口用以根据HandlerMethod得到一个名字，类图:\n\n![HandlerMethodMappingNamingStrategy类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodMappingNamingStrategy.jpg)\n\n比如对于我们的控制器,SimpleController.echo方法，最终得到的名字将是SC#echo。\n\n#### 跨域请求\n\nspring-mvc自4.2开启加入了跨域请求Cors的支持，主要有两种配置方式:\n\n- xml:\n\n  ```xml\n  <mvc:cors>\n    <mvc:mapping path=\"\"/>\n  </mvc:cors>\n  ```\n\n- @CrossOrigin注解。\n\nCors的原理可以参考:\n\n[探讨跨域请求资源的几种方式](http://www.cnblogs.com/dojo-lzz/p/4265637.html)\n\n而initCorsConfiguration方法的作用便是将@CrossOrigin注解的各种属性封装在CorsConfiguration中。\n\n#### 拦截器初始化\n\nAbstractHandlerMapping.initApplicationContext:\n\n```java\n@Override\nprotected void initApplicationContext() throws BeansException {\n    detectMappedInterceptors(this.adaptedInterceptors);\n}\n```\n\n作用就是从容器中获取所有MappedInterceptor bean并放到adaptedInterceptors中，前面提到过了，我们使用mvc:interceptor定义的拦截器其实就是MappedInterceptor对象。类图:\n\n![MappedInterceptor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MappedInterceptor.jpg)\n\n## HandlerAdapter初始化\n\n同样，我们以RequestMappingHandlerAdapter为例进行说明，类图:\n\n![RequestMappingHandlerAdapter类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RequestMappingHandlerAdapter.jpg)\n\n显然，入口在afterPropertiesSet方法:\n\n```java\n@Override\npublic void afterPropertiesSet() {\n    // Do this first, it may add ResponseBody advice beans\n    initControllerAdviceCache();\n    if (this.argumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite()\n            .addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite()\n            .addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite()\n            .addHandlers(handlers);\n    }\n}\n```\n\n### @ControllerAdvice\n\ninitControllerAdviceCache方法用以解析并存储标注了@ControllerAdvice的bean，这东西是干什么的参考：\n\n[Spring3.2新注解@ControllerAdvice](http://jinnianshilongnian.iteye.com/blog/1866350)\n\n### 参数解析器\n\nHandlerMethodArgumentResolver即参数解析器，负责从request中解析、得到Controller方法所需的参数。afterPropertiesSet方法设置了一组默认的解析器。具体是哪些参考getDefaultArgumentResolvers方法。类图:\n\n![HandlerMethodArgumentResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodArgumentResolver.jpg)\n\n### @InitBinder支持\n\n此注解定义的其实是自定义类型转换器。使用方法参考:\n\n[springMVC @initBinder 使用](http://blog.csdn.net/songzaiblog/article/details/49757253)\n\ngetDefaultInitBinderArgumentResolvers返回了一组默认使用的转换器，不过其实这里的转换器和上面的参数解析器其实是一个类型的，这里留个坑。\n\n### 返回结果解析器\n\nHandlerMethodReturnValueHandler接口用以处理方法调用(Controller方法)的返回值，类图:\n\n![HandlerMethodReturnValueHandler类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodReturnValueHandler.jpg)\n\ngetDefaultReturnValueHandlers方法便返回了一坨这东西。\n\n# 请求响应\n\n我们先来看一下入口在哪。众所周知，Servlet标准定义了所有请求先由service方法处理，如果是get或post方法，那么再交由doGet或是doPost方法处理。\n\nFrameworkServlet覆盖了service方法:\n\n```java\n@Override\nprotected void service(HttpServletRequest request, HttpServletResponse response) {\n    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    if (HttpMethod.PATCH == httpMethod || httpMethod == null) {\n        processRequest(request, response);\n    } else {\n        super.service(request, response);\n    }\n}\n```\n\nSpring要覆盖此方法的目的在于拦截PATCH请求，PATCH请求与PUT类似，不同在于PATCH是局部更新，而后者是全部更新。可以参考:\n\n[PATCH和PUT方法的区别？](https://segmentfault.com/q/1010000005685904)\n\nFrameworkServlet同样也覆盖了doGet和doPost方法，两者只是调用processRequest方法。\n\n## 请求上下文\n\nSpring MVC会在请求分发之前进行上下文的准备工作，含两部分:\n\n1. 将地区(Locale)和请求属性以ThreadLocal的方法与当前线程进行关联，分别可以通过LocaleContextHolder和RequestContextHolder进行获取。\n2. 将WebApplicationContext、FlashMap等组件放入到Request属性中。\n\n## 请求分发\n\nDispatcherServlet.doDispatch简略版源码:\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) {\n    HandlerExecutionChain mappedHandler = getHandler(processedRequest);\n    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n    applyDefaultViewName(processedRequest, mv);\n    mappedHandler.applyPostHandle(processedRequest, response, mv);\n    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n}\n```\n\n### 处理器查找\n\n即为请求寻找合适的Controller的过程。DispatcherServlet.getHandler:\n\n```java\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) {\n    for (HandlerMapping hm : this.handlerMappings) {\n        HandlerExecutionChain handler = hm.getHandler(request);\n        if (handler != null) {\n            return handler;\n        }\n    }\n    return null;\n}\n```\n\n从这里可以看出，寻找处理器实际上委托给HandlerMapping实现，寻找的过程便是遍历所有的HandlerMapping进行查找，**一旦找到，那么不再继续进行遍历**。也就是说HandlerMapping之间有优先级的概念，而根据AnnotationDrivenBeanDefinitionParser的注释，RequestMappingHandlerMapping其实有最高的优先级。\n\nAbstractHandlerMapping.getHandler:\n\n```java\n@Override\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    Object handler = getHandlerInternal(request);\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n    //判断请求头中是否有ORIGIN字段\n    if (CorsUtils.isCorsRequest(request)) {\n        CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);\n        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);\n        CorsConfiguration config = (globalConfig != null ? \n            globalConfig.combine(handlerConfig) : handlerConfig);\n        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);\n    }\n    return executionChain;\n}\n```\n\ngetHandlerInternal方法便是根据url进行查找的过程，可以参见MVC初始化-HandlerMapping初始化一节。下面重点是执行链的生成。\n\ngetHandlerExecutionChain方法的原理就是从adaptedInterceptors中获得所有可以适配当前请求URL的MappedInterceptor并将其添加到HandlerExecutionChain的拦截器列表中。拦截器的顺序其实就是我们定义/注册的顺序。\n\n从getCorsHandlerExecutionChain的源码中可以看出，对于跨域请求其实是向调用链插入了一个CorsInterceptor。\n\n### 适配器查找\n\nDispatcherServlet.getHandlerAdapter:\n\n```java\nprotected HandlerAdapter getHandlerAdapter(Object handler) {\n    for (HandlerAdapter ha : this.handlerAdapters) {\n        if (ha.supports(handler)) {\n            return ha;\n        }\n    }\n}\n```\n\n从前面配置解析-注解驱动可以看出，第一个适配器是RequestMappingHandlerAdapter，而其support方法直接返回true，这就导致了使用的适配器总是这一个。\n\n## 请求处理\n\nRequestMappingHandlerAdapter.handleInternal:\n\n```java\n@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n        HttpServletResponse response, HandlerMethod handlerMethod){\n    ModelAndView mav;\n    // Execute invokeHandlerMethod in synchronized block if required.\n    if (this.synchronizeOnSession) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            synchronized (mutex) {\n                mav = invokeHandlerMethod(request, response, handlerMethod);\n            }\n        } else {\n            // No HttpSession available -> no mutex necessary\n            mav = invokeHandlerMethod(request, response, handlerMethod);\n        }\n    } else {\n        // No synchronization on session demanded at all...\n        mav = invokeHandlerMethod(request, response, handlerMethod);\n    }\n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n        }\n        else {\n            prepareResponse(response);\n        }\n    }\n    return mav;\n}\n```\n\n### Session同步\n\n可以看出，如果开启了synchronizeOnSession，那么**同一个session的请求将会串行执行**，这一选项默认是关闭的，当然我们可以通过注入的方式进行改变。\n\n### 参数解析\n\n#### 策略模式\n\n正如前面HandlerAdapter初始化-参数解析器一节提到的，HandlerAdapter内部含有一组解析器负责对各类型的参数进行解析。下面我们就常用的自定义参数和Model为例进行说明。\n\n#### 自定义参数\n\n解析由RequestParamMethodArgumentResolver完成。\n\nsupportsParameter方法决定了一个解析器可以解析的参数类型，该解析器支持@RequestParam标准的参数或是**简单类型**的参数，具体参见其注释。为什么此解析器可以同时解析@RequestParam注解和普通参数呢?玄机在于RequestMappingHandlerAdapter方法在初始化参数解析器时其实初始化了**两个RequestMappingHandlerAdapter对象**，getDefaultArgumentResolvers方法相关源码:\n\n```java\nprivate List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers() {\n    resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));\n    // Catch-all\n    resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));\n}\n```\n\nuseDefaultResolution参数用于启动对常规类型参数的解析，这里的常规类型指的又是什么呢?\n\n实际上由BeanUtils.isSimpleProperty方法决定:\n\n```java\npublic static boolean isSimpleProperty(Class<?> clazz) {\n    Assert.notNull(clazz, \"Class must not be null\");\n    return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()));\n}\n\npublic static boolean isSimpleValueType(Class<?> clazz) {\n    return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||\n            CharSequence.class.isAssignableFrom(clazz) ||\n            Number.class.isAssignableFrom(clazz) ||\n            Date.class.isAssignableFrom(clazz) ||\n            URI.class == clazz || URL.class == clazz ||\n            Locale.class == clazz || Class.class == clazz);\n}\n```\n\n忽略复杂的调用关系，最核心的实现位于resolveName方法，部分源码:\n\n```java\n@Override\nprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) {\n    if (arg == null) {\n        String[] paramValues = request.getParameterValues(name);\n        if (paramValues != null) {\n            arg = (paramValues.length == 1 ? paramValues[0] : paramValues);\n        }\n    }\n    return arg;\n}\n```\n\nname就是方法的参数名，可以看出，参数解析**就是根据参数名去request查找对应属性的过程**，在这里参数类型并没有起什么作用。\n\n###### 参数名是从哪里来的\n\n方法名获取的入口位于RequestParamMethodArgumentResolver的resolveArgument方法:\n\n```java\n@Override\npublic final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n}\n```\n\ngetNamedValueInfo方法最终完成对MethodParameter的getParameterName方法的调用:\n\n```java\npublic String getParameterName() {\n    ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;\n    if (discoverer != null) {\n        String[] parameterNames = (this.method != null ?\n                discoverer.getParameterNames(this.method) : discoverer.getParameterNames(this.constructor));\n        if (parameterNames != null) {\n            this.parameterName = parameterNames[this.parameterIndex];\n        }\n        this.parameterNameDiscoverer = null;\n    }\n    return this.parameterName;\n}\n```\n\n显然，参数名的获取由接口ParameterNameDiscoverer完成:\n\n![ParameterNameDiscoverer]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ParameterNameDiscoverer.jpg)\n\n默认采用DefaultParameterNameDiscoverer，但此类其实相当于StandardReflectionParameterNameDiscoverer和LocalVariableTableParameterNameDiscoverer的组合，且前者先于后者进行解析。\n\nStandardReflectionParameterNameDiscoverer.getParameterNames:\n\n```java\n@Override\npublic String[] getParameterNames(Method method) {\n    Parameter[] parameters = method.getParameters();\n    String[] parameterNames = new String[parameters.length];\n    for (int i = 0; i < parameters.length; i++) {\n        Parameter param = parameters[i];\n        if (!param.isNamePresent()) {\n            return null;\n        }\n        parameterNames[i] = param.getName();\n    }\n    return parameterNames;\n}\n```\n\n此类被注解UsesJava8标注，其原理就是利用的jdk8的-parameters编译参数，只有在加上此选项的情况下才能用反射的方法获得真实的参数名，所以一般情况下StandardReflectionParameterNameDiscoverer是无法成功获取参数名的。\n\nLocalVariableTableParameterNameDiscoverer利用了ASM直接访问class文件中的本地变量表来得到变量名，下面是使用`javap -verbose`命令得到的本地变量表示例:\n\n![本地变量表]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/local_variable_tables.PNG)\n\n但是默认情况下javac compiler是不生成本地变量表这种调试信息的，需要加`-g`参数才可以，那为什么在我们的测试Controller中却可以获得呢，玄机就在于idea的下列设置:\n\n![idea编译设置]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/idea_debug_info.PNG)\n\n取消这项设置的勾选再次运行程序便出问题了:\n\n![调试信息错误]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/debug_info_error.PNG)\n\n#### Model\n\n解析由ModelMethodProcessor完成。\n\nsupportsParameter方法很简单:\n\n```java\n@Override\npublic boolean supportsParameter(MethodParameter parameter) {\n    return Model.class.isAssignableFrom(parameter.getParameterType());\n}\n```\n\n很直白了。\n\nresolveArgument：\n\n```java\n@Override\npublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    return mavContainer.getModel();\n}\n```\n\n忽略各种调用关系，**Model其实是一个BindingAwareModelMap对象，且每次请求(需要注入Model的前提下)都有一个新的该对象生成**。类图:\n\n![BindingAwareModelMap类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BindingAwareModelMap.jpg)\n\n#### 总结\n\n- 我们可以通过实现HandlerMethodArgumentResolver接口并将其注册容器的方式实现自定义参数类型的解析。\n- 为了防止出现参数名获取不到的问题，应优先使用@RequestParam注解直接声明需要的参数名称。\n\n### 返回值解析\n\n套路和上面是一样的，通常情况，我们返回的其实是view名，负责处理的是ViewNameMethodReturnValueHandler，\n\nsupportsReturnType方法:\n\n```java\n@Override\npublic boolean supportsReturnType(MethodParameter returnType) {\n    Class<?> paramType = returnType.getParameterType();\n    return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));\n}\n```\n\nhandleReturnValue:\n\n```java\n@Override\npublic void handleReturnValue(Object returnValue, MethodParameter returnType,\n        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n    if (returnValue instanceof CharSequence) {\n        String viewName = returnValue.toString();\n        mavContainer.setViewName(viewName);\n         // 判断的依据: 是否以redirect:开头\n        if (isRedirectViewName(viewName)) {\n            mavContainer.setRedirectModelScenario(true);\n        }\n    }\n}\n```\n\n可见这里并没有进行实际的处理，只是解析得到了最终的视图名称。\n\n### 视图渲染\n\n由DispatcherServlet的processDispatchResult方法完成，源码:\n\n```java\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) {\n    boolean errorView = false;\n    if (exception != null) {\n         //一般不会到这个分支\n        if (exception instanceof ModelAndViewDefiningException) {\n            mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n        } else {\n            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n            mv = processHandlerException(request, response, handler, exception);\n            errorView = (mv != null);\n        }\n    }\n    // Did the handler return a view to render?\n    if (mv != null && !mv.wasCleared()) {\n        render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    }\n}\n```\n\n可以看出，处理**根据是否抛出异常分为了两种情况**。\n\n如果抛出了异常，那么processHandlerException方法将会遍历所有的HandlerExceptionResolver实例，默认有哪些参考MVC初始化-HandlerExceptionResolver检查一节。默认的处理器用于改变响应状态码、调用标注了@ExceptionHandler的bean进行处理，如果没有@ExceptionHandler的bean或是不能处理此类异常，那么就会导致ModelAndView始终为null，最终Spring MVC将异常向上抛给Tomcat，然后Tomcat就会把堆栈打印出来。\n\n如果我们想将其定向到指定的错误页面，可以这样配置:\n\n```xml\n<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"defaultErrorView\" value=\"error\"></property>\n</bean>\n```\n\n此处理器会返回一个非空的ModelAndView。\n\n#### ModelAndView\n\n回过头来看一下这到底是个什么东西。类图:\n\n![ModelAndView类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ModelAndView.jpg)\n\n很直白。\n\n怎么生成的。RequestMappingHandlerAdapter.getModelAndView相关源码:\n\n```java\nModelMap model = mavContainer.getModel();\nModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());\n```\n\n#### 渲染\n\nDispatcherServlet.render简略版源码:\n\n```java\nprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) {\n    Locale locale = this.localeResolver.resolveLocale(request);\n    response.setLocale(locale);\n    View view;\n    //判断依据: 是否是String类型\n    if (mv.isReference()) {\n        // We need to resolve the view name.\n        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);\n    } else {\n        // No need to lookup: the ModelAndView object contains the actual View object.\n        view = mv.getView();\n    }\n    if (mv.getStatus() != null) {\n        response.setStatus(mv.getStatus().value());\n    }\n    view.render(mv.getModelInternal(), request, response);\n}\n```\n\nresolveViewName方法将会遍历所有的ViewResolver bean，只要有一个解析的结果(View)不为空，即停止遍历。根据MVC初始化-ViewResolver检查一节和我们的配置文件可知，容器中有两个ViewResolver ，分别是: InternalResourceViewResolver和UrlBasedViewResolver。\n\n##### ViewResolver\n\n类图(忽略实现类):\n\n![ViewResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ViewResolver.jpg)\n\nresolveViewName方法的源码不再贴出，其实只做了一件事: 用反射创建并初始化我们指定的View，根据我们的配置，就是JstlView。\n\n##### View\n\n类图:\n\n![JstlView类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/JstlView.jpg)\n\n渲染的核心逻辑位于InternalResourceView.renderMergedOutputModel，简略版源码:\n\n```java\n@Override\nprotected void renderMergedOutputModel(\n        Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) {\n    // 将Model中的属性设置的request中\n    exposeModelAsRequestAttributes(model, request);\n    // 获取资源(jsp)路径\n    String dispatcherPath = prepareForRendering(request, response);\n    // Obtain a RequestDispatcher for the target resource (typically a JSP).\n    RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);\n    // If already included or response already committed, perform include, else forward.\n    if (useInclude(request, response)) {\n        response.setContentType(getContentType());\n        rd.include(request, response);\n    } else {\n        // Note: The forwarded resource is supposed to determine the content type itself.\n        rd.forward(request, response);\n    }\n}\n```\n\n可以看出，对jsp来说，所谓的渲染其实就是**将Model中的属性设置到Request，再利用原生Servlet RequestDispatcher API进行转发的过程**。\n\n# 拾遗\n\n## @ResponseBody\n\n通常我们可以在Controller或方法上标注@ResponseBody注解以表示需要将对象转为JSON并返回给前端，那么Spring MVC是如何自动完成这一过程的呢?\n\n从前面初始化-容器初始化-容器创建-配置解析一节可以看出，Spring MVC采用org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser进行配置的解析，核心的parse方法中完成了对HttpMessageConverter的初始化。\n\n### HttpMessageConverter\n\nSpring的HttpMessageConverter接口负责HTTP请求-Java对象与Java对象-响应之间的转换。我们以Spring默认使用的Jackson转换器为例，类图:\n\n![HttpMessageConverter]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HttpMessageConverter.jpg)\n\nHttpMessageConverter实现的初始化由AnnotationDrivenBeanDefinitionParser的getMessageConverters方法完成，HttpMessageConverter的来源分为自定义和默认。\n\n示例配置:\n\n```xml\n<mvc:annotation-driven>\n  <mvc:message-converters register-defaults=\"true\">\n    <bean class=\"test.Converter\" />\n  </mvc:message-converters>\n</mvc:annotation-driven>\n```\n\n#### 自定义\n\nSpring允许我们通过XML配置文件的message-converters元素来进行自定义。\n\n#### 默认\n\n当**检测到没有配置message-converters元素或者register-defaults=\"true\"时Spring便会注册默认转换器**。这其中便包括MappingJacksonHttpMessageConverter，相关源码:\n\n```java\nelse if (jacksonPresent) {\n    messageConverters.add(createConverterDefinition(\n        org.springframework.http.converter.json.MappingJacksonHttpMessageConverter.class, source));\n}\n```\n\njacksonPresent声明:\n\n```java\nprivate static final boolean jacksonPresent =\n    ClassUtils.isPresent(\"org.codehaus.jackson.map.ObjectMapper\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader()) &&\n    ClassUtils.isPresent(\"org.codehaus.jackson.JsonGenerator\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader());\n```\n\n### 转换\n\n入口位于ServletInvocableHandlerMethod的invokeAndHandle方法对于响应的处理:\n\n```java\nthis.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n```\n\nreturnValueHandlers其实就是RequestMappingHandlerAdapter内部的returnValueHandlers，后者由RequestMappingHandlerAdapter的afterPropertiesSet方法初始化，关键在于:\n\n```java\nhandlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.contentNegotiationManager));\n```\n\n对象到JSON的转换正是由RequestResponseBodyMethodProcessor完成，ServletInvocableHandlerMethod通过supportsReturnType方法决定HandlerMethodReturnValueHandler是否可以处理当前返回类型或返回方法，RequestResponseBodyMethodProcessor的实现:\n\n```java\n@Override\npublic boolean supportsReturnType(MethodParameter returnType) {\n    return ((AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != null) ||\n        (returnType.getMethodAnnotation(ResponseBody.class) != null));\n}\n```\n\n核心的handleReturnValue方法:\n\n```java\n@Override\npublic void handleReturnValue(Object returnValue, MethodParameter returnType,\n    ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n    mavContainer.setRequestHandled(true);\n    if (returnValue != null) {\n        writeWithMessageConverters(returnValue, returnType, webRequest);\n    }\n}\n```\n\n这里其实是通过HttpMessageConverter的canRead或canWrite方法来判断给定的转换器是否合适，canWrite方法实现:\n\n```java\n@Override\npublic boolean canWrite(Class<?> clazz, MediaType mediaType) {\n    return (this.objectMapper.canSerialize(clazz) && canWrite(mediaType));\n}\n```\n\n这里剩下的便是Jackson的事情了，注意MappingJacksonHttpMessageConverter中的objectMapper被所有的线程所共享，因为其是线程安全的，但是这样是否有性能问题?\n\n## 参数解析 & 结果转换\n\nSpring MVC中参数到各种类型的转换由HandlerMethodArgumentResolver接口完成，而Controller返回值到真正的响应的转换由HandlerMethodReturnValueHandler接口完成。两者分别负责Spring MVC中数据的输入与输出，可用下图表示:\n\n![Spring MVC输入输出转换]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/mvc_input_output.PNG)\n\nHandlerMethodArgumentResolver接口及其主要实现类如下图:\n\n![HandlerMethodArgumentResolver]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodArgumentResolver_all.jpg)\n\nHandlerMethodReturnValueHandler接口以及主要实现类如下:\n\n![HandlerMethodReturnValueHandler]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodReturnValueHandler_all.jpg)\n\n其实有很多类同时实现了两个接口，比如RequestResponseBodyMethodProcessor，这样的类一般以Processor结尾。\n\n两种转换器的初始化由HandlerAdapter完成，这也很好的体现了HandlerAdapter接口的功能。以喜闻乐见的RequestMappingHandlerAdapter为例，其初始化的HandlerMethodReturnValueHandler列表如下:\n\n- ModelAndViewMethodReturnValueHandler\n- ModelMethodProcessor\n- HttpEntityMethodProcessor\n- HttpHeadersReturnValueHandler\n- CallableMethodReturnValueHandler\n- DeferredResultMethodReturnValueHandler\n- AsyncTaskMethodReturnValueHandler\n- ListenableFutureReturnValueHandler\n- ModelAttributeMethodProcessor\n- RequestResponseBodyMethodProcessor\n- ViewNameMethodReturnValueHandler\n- MapMethodProcessor\n- ModelAndViewResolverMethodReturnValueHandler\n\n从中也可以推测出我们可以把哪些类型的值(对象)直接\"丢给\"Spring。\n\n对于HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler来说，HttpMessageConverter像是两者手中用来实现功能的武器。\n\n## \"纯\"对象参数接收\n\n假设有如下这样的Controller:\n\n```java\n@RequestMapping(\"/echoAgain\")\npublic String echo(SimpleModel simpleModel, Model model) {\n    model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\");\n    return \"echo\";\n}\n```\n\n经过测试可以发现，SimpleModel参数既可以接收get请求，也可以接收post请求。那么在这种情况下请求参数是被哪个参数解析器解析的呢，debug发现: ServletModelAttributeMethodProcessor：\n\n![ServletModelAttributeMethodProcessor]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ServletModelAttributeMethodProcessor.jpg)\n\n核心的supportsParameter方法由父类ModelAttributeMethodProcessor实现:\n\n```java\n@Override\npublic boolean supportsParameter(MethodParameter parameter) {\n    return (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n        (this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n}\n```\n\n可以看出，这里支持带有ModelAttribute注解或者是非基本类型的参数解析，同时annotationNotRequired必须设为false，即ModelAttribute注解不必存在，这里是在ServletModelAttributeMethodProcessor的构造器中进行控制的，\nRequestMappingHandlerAdapter.getDefaultArgumentResolvers部分源码:\n\n```java\nresolvers.add(new ServletModelAttributeMethodProcessor(false));\n```\n\n此类的作用是对@ModelAttribute注解标注的参数进行解析，假设我们将Controller方法改写成:\n\n```java\n@RequestMapping(\"/echoAgain\")\npublic String echo(@ModelAttribute SimpleModel simpleModel, Model model) {\n    model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\");\n    System.out.println(model.asMap().get(\"simpleModel\"));\n    return \"echo\";\n}\n```\n\n首先，Spring会首先反射生成一个SimpleModel对象，之后将从request中获取的参数尝试设置到SimpleModel对象中去，最后将此对象放置到Model中(本质上就是一个Map)，key就是simpleModel.下面我们来看一下具体的解析过程，整个过程可以分为\n以下三部分:\n\n### 参数对象构造\n\n因为SimpleModel是一个对象类型，所以要想将参数注入到其中，第一步必然是先创建一个对象，创建的入口位于ModelAttributeMethodProcessor的resolveArgument方法，相关源码:\n\n```java\n//name在这里便是simpleModel\nString name = ModelFactory.getNameForParameter(parameter);\nObject attribute = (mavContainer.containsAttribute(name) ? mavContainer.getModel().get(name) :\n                    createAttribute(name, parameter, binderFactory, webRequest));//反射实例化\n```\n\nModelAndViewContainer是个什么东西呢，从名字就可以看出就，它是Spring MVC里两个重要概念Model和View的组合体，用来记录在请求响应过程中Model和View的变化，在这里可以简单理解为去Model中检查有没有叫simpleModel的属性已经存在。\n\n### 参数绑定\n\n这里使用到了DataBinder接口，按照注释的说明，此接口用以**向执行的对象中设置属性值**，就是这么简单，其继承体系如下图:\n\n![DataBinder]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DataBinder.jpg)\n\nWebDataBinderFactory接口用以创建WebDataBinder对象，其继承体系如下图:\n\n![WebDataBinderFactory]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/WebDataBinderFactory.jpg)\n\n默认使用的是ServletRequestDataBinderFactory，创建了一个ExtendedServletRequestDataBinder对象:\n\n```java\n@Override\nprotected ServletRequestDataBinder createBinderInstance(Object target, String objectName, NativeWebRequest request) {\n    return new ExtendedServletRequestDataBinder(target, objectName);\n}\n```\n\n参数绑定的入口位于ModelAttributeMethodProcessor.resolveArgument方法，相关源码:\n\n```java\nif (!mavContainer.isBindingDisabled(name)) {\n    bindRequestParameters(binder, webRequest);\n}\n```\n\n接下来由ServletRequestDataBinder的bind方法完成，核心源码:\n\n```java\npublic void bind(ServletRequest request) {\n    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);\n    doBind(mpvs);\n}\n```\n\n在ServletRequestParameterPropertyValues构造器中获取了Request中所有的属性对。doBind方法便是调用前面初始化的目标对象的setter方法进行参数设置的过程，不再展开。\n\n### 参数校验\n\n将我们的Controller方法改写为下面这种形式便可以启动Spring MVC的参数校验:\n\n```java\n@RequestMapping(\"/echoAgain\")\npublic String echo(@Validated SimpleModel simpleModel, Model model) {\n    model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\");\n    System.out.println(model.asMap().get(\"simpleModel\"));\n    return \"echo\";\n}\n```\n\n在这里@Validated注解可以用@Valid(javax)替换，前者是Spring对java校验标准的扩充，增加了校验组的支持。\n为什么参数校验要放到参数绑定后面进行说明呢，因为**@Validated和@valid注解不会影响Spring MVC参数解析的行为，被这两个注解标注的对象仍是由参数绑定一节提到的解析器进行解析。**\n\n当参数校验绑定之后，Spring MVC会尝试对参数进行校验，如果我们设置了校验注解。ModelAttributeMethodProcessor.resolveArgument方法相关源码:\n\n```java\nvalidateIfApplicable(binder, parameter);\n\nprotected void validateIfApplicable(WebDataBinder binder, MethodParameter methodParam) {\n    Annotation[] annotations = methodParam.getParameterAnnotations();\n    for (Annotation ann : annotations) {\n        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n            binder.validate(validationHints);\n            break;\n        }\n    }\n}\n```\n\nDataBinder.validate:\n\n```java\npublic void validate(Object... validationHints) {\n    for (Validator validator : getValidators()) {\n        if (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator) {\n            ((SmartValidator) validator).validate(getTarget(), getBindingResult(), validationHints);\n        } else if (validator != null) {\n            validator.validate(getTarget(), getBindingResult());\n        }\n    }\n}\n```\n\n可见，具体的校验交给了`org.springframework.validation.Validator`实现，类图:\n\n![Validator]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Validator.png)\n\ngetValidators方法获取的实际上是DataBinder内部的validators字段:\n\n```java\nprivate final List<Validator> validators = new ArrayList<Validator>();\n```\n\n根据这里的校验器的来源可以分为以下两种情况。\n\n#### JSR校验\n\n需要引入hibernate-validator到classpath中，回顾最前面配置解析部分，配置:\n\n```xml\n<mvc:annotation-driven/>\n```\n\n会利用AnnotationDrivenBeanDefinitionParser进行相关的解析、初始化工作，正是在其parse方法完成了对JSR校验的支持。相关源码:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    RuntimeBeanReference validator = getValidator(element, source, parserContext);\n}\n\nprivate RuntimeBeanReference getValidator(Element element, Object source, ParserContext parserContext) {\n    //mvc:annotation-driven配置支持validator属性\n    if (element.hasAttribute(\"validator\")) {\n        return new RuntimeBeanReference(element.getAttribute(\"validator\"));\n    } else if (javaxValidationPresent) {\n        RootBeanDefinition validatorDef = new RootBeanDefinition(\n                \"org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean\");\n        validatorDef.setSource(source);\n        validatorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        String validatorName = parserContext.getReaderContext().registerWithGeneratedName(validatorDef);\n        parserContext.registerComponent(new BeanComponentDefinition(validatorDef, validatorName));\n        return new RuntimeBeanReference(validatorName);\n    } else {\n        return null;\n    }\n}\n```\n\njavaxValidationPresent的定义:\n\n```java\nprivate static final boolean javaxValidationPresent =\n    ClassUtils.isPresent(\"javax.validation.Validator\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader());\n```\n\n 实现了InitializingBean接口，所以afterPropertiesSet方法是其初始化的入口，具体的校验过程不再展开。\n 除此之外还有一个有意思的问题，就是上面提到的校验器是如何进入到DataBinder中去的呢?答案是WebDataBinderFactory创建DataBinder对象时会利用WebBindingInitializer对DataBinder进行初始化，正是在这里\n 将容器中存在的校验器设置到DataBinder中，至于WebBindingInitializer又是从哪里来的，不再探究了，否则这细节实在是太麻烦了，意义不大。\n\n#### 自定义校验器\n\n我们可以实现Spring提供的Validator接口，然后在Controller里边这样设置我们要是用的校验器:\n\n```java\n@InitBinder\npublic void initBinder(DataBinder dataBinder) {\n    dataBinder.setValidator(new SimpleModelValidator());\n    //如果有多个可以使用addValidators方法\n}\n```\n\n我们的Controller方法依然可以如此定义:\n\n```java\n@RequestMapping(\"/echoAgain\")\npublic String echo(@Validated SimpleModel simpleModel, Model model) {\n    return \"echo\";\n}\n```\n\n如果有错误，会直接返回400.\n\n#### 一个有意思的问题\n\n如果我们把Controller方法这样定义会怎样?\n\n```java\n@RequestMapping(value = \"/echoAgain\", method = RequestMethod.POST)\npublic String echo(@Validated @RequestBody SimpleModel simpleModel, Model model) {}\n```\n\n答案是@RequestBody注解先于@Validated注解起作用，这样既可以利用@RequestBody注解向Controller传递json串，同时又能够达到校验的目的。从源码的角度来说，这在很大程度上是一个顺序的问题:\nRequestMappingHandlerAdapter.getDefaultArgumentResolvers相关源码:\n\n```java\nresolvers.add(new ServletModelAttributeMethodProcessor(false));\nresolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n```\n\n虽然ServletModelAttributeMethodProcessor位于RequestResponseBodyMethodProcessor之前，但构造器参数为false说明了此解析器必须要求参数被@ModelAttribute注解标注，其实在最后还有一个不需要注解的解析器被添加:\n\n```java\n// Catch-all\nresolvers.add(new ServletModelAttributeMethodProcessor(true));\n```\n\n至此，真相大白。', '', '2', 0, '2020-01-08 17:05:15', '2020-01-08 17:05:15', '2020-01-08 17:02:00', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\">初始化</a>\n<ul>\n<li><a href=\"#%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96\">容器初始化</a>\n<ul>\n<li><a href=\"#%E6%A0%B9%E5%AE%B9%E5%99%A8%E6%9F%A5%E6%89%BE\">根容器查找</a></li>\n<li><a href=\"#%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA\">容器创建</a>\n<ul>\n<li><a href=\"#applicationcontextinitializer\">ApplicationContextInitializer</a></li>\n<li><a href=\"#%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90\">配置解析</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8\">注解驱动</a></li>\n<li><a href=\"#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86\">静态资源处理</a></li>\n<li><a href=\"#%E6%8B%A6%E6%88%AA%E5%99%A8\">拦截器</a></li>\n<li><a href=\"#%E8%A7%86%E5%9B%BE\">视图</a></li>\n</ul>\n</li>\n<li><a href=\"#scope%E5%A4%84%E7%90%86%E5%99%A8%E6%B3%A8%E5%86%8C\">Scope/处理器注册</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#mvc%E5%88%9D%E5%A7%8B%E5%8C%96\">MVC初始化</a>\n<ul>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%AF%E6%8C%81\">文件上传支持</a></li>\n<li><a href=\"#%E5%9C%B0%E5%8C%BA%E8%A7%A3%E6%9E%90%E5%99%A8\">地区解析器</a></li>\n<li><a href=\"#%E4%B8%BB%E9%A2%98%E8%A7%A3%E6%9E%90%E5%99%A8\">主题解析器</a></li>\n<li><a href=\"#handlermapping%E6%A3%80%E6%9F%A5\">HandlerMapping检查</a></li>\n<li><a href=\"#handleradapter%E6%A3%80%E6%9F%A5\">HandlerAdapter检查</a></li>\n<li><a href=\"#handlerexceptionresolver%E6%A3%80%E6%9F%A5\">HandlerExceptionResolver检查</a></li>\n<li><a href=\"#requesttoviewnametranslator\">RequestToViewNameTranslator</a></li>\n<li><a href=\"#viewresolver%E6%A3%80%E6%9F%A5\">ViewResolver检查</a></li>\n<li><a href=\"#flashmapmanager\">FlashMapManager</a></li>\n</ul>\n</li>\n<li><a href=\"#handlermapping%E5%88%9D%E5%A7%8B%E5%8C%96\">HandlerMapping初始化</a>\n<ul>\n<li><a href=\"#requestmappinghandlermapping\">RequestMappingHandlerMapping</a>\n<ul>\n<li><a href=\"#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82\">跨域请求</a></li>\n<li><a href=\"#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96\">拦截器初始化</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#handleradapter%E5%88%9D%E5%A7%8B%E5%8C%96\">HandlerAdapter初始化</a>\n<ul>\n<li><a href=\"#controlleradvice\">@ControllerAdvice</a></li>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8\">参数解析器</a></li>\n<li><a href=\"#initbinder%E6%94%AF%E6%8C%81\">@InitBinder支持</a></li>\n<li><a href=\"#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90%E5%99%A8\">返回结果解析器</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94\">请求响应</a>\n<ul>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87\">请求上下文</a></li>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91\">请求分发</a>\n<ul>\n<li><a href=\"#%E5%A4%84%E7%90%86%E5%99%A8%E6%9F%A5%E6%89%BE\">处理器查找</a></li>\n<li><a href=\"#%E9%80%82%E9%85%8D%E5%99%A8%E6%9F%A5%E6%89%BE\">适配器查找</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86\">请求处理</a>\n<ul>\n<li><a href=\"#session%E5%90%8C%E6%AD%A5\">Session同步</a></li>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90\">参数解析</a>\n<ul>\n<li><a href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\">策略模式</a></li>\n<li><a href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0\">自定义参数</a>\n<ul>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E5%90%8D%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5%E7%9A%84\">参数名是从哪里来的</a></li>\n</ul>\n</li>\n<li><a href=\"#model\">Model</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90\">返回值解析</a></li>\n<li><a href=\"#%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93\">视图渲染</a>\n<ul>\n<li><a href=\"#modelandview\">ModelAndView</a></li>\n<li><a href=\"#%E6%B8%B2%E6%9F%93\">渲染</a>\n<ul>\n<li><a href=\"#viewresolver\">ViewResolver</a></li>\n<li><a href=\"#view\">View</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%8B%BE%E9%81%97\">拾遗</a>\n<ul>\n<li><a href=\"#responsebody\">@ResponseBody</a>\n<ul>\n<li><a href=\"#httpmessageconverter\">HttpMessageConverter</a>\n<ul>\n<li><a href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89\">自定义</a></li>\n<li><a href=\"#%E9%BB%98%E8%AE%A4\">默认</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BD%AC%E6%8D%A2\">转换</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90--%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2\">参数解析 &amp; 结果转换</a></li>\n<li><a href=\"#%E7%BA%AF%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6\">\"纯\"对象参数接收</a>\n<ul>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0\">参数对象构造</a></li>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A\">参数绑定</a></li>\n<li><a href=\"#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C\">参数校验</a>\n<ul>\n<li><a href=\"#jsr%E6%A0%A1%E9%AA%8C\">JSR校验</a></li>\n<li><a href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E5%99%A8\">自定义校验器</a></li>\n<li><a href=\"#%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98\">一个有意思的问题</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n<h1>初始化</h1>\n<p>spring-mvc的核心便是DispatcherServlet，所以初始化也是围绕其展开的。类图:</p>\n<p>![DispatcherServlet类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DispatcherServlet.jpg)</p>\n<p>Servlet标准定义了init方法是其生命周期的初始化方法。</p>\n<p>HttpServletBean.init:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic final void init() throws ServletException {\n    // Set bean properties from init parameters.\n    PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n    //包装DispatcherServlet，准备放入容器\n    BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n    //用以加载spring-mvc配置文件\n    ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n    bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n    //没有子类实现此方法\n    initBeanWrapper(bw);\n    bw.setPropertyValues(pvs, true);\n    // Let subclasses do whatever initialization they like.\n    initServletBean();\n}\n</code></pre>\n<p>主要逻辑一目了然。注意<strong>setPropertyValues方法会导致对DispatcherServlet相关setter方法的调用，所以当进行容器初始化时从init-param中读取的参数已被设置到DispatcherServlet的相关字段(Field)中</strong>。</p>\n<h2>容器初始化</h2>\n<p>FrameworkServlet.initServletBean简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected final void initServletBean() {\n    this.webApplicationContext = initWebApplicationContext();\n    //空实现，且没有子类覆盖\n    initFrameworkServlet()\n}\n</code></pre>\n<p>FrameworkServlet.initWebApplicationContext:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected WebApplicationContext initWebApplicationContext() {\n    //根容器查找\n    WebApplicationContext rootContext =\n            WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n    if (this.webApplicationContext != null) {\n        //有可能DispatcherServlet被作为Spring bean初始化，且webApplicationContext已被注入进来\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                if (cwac.getParent() == null) {\n                    cwac.setParent(rootContext);\n                }\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        //是否已经存在于ServletContext中\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        wac = createWebApplicationContext(rootContext);\n    }\n    if (!this.refreshEventReceived) {\n        onRefresh(wac);\n    }\n    if (this.publishContext) {\n        String attrName = getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    }\n    return wac;\n}\n</code></pre>\n<p>下面分部分展开。</p>\n<h3>根容器查找</h3>\n<p>spring-mvc支持Spring容器与MVC容器共存，此时，Spring容器即根容器，mvc容器将根容器视为父容器。</p>\n<p>Spring容器(根容器)以下列形式进行配置(web.xml):</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n</code></pre>\n<p>根据Servlet规范，各组件的加载 顺序如下:</p>\n<p>listener -&gt; filter -&gt; servlet</p>\n<p>WebApplicationContextUtils.getWebApplicationContext:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \".ROOT\";\npublic static WebApplicationContext getWebApplicationContext(ServletContext sc) {\n    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n}\n</code></pre>\n<p>两参数方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n    Object attr = sc.getAttribute(attrName);\n    if (attr == null) {\n        return null;\n    }\n    return (WebApplicationContext) attr;\n}\n</code></pre>\n<p>可以得出结论:</p>\n<p><strong>如果Spring根容器存在，那么它被保存在ServletContext中，其key为<code data-backticks=\"1\">WebApplicationContext.class.getName() + \".ROOT\"</code>。</strong></p>\n<h3>容器创建</h3>\n<p>FrameworkServlet.createWebApplicationContext:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {\n    Class&lt;?&gt; contextClass = getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException();\n    }\n    ConfigurableWebApplicationContext wac =\n            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n    wac.setEnvironment(getEnvironment());\n    wac.setParent(parent);\n    wac.setConfigLocation(getContextConfigLocation());\n    configureAndRefreshWebApplicationContext(wac);\n    return wac;\n}\n</code></pre>\n<p>通过对getContextClass方法的调用，Spring允许我们自定义容器的类型，即我们可以在web.xml中如下配置:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;servlet&gt;\n    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;!-- 配置文件位置 --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:spring-servlet.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;!-- 容器类型 --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextClass&lt;/param-name&gt;\n        &lt;param-value&gt;java.lang.Object&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/servlet&gt;\n</code></pre>\n<p>configureAndRefreshWebApplicationContext核心源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {\n    applyInitializers(wac);\n    wac.refresh();\n}\n</code></pre>\n<h4>ApplicationContextInitializer</h4>\n<p>ApplicationContextInitializer允许我们在Spring(mvc)容器初始化之前干点坏事，可以通过init-param传入:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;init-param&gt;\n    &lt;param-name&gt;contextInitializerClasses&lt;/param-name&gt;\n    &lt;param-value&gt;坏事儿&lt;/param-value&gt;\n&lt;/init-param&gt;\n</code></pre>\n<p>applyInitializers方法正是要触发这些坏事儿。类图:</p>\n<p>![ApplicationContextInitializer类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ApplicationContextInitializer.jpg)</p>\n<h4>配置解析</h4>\n<p>\"配置\"指的便是spring-servlet.xml:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;context:component-scan base-package=\"controller\"/&gt;\n&lt;mvc:annotation-driven/&gt;\n&lt;!-- 启用对静态资源使用默认servlet处理，非REST方式不需要 --&gt;\n&lt;mvc:default-servlet-handler/&gt;\n&lt;!-- 配置视图 --&gt;\n&lt;bean class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt;\n    &lt;!-- viewClass属性必不可少 --&gt;\n    &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt;\n    &lt;property name=\"prefix\" value=\"/WEB-INF/\"&gt;&lt;/property&gt;\n    &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>而解析的入口便在于对refresh方法的调用，此方法位于AbstractApplicationContext，这一点在spring-core时已经见过了，下面我们重点关注不同于spring-core的地方。</p>\n<p>对于spring-mvc来说，其容器默认为XmlWebApplicationContext，部分类图:</p>\n<p>![XmlWebApplicationContext类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/XmlWebApplicationContext.jpg)</p>\n<p>XmlWebApplicationContext通过重写loadBeanDefinitions方法改变了bean加载行为，使其指向spring-servlet.xml。</p>\n<p>spring-servlet.xml中不同于spring-core的地方便在于引入了mvc命名空间，正如spring-core中笔记中所说的那样，<strong>Spring用过jar包/META-INFO中的.handlers文件定义针对不同的命名空间所使用的解析器</strong>。</p>\n<p>mvc命名空间的解析器为MvcNamespaceHandler，部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void init() {\n    registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());\n    registerBeanDefinitionParser(\"default-servlet-handler\", \n                                 new DefaultServletHandlerBeanDefinitionParser());\n    registerBeanDefinitionParser(\"interceptors\", new IanterceptorsBeanDefinitionParser());\n    registerBeanDefinitionParser(\"view-resolvers\", new ViewResolversBeanDefinitionParser());\n}\n</code></pre>\n<p>老样子，按部分展开。</p>\n<h5>注解驱动</h5>\n<p>其parse方法负责向Sprng容器注册一些必要的组件，整理如下图:</p>\n<p>![mvc-annotation]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/mvc-annotation.png)</p>\n<h5>静态资源处理</h5>\n<p>即:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;mvc:default-servlet-handler/&gt;\n</code></pre>\n<p>DefaultServletHandlerBeanDefinitionParser.parse负责向容器注册以下三个组件:</p>\n<ul>\n<li>DefaultServletHttpRequestHandler</li>\n<li>SimpleUrlHandlerMapping</li>\n<li>HttpRequestHandlerAdapter</li>\n</ul>\n<h5>拦截器</h5>\n<p>InterceptorsBeanDefinitionParser.parse方法负责<strong>将每一项<code data-backticks=\"1\">mvc:interceptor</code>配置解析为一个MappedInterceptor bean并注册到容器中</strong>。</p>\n<h5>视图</h5>\n<p>有两种方式向Spring容器注册视图:</p>\n<ul>\n<li>\n<p>以前采用较土的方式:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt;\n  &lt;!-- viewClass属性必不可少 --&gt;\n    &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt;\n    &lt;property name=\"prefix\" value=\"/WEB-INF/\"&gt;&lt;/property&gt;\n    &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n<li>\n<p>通过特定的标签:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;mvc:view-resolvers&gt;\n  &lt;mvc:jsp view-class=\"\" /&gt;\n&lt;/mvc:view-resolvers&gt;\n</code></pre>\n</li>\n</ul>\n<p>从这里可以推测出: 拦截器同样支持第一种方式，Spring在查找时应该会查询某一接口的子类。</p>\n<p>ViewResolversBeanDefinitionParser.parse方法的作用便是将每一个视图解析为ViewResolver并注册到容器。</p>\n<h4>Scope/处理器注册</h4>\n<p>AbstractRefreshableWebApplicationContext.postProcessBeanFactory:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    beanFactory.addBeanPostProcessor(\n        new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, \n        this.servletContext, this.servletConfig);\n}\n</code></pre>\n<p>ServletContextAwareProcessor用以向实现了ServletContextAware的bean注册ServletContext。</p>\n<p>registerWebApplicationScopes用以注册\"request\", \"session\", \"globalSession\", \"application\"四种scope，scope是个什么东西以及如何自定义，在spring-core中已经进行过说明了。</p>\n<p>registerEnvironmentBeans用以将servletContext、servletConfig以及各种启动参数注册到Spring容器中。</p>\n<h2>MVC初始化</h2>\n<p>入口位于DispatcherServlet的initStrategies方法(经由onRefresh调用):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void initStrategies(ApplicationContext context) {\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n}\n</code></pre>\n<p>显然，这里就是spring-mvc的核心了。</p>\n<h3>文件上传支持</h3>\n<p>initMultipartResolver核心源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private void initMultipartResolver(ApplicationContext context) {\n    try {\n        this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);\n    } catch (NoSuchBeanDefinitionException ex) {\n        // Default is no multipart resolver.\n        this.multipartResolver = null;\n    }\n}\n</code></pre>\n<p>MultipartResolver用于开启Spring MVC文件上传功能，其类图:</p>\n<p>![MultipartResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MultipartResolver.jpg)</p>\n<p>也就是说，如果我们要使用文件上传功能，须在容器中注册一个MultipartResolver bean。当然，默认是没有的。</p>\n<h3>地区解析器</h3>\n<p>LocaleResolver接口定义了Spring MVC如何获取客户端(浏览器)的地区，initLocaleResolver方法在容器中寻找此bean，如果没有，注册AcceptHeaderLocaleResolver，即根据request的请求头<strong>Accept-Language</strong>获取地区。</p>\n<p>spring-mvc采用了属性文件的方式配置默认策略(即bean)，此文件位于spring-mvc的jar包的org.springframework.web.servlet下。</p>\n<h3>主题解析器</h3>\n<p>ThemeResolver接口配合Spring标签库使用可以通过动态决定使用的css以及图片的方式达到换肤的效果，其类图:</p>\n<p>![ThemeResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ThemeResolver.jpg)</p>\n<p>如果容器中不存在叫做themeResolver的bean，initThemeResolver方法将向容器中注册FixedThemeResolver，此bean只能提供一套默认的主题，名为theme。</p>\n<h3>HandlerMapping检查</h3>\n<p>initHandlerMappings方法用于确保容器中<strong>至少含有一个HandlerMapping对象</strong>。从前面配置解析-注解驱动一节中可以看出，注解驱动导致已经注册了两个此对象。</p>\n<p>如果没有开启注解驱动，那么将会使用默认的HandlerMapping，相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (this.handlerMappings == null) {\n    this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"No HandlerMappings found in servlet \'\" + getServletName() + \"\': using default\");\n    }\n}\n</code></pre>\n<p>前面提到了，默认的策略由DispatcherServlet.properties决定，<strong>目前是BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping</strong>。</p>\n<h3>HandlerAdapter检查</h3>\n<p>套路和上面完全一样，默认使用HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter。</p>\n<h3>HandlerExceptionResolver检查</h3>\n<p>套路和上面完全一样，默认使用AnnotationMethodHandlerExceptionResolver、ResponseStatusExceptionResolver、DefaultHandlerExceptionResolver。</p>\n<h3>RequestToViewNameTranslator</h3>\n<p>initRequestToViewNameTranslator方法回向容器中注册一个DefaultRequestToViewNameTranslator对象，此接口用以完成从HttpServletRequest到视图名的解析，其使用场景是<strong>给定的URL无法匹配任何控制器时</strong>。</p>\n<p>DefaultRequestToViewNameTranslator的转换例子:</p>\n<p>http://localhost:8080/gamecast/display.html -&gt; display(视图)</p>\n<p>其类图:</p>\n<p>![RequestToViewNameTranslator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RequestToViewNameTranslator.jpg)</p>\n<h3>ViewResolver检查</h3>\n<p>熟悉的套路，默认使用InternalResourceViewResolver。</p>\n<h3>FlashMapManager</h3>\n<p>initFlashMapManager方法会向容器注册SessionFlashMapManager对象，类图:</p>\n<p>![FlashMapManager类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/FlashMapManager.jpg)</p>\n<p>此接口和FlashMap搭配使用，用于在<strong>请求重定向时保存/传递参数</strong>。</p>\n<h2>HandlerMapping初始化</h2>\n<p>此接口用以根据请求的URL寻找合适的处理器。从前面配置解析一节可以看出，我们的容器中有三个HandlerMapping实现，下面以RequestMappingHandlerMapping位代表进行说明。</p>\n<h3>RequestMappingHandlerMapping</h3>\n<p>此实现根据@Controller和@RequestMapping注解完成解析。类图(忽略部分接口):</p>\n<p>![RequestMappingHandlerMapping类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RequestMappingHandlerMapping.jpg)</p>\n<p>初始化的入口位于AbstractHandlerMethodMapping的afterPropertiesSet方法和AbstractHandlerMapping的initApplicationContext方法，afterPropertiesSet调用了initHandlerMethods:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void initHandlerMethods() {\n    //获取容器中所有的bean\n    String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?\n            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class)             :getApplicationContext().getBeanNamesForType(Object.class));\n    for (String beanName : beanNames) {\n        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n            Class&lt;?&gt; beanType = null;\n            beanType = getApplicationContext().getType(beanName);\n             //isHandler方法的原理:\n             //判断类上有没有@Controller注解或者是@RequestMapping注解\n            if (beanType != null &amp;&amp; isHandler(beanType)) {\n                detectHandlerMethods(beanName);\n            }\n        }\n    }\n    //空实现\n    handlerMethodsInitialized(getHandlerMethods());\n}\n</code></pre>\n<p>detectHandlerMethods方法将反射遍历类中所有的public方法，如果方法上含有@RequestMapping注解，那么将方法上的路径与类上的基础路径(如果有)进行合并，之后将映射(匹配关系)注册到MappingRegistry中。</p>\n<p>注意，<strong>类上的@RequestMapping注解只能作为基路径存在，也就是说，如果类里面没有任何的方法级@RequestMapping注解，那么类上的注解是没有意义的</strong>。这一点可以从实验和源码上得到证实。</p>\n<p>下面我们关注一下映射关系是如何保存(注册)的。</p>\n<p>内部类AbstractHandlerMethodMapping.MappingRegistry是映射的载体，类图:</p>\n<p>![MappingRegistry类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MappingRegistry.jpg)</p>\n<p>其register方法简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void register(T mapping, Object handler, Method method) {\n    //包装bean和方法\n    HandlerMethod handlerMethod = createHandlerMethod(handler, method);\n    this.mappingLookup.put(mapping, handlerMethod);\n    List&lt;String&gt; directUrls = getDirectUrls(mapping);\n    for (String url : directUrls) {\n        this.urlLookup.add(url, mapping);\n    }\n    String name = null;\n    if (getNamingStrategy() != null) {\n        name = getNamingStrategy().getName(handlerMethod, mapping);\n        addMappingName(name, handlerMethod);\n    }\n    CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n    if (corsConfig != null) {\n        this.corsLookup.put(handlerMethod, corsConfig);\n    }\n    this.registry.put(mapping, new MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name));\n}\n</code></pre>\n<p>mapping其实是一个RequestMappingInfo对象，可以将其看做是**@RequestMapping注解各种属性的一个封装**。最终由RequestMappingInfo.createRequestMappingInfo方法创建，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected RequestMappingInfo createRequestMappingInfo(\n        RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition) {\n    return RequestMappingInfo\n            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n            .methods(requestMapping.method())\n            .params(requestMapping.params())\n            .headers(requestMapping.headers())\n            .consumes(requestMapping.consumes())\n            .produces(requestMapping.produces())\n            .mappingName(requestMapping.name())\n            .customCondition(customCondition)\n            .options(this.config)\n            .build();\n}\n</code></pre>\n<p>这就很明显了，具体每种属性什么意义可以参考@RequestMapping源码。</p>\n<p>register方法中urlLookup其实就是将paths属性中的每个path都与处理器做映射。</p>\n<p>getNamingStrategy方法得到的是一个HandlerMethodMappingNamingStrategy接口的实例，此接口用以根据HandlerMethod得到一个名字，类图:</p>\n<p>![HandlerMethodMappingNamingStrategy类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodMappingNamingStrategy.jpg)</p>\n<p>比如对于我们的控制器,SimpleController.echo方法，最终得到的名字将是SC#echo。</p>\n<h4>跨域请求</h4>\n<p>spring-mvc自4.2开启加入了跨域请求Cors的支持，主要有两种配置方式:</p>\n<ul>\n<li>\n<p>xml:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;mvc:cors&gt;\n  &lt;mvc:mapping path=\"\"/&gt;\n&lt;/mvc:cors&gt;\n</code></pre>\n</li>\n<li>\n<p>@CrossOrigin注解。</p>\n</li>\n</ul>\n<p>Cors的原理可以参考:</p>\n<p><a href=\"http://www.cnblogs.com/dojo-lzz/p/4265637.html\">探讨跨域请求资源的几种方式</a></p>\n<p>而initCorsConfiguration方法的作用便是将@CrossOrigin注解的各种属性封装在CorsConfiguration中。</p>\n<h4>拦截器初始化</h4>\n<p>AbstractHandlerMapping.initApplicationContext:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void initApplicationContext() throws BeansException {\n    detectMappedInterceptors(this.adaptedInterceptors);\n}\n</code></pre>\n<p>作用就是从容器中获取所有MappedInterceptor bean并放到adaptedInterceptors中，前面提到过了，我们使用mvc:interceptor定义的拦截器其实就是MappedInterceptor对象。类图:</p>\n<p>![MappedInterceptor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/MappedInterceptor.jpg)</p>\n<h2>HandlerAdapter初始化</h2>\n<p>同样，我们以RequestMappingHandlerAdapter为例进行说明，类图:</p>\n<p>![RequestMappingHandlerAdapter类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/RequestMappingHandlerAdapter.jpg)</p>\n<p>显然，入口在afterPropertiesSet方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void afterPropertiesSet() {\n    // Do this first, it may add ResponseBody advice beans\n    initControllerAdviceCache();\n    if (this.argumentResolvers == null) {\n        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite()\n            .addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite()\n            .addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite()\n            .addHandlers(handlers);\n    }\n}\n</code></pre>\n<h3>@ControllerAdvice</h3>\n<p>initControllerAdviceCache方法用以解析并存储标注了@ControllerAdvice的bean，这东西是干什么的参考：</p>\n<p><a href=\"http://jinnianshilongnian.iteye.com/blog/1866350\">Spring3.2新注解@ControllerAdvice</a></p>\n<h3>参数解析器</h3>\n<p>HandlerMethodArgumentResolver即参数解析器，负责从request中解析、得到Controller方法所需的参数。afterPropertiesSet方法设置了一组默认的解析器。具体是哪些参考getDefaultArgumentResolvers方法。类图:</p>\n<p>![HandlerMethodArgumentResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodArgumentResolver.jpg)</p>\n<h3>@InitBinder支持</h3>\n<p>此注解定义的其实是自定义类型转换器。使用方法参考:</p>\n<p><a href=\"http://blog.csdn.net/songzaiblog/article/details/49757253\">springMVC @initBinder 使用</a></p>\n<p>getDefaultInitBinderArgumentResolvers返回了一组默认使用的转换器，不过其实这里的转换器和上面的参数解析器其实是一个类型的，这里留个坑。</p>\n<h3>返回结果解析器</h3>\n<p>HandlerMethodReturnValueHandler接口用以处理方法调用(Controller方法)的返回值，类图:</p>\n<p>![HandlerMethodReturnValueHandler类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodReturnValueHandler.jpg)</p>\n<p>getDefaultReturnValueHandlers方法便返回了一坨这东西。</p>\n<h1>请求响应</h1>\n<p>我们先来看一下入口在哪。众所周知，Servlet标准定义了所有请求先由service方法处理，如果是get或post方法，那么再交由doGet或是doPost方法处理。</p>\n<p>FrameworkServlet覆盖了service方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void service(HttpServletRequest request, HttpServletResponse response) {\n    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    if (HttpMethod.PATCH == httpMethod || httpMethod == null) {\n        processRequest(request, response);\n    } else {\n        super.service(request, response);\n    }\n}\n</code></pre>\n<p>Spring要覆盖此方法的目的在于拦截PATCH请求，PATCH请求与PUT类似，不同在于PATCH是局部更新，而后者是全部更新。可以参考:</p>\n<p><a href=\"https://segmentfault.com/q/1010000005685904\">PATCH和PUT方法的区别？</a></p>\n<p>FrameworkServlet同样也覆盖了doGet和doPost方法，两者只是调用processRequest方法。</p>\n<h2>请求上下文</h2>\n<p>Spring MVC会在请求分发之前进行上下文的准备工作，含两部分:</p>\n<ol>\n<li>将地区(Locale)和请求属性以ThreadLocal的方法与当前线程进行关联，分别可以通过LocaleContextHolder和RequestContextHolder进行获取。</li>\n<li>将WebApplicationContext、FlashMap等组件放入到Request属性中。</li>\n</ol>\n<h2>请求分发</h2>\n<p>DispatcherServlet.doDispatch简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {\n    HandlerExecutionChain mappedHandler = getHandler(processedRequest);\n    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n    applyDefaultViewName(processedRequest, mv);\n    mappedHandler.applyPostHandle(processedRequest, response, mv);\n    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n}\n</code></pre>\n<h3>处理器查找</h3>\n<p>即为请求寻找合适的Controller的过程。DispatcherServlet.getHandler:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected HandlerExecutionChain getHandler(HttpServletRequest request) {\n    for (HandlerMapping hm : this.handlerMappings) {\n        HandlerExecutionChain handler = hm.getHandler(request);\n        if (handler != null) {\n            return handler;\n        }\n    }\n    return null;\n}\n</code></pre>\n<p>从这里可以看出，寻找处理器实际上委托给HandlerMapping实现，寻找的过程便是遍历所有的HandlerMapping进行查找，<strong>一旦找到，那么不再继续进行遍历</strong>。也就是说HandlerMapping之间有优先级的概念，而根据AnnotationDrivenBeanDefinitionParser的注释，RequestMappingHandlerMapping其实有最高的优先级。</p>\n<p>AbstractHandlerMapping.getHandler:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    Object handler = getHandlerInternal(request);\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n    //判断请求头中是否有ORIGIN字段\n    if (CorsUtils.isCorsRequest(request)) {\n        CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);\n        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);\n        CorsConfiguration config = (globalConfig != null ? \n            globalConfig.combine(handlerConfig) : handlerConfig);\n        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);\n    }\n    return executionChain;\n}\n</code></pre>\n<p>getHandlerInternal方法便是根据url进行查找的过程，可以参见MVC初始化-HandlerMapping初始化一节。下面重点是执行链的生成。</p>\n<p>getHandlerExecutionChain方法的原理就是从adaptedInterceptors中获得所有可以适配当前请求URL的MappedInterceptor并将其添加到HandlerExecutionChain的拦截器列表中。拦截器的顺序其实就是我们定义/注册的顺序。</p>\n<p>从getCorsHandlerExecutionChain的源码中可以看出，对于跨域请求其实是向调用链插入了一个CorsInterceptor。</p>\n<h3>适配器查找</h3>\n<p>DispatcherServlet.getHandlerAdapter:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected HandlerAdapter getHandlerAdapter(Object handler) {\n    for (HandlerAdapter ha : this.handlerAdapters) {\n        if (ha.supports(handler)) {\n            return ha;\n        }\n    }\n}\n</code></pre>\n<p>从前面配置解析-注解驱动可以看出，第一个适配器是RequestMappingHandlerAdapter，而其support方法直接返回true，这就导致了使用的适配器总是这一个。</p>\n<h2>请求处理</h2>\n<p>RequestMappingHandlerAdapter.handleInternal:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n        HttpServletResponse response, HandlerMethod handlerMethod){\n    ModelAndView mav;\n    // Execute invokeHandlerMethod in synchronized block if required.\n    if (this.synchronizeOnSession) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            synchronized (mutex) {\n                mav = invokeHandlerMethod(request, response, handlerMethod);\n            }\n        } else {\n            // No HttpSession available -&gt; no mutex necessary\n            mav = invokeHandlerMethod(request, response, handlerMethod);\n        }\n    } else {\n        // No synchronization on session demanded at all...\n        mav = invokeHandlerMethod(request, response, handlerMethod);\n    }\n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n        }\n        else {\n            prepareResponse(response);\n        }\n    }\n    return mav;\n}\n</code></pre>\n<h3>Session同步</h3>\n<p>可以看出，如果开启了synchronizeOnSession，那么<strong>同一个session的请求将会串行执行</strong>，这一选项默认是关闭的，当然我们可以通过注入的方式进行改变。</p>\n<h3>参数解析</h3>\n<h4>策略模式</h4>\n<p>正如前面HandlerAdapter初始化-参数解析器一节提到的，HandlerAdapter内部含有一组解析器负责对各类型的参数进行解析。下面我们就常用的自定义参数和Model为例进行说明。</p>\n<h4>自定义参数</h4>\n<p>解析由RequestParamMethodArgumentResolver完成。</p>\n<p>supportsParameter方法决定了一个解析器可以解析的参数类型，该解析器支持@RequestParam标准的参数或是<strong>简单类型</strong>的参数，具体参见其注释。为什么此解析器可以同时解析@RequestParam注解和普通参数呢?玄机在于RequestMappingHandlerAdapter方法在初始化参数解析器时其实初始化了<strong>两个RequestMappingHandlerAdapter对象</strong>，getDefaultArgumentResolvers方法相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() {\n    resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));\n    // Catch-all\n    resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));\n}\n</code></pre>\n<p>useDefaultResolution参数用于启动对常规类型参数的解析，这里的常规类型指的又是什么呢?</p>\n<p>实际上由BeanUtils.isSimpleProperty方法决定:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static boolean isSimpleProperty(Class&lt;?&gt; clazz) {\n    Assert.notNull(clazz, \"Class must not be null\");\n    return isSimpleValueType(clazz) || (clazz.isArray() &amp;&amp; isSimpleValueType(clazz.getComponentType()));\n}\n\npublic static boolean isSimpleValueType(Class&lt;?&gt; clazz) {\n    return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||\n            CharSequence.class.isAssignableFrom(clazz) ||\n            Number.class.isAssignableFrom(clazz) ||\n            Date.class.isAssignableFrom(clazz) ||\n            URI.class == clazz || URL.class == clazz ||\n            Locale.class == clazz || Class.class == clazz);\n}\n</code></pre>\n<p>忽略复杂的调用关系，最核心的实现位于resolveName方法，部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) {\n    if (arg == null) {\n        String[] paramValues = request.getParameterValues(name);\n        if (paramValues != null) {\n            arg = (paramValues.length == 1 ? paramValues[0] : paramValues);\n        }\n    }\n    return arg;\n}\n</code></pre>\n<p>name就是方法的参数名，可以看出，参数解析<strong>就是根据参数名去request查找对应属性的过程</strong>，在这里参数类型并没有起什么作用。</p>\n<h6>参数名是从哪里来的</h6>\n<p>方法名获取的入口位于RequestParamMethodArgumentResolver的resolveArgument方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n}\n</code></pre>\n<p>getNamedValueInfo方法最终完成对MethodParameter的getParameterName方法的调用:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public String getParameterName() {\n    ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;\n    if (discoverer != null) {\n        String[] parameterNames = (this.method != null ?\n                discoverer.getParameterNames(this.method) : discoverer.getParameterNames(this.constructor));\n        if (parameterNames != null) {\n            this.parameterName = parameterNames[this.parameterIndex];\n        }\n        this.parameterNameDiscoverer = null;\n    }\n    return this.parameterName;\n}\n</code></pre>\n<p>显然，参数名的获取由接口ParameterNameDiscoverer完成:</p>\n<p>![ParameterNameDiscoverer]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ParameterNameDiscoverer.jpg)</p>\n<p>默认采用DefaultParameterNameDiscoverer，但此类其实相当于StandardReflectionParameterNameDiscoverer和LocalVariableTableParameterNameDiscoverer的组合，且前者先于后者进行解析。</p>\n<p>StandardReflectionParameterNameDiscoverer.getParameterNames:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic String[] getParameterNames(Method method) {\n    Parameter[] parameters = method.getParameters();\n    String[] parameterNames = new String[parameters.length];\n    for (int i = 0; i &lt; parameters.length; i++) {\n        Parameter param = parameters[i];\n        if (!param.isNamePresent()) {\n            return null;\n        }\n        parameterNames[i] = param.getName();\n    }\n    return parameterNames;\n}\n</code></pre>\n<p>此类被注解UsesJava8标注，其原理就是利用的jdk8的-parameters编译参数，只有在加上此选项的情况下才能用反射的方法获得真实的参数名，所以一般情况下StandardReflectionParameterNameDiscoverer是无法成功获取参数名的。</p>\n<p>LocalVariableTableParameterNameDiscoverer利用了ASM直接访问class文件中的本地变量表来得到变量名，下面是使用<code data-backticks=\"1\">javap -verbose</code>命令得到的本地变量表示例:</p>\n<p>![本地变量表]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/local_variable_tables.PNG)</p>\n<p>但是默认情况下javac compiler是不生成本地变量表这种调试信息的，需要加<code data-backticks=\"1\">-g</code>参数才可以，那为什么在我们的测试Controller中却可以获得呢，玄机就在于idea的下列设置:</p>\n<p>![idea编译设置]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/idea_debug_info.PNG)</p>\n<p>取消这项设置的勾选再次运行程序便出问题了:</p>\n<p>![调试信息错误]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/debug_info_error.PNG)</p>\n<h4>Model</h4>\n<p>解析由ModelMethodProcessor完成。</p>\n<p>supportsParameter方法很简单:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean supportsParameter(MethodParameter parameter) {\n    return Model.class.isAssignableFrom(parameter.getParameterType());\n}\n</code></pre>\n<p>很直白了。</p>\n<p>resolveArgument：</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    return mavContainer.getModel();\n}\n</code></pre>\n<p>忽略各种调用关系，<strong>Model其实是一个BindingAwareModelMap对象，且每次请求(需要注入Model的前提下)都有一个新的该对象生成</strong>。类图:</p>\n<p>![BindingAwareModelMap类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BindingAwareModelMap.jpg)</p>\n<h4>总结</h4>\n<ul>\n<li>我们可以通过实现HandlerMethodArgumentResolver接口并将其注册容器的方式实现自定义参数类型的解析。</li>\n<li>为了防止出现参数名获取不到的问题，应优先使用@RequestParam注解直接声明需要的参数名称。</li>\n</ul>\n<h3>返回值解析</h3>\n<p>套路和上面是一样的，通常情况，我们返回的其实是view名，负责处理的是ViewNameMethodReturnValueHandler，</p>\n<p>supportsReturnType方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean supportsReturnType(MethodParameter returnType) {\n    Class&lt;?&gt; paramType = returnType.getParameterType();\n    return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));\n}\n</code></pre>\n<p>handleReturnValue:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void handleReturnValue(Object returnValue, MethodParameter returnType,\n        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n    if (returnValue instanceof CharSequence) {\n        String viewName = returnValue.toString();\n        mavContainer.setViewName(viewName);\n         // 判断的依据: 是否以redirect:开头\n        if (isRedirectViewName(viewName)) {\n            mavContainer.setRedirectModelScenario(true);\n        }\n    }\n}\n</code></pre>\n<p>可见这里并没有进行实际的处理，只是解析得到了最终的视图名称。</p>\n<h3>视图渲染</h3>\n<p>由DispatcherServlet的processDispatchResult方法完成，源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) {\n    boolean errorView = false;\n    if (exception != null) {\n         //一般不会到这个分支\n        if (exception instanceof ModelAndViewDefiningException) {\n            mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n        } else {\n            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n            mv = processHandlerException(request, response, handler, exception);\n            errorView = (mv != null);\n        }\n    }\n    // Did the handler return a view to render?\n    if (mv != null &amp;&amp; !mv.wasCleared()) {\n        render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    }\n}\n</code></pre>\n<p>可以看出，处理<strong>根据是否抛出异常分为了两种情况</strong>。</p>\n<p>如果抛出了异常，那么processHandlerException方法将会遍历所有的HandlerExceptionResolver实例，默认有哪些参考MVC初始化-HandlerExceptionResolver检查一节。默认的处理器用于改变响应状态码、调用标注了@ExceptionHandler的bean进行处理，如果没有@ExceptionHandler的bean或是不能处理此类异常，那么就会导致ModelAndView始终为null，最终Spring MVC将异常向上抛给Tomcat，然后Tomcat就会把堆栈打印出来。</p>\n<p>如果我们想将其定向到指定的错误页面，可以这样配置:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;\n    &lt;property name=\"defaultErrorView\" value=\"error\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>此处理器会返回一个非空的ModelAndView。</p>\n<h4>ModelAndView</h4>\n<p>回过头来看一下这到底是个什么东西。类图:</p>\n<p>![ModelAndView类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ModelAndView.jpg)</p>\n<p>很直白。</p>\n<p>怎么生成的。RequestMappingHandlerAdapter.getModelAndView相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">ModelMap model = mavContainer.getModel();\nModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());\n</code></pre>\n<h4>渲染</h4>\n<p>DispatcherServlet.render简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) {\n    Locale locale = this.localeResolver.resolveLocale(request);\n    response.setLocale(locale);\n    View view;\n    //判断依据: 是否是String类型\n    if (mv.isReference()) {\n        // We need to resolve the view name.\n        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);\n    } else {\n        // No need to lookup: the ModelAndView object contains the actual View object.\n        view = mv.getView();\n    }\n    if (mv.getStatus() != null) {\n        response.setStatus(mv.getStatus().value());\n    }\n    view.render(mv.getModelInternal(), request, response);\n}\n</code></pre>\n<p>resolveViewName方法将会遍历所有的ViewResolver bean，只要有一个解析的结果(View)不为空，即停止遍历。根据MVC初始化-ViewResolver检查一节和我们的配置文件可知，容器中有两个ViewResolver ，分别是: InternalResourceViewResolver和UrlBasedViewResolver。</p>\n<h5>ViewResolver</h5>\n<p>类图(忽略实现类):</p>\n<p>![ViewResolver类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ViewResolver.jpg)</p>\n<p>resolveViewName方法的源码不再贴出，其实只做了一件事: 用反射创建并初始化我们指定的View，根据我们的配置，就是JstlView。</p>\n<h5>View</h5>\n<p>类图:</p>\n<p>![JstlView类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/JstlView.jpg)</p>\n<p>渲染的核心逻辑位于InternalResourceView.renderMergedOutputModel，简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void renderMergedOutputModel(\n        Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) {\n    // 将Model中的属性设置的request中\n    exposeModelAsRequestAttributes(model, request);\n    // 获取资源(jsp)路径\n    String dispatcherPath = prepareForRendering(request, response);\n    // Obtain a RequestDispatcher for the target resource (typically a JSP).\n    RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);\n    // If already included or response already committed, perform include, else forward.\n    if (useInclude(request, response)) {\n        response.setContentType(getContentType());\n        rd.include(request, response);\n    } else {\n        // Note: The forwarded resource is supposed to determine the content type itself.\n        rd.forward(request, response);\n    }\n}\n</code></pre>\n<p>可以看出，对jsp来说，所谓的渲染其实就是<strong>将Model中的属性设置到Request，再利用原生Servlet RequestDispatcher API进行转发的过程</strong>。</p>\n<h1>拾遗</h1>\n<h2>@ResponseBody</h2>\n<p>通常我们可以在Controller或方法上标注@ResponseBody注解以表示需要将对象转为JSON并返回给前端，那么Spring MVC是如何自动完成这一过程的呢?</p>\n<p>从前面初始化-容器初始化-容器创建-配置解析一节可以看出，Spring MVC采用org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser进行配置的解析，核心的parse方法中完成了对HttpMessageConverter的初始化。</p>\n<h3>HttpMessageConverter</h3>\n<p>Spring的HttpMessageConverter接口负责HTTP请求-Java对象与Java对象-响应之间的转换。我们以Spring默认使用的Jackson转换器为例，类图:</p>\n<p>![HttpMessageConverter]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HttpMessageConverter.jpg)</p>\n<p>HttpMessageConverter实现的初始化由AnnotationDrivenBeanDefinitionParser的getMessageConverters方法完成，HttpMessageConverter的来源分为自定义和默认。</p>\n<p>示例配置:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;mvc:annotation-driven&gt;\n  &lt;mvc:message-converters register-defaults=\"true\"&gt;\n    &lt;bean class=\"test.Converter\" /&gt;\n  &lt;/mvc:message-converters&gt;\n&lt;/mvc:annotation-driven&gt;\n</code></pre>\n<h4>自定义</h4>\n<p>Spring允许我们通过XML配置文件的message-converters元素来进行自定义。</p>\n<h4>默认</h4>\n<p>当<strong>检测到没有配置message-converters元素或者register-defaults=\"true\"时Spring便会注册默认转换器</strong>。这其中便包括MappingJacksonHttpMessageConverter，相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">else if (jacksonPresent) {\n    messageConverters.add(createConverterDefinition(\n        org.springframework.http.converter.json.MappingJacksonHttpMessageConverter.class, source));\n}\n</code></pre>\n<p>jacksonPresent声明:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static final boolean jacksonPresent =\n    ClassUtils.isPresent(\"org.codehaus.jackson.map.ObjectMapper\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader()) &amp;&amp;\n    ClassUtils.isPresent(\"org.codehaus.jackson.JsonGenerator\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader());\n</code></pre>\n<h3>转换</h3>\n<p>入口位于ServletInvocableHandlerMethod的invokeAndHandle方法对于响应的处理:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n</code></pre>\n<p>returnValueHandlers其实就是RequestMappingHandlerAdapter内部的returnValueHandlers，后者由RequestMappingHandlerAdapter的afterPropertiesSet方法初始化，关键在于:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.contentNegotiationManager));\n</code></pre>\n<p>对象到JSON的转换正是由RequestResponseBodyMethodProcessor完成，ServletInvocableHandlerMethod通过supportsReturnType方法决定HandlerMethodReturnValueHandler是否可以处理当前返回类型或返回方法，RequestResponseBodyMethodProcessor的实现:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean supportsReturnType(MethodParameter returnType) {\n    return ((AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != null) ||\n        (returnType.getMethodAnnotation(ResponseBody.class) != null));\n}\n</code></pre>\n<p>核心的handleReturnValue方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void handleReturnValue(Object returnValue, MethodParameter returnType,\n    ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n    mavContainer.setRequestHandled(true);\n    if (returnValue != null) {\n        writeWithMessageConverters(returnValue, returnType, webRequest);\n    }\n}\n</code></pre>\n<p>这里其实是通过HttpMessageConverter的canRead或canWrite方法来判断给定的转换器是否合适，canWrite方法实现:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType) {\n    return (this.objectMapper.canSerialize(clazz) &amp;&amp; canWrite(mediaType));\n}\n</code></pre>\n<p>这里剩下的便是Jackson的事情了，注意MappingJacksonHttpMessageConverter中的objectMapper被所有的线程所共享，因为其是线程安全的，但是这样是否有性能问题?</p>\n<h2>参数解析 &amp; 结果转换</h2>\n<p>Spring MVC中参数到各种类型的转换由HandlerMethodArgumentResolver接口完成，而Controller返回值到真正的响应的转换由HandlerMethodReturnValueHandler接口完成。两者分别负责Spring MVC中数据的输入与输出，可用下图表示:</p>\n<p>![Spring MVC输入输出转换]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/mvc_input_output.PNG)</p>\n<p>HandlerMethodArgumentResolver接口及其主要实现类如下图:</p>\n<p>![HandlerMethodArgumentResolver]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodArgumentResolver_all.jpg)</p>\n<p>HandlerMethodReturnValueHandler接口以及主要实现类如下:</p>\n<p>![HandlerMethodReturnValueHandler]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/HandlerMethodReturnValueHandler_all.jpg)</p>\n<p>其实有很多类同时实现了两个接口，比如RequestResponseBodyMethodProcessor，这样的类一般以Processor结尾。</p>\n<p>两种转换器的初始化由HandlerAdapter完成，这也很好的体现了HandlerAdapter接口的功能。以喜闻乐见的RequestMappingHandlerAdapter为例，其初始化的HandlerMethodReturnValueHandler列表如下:</p>\n<ul>\n<li>ModelAndViewMethodReturnValueHandler</li>\n<li>ModelMethodProcessor</li>\n<li>HttpEntityMethodProcessor</li>\n<li>HttpHeadersReturnValueHandler</li>\n<li>CallableMethodReturnValueHandler</li>\n<li>DeferredResultMethodReturnValueHandler</li>\n<li>AsyncTaskMethodReturnValueHandler</li>\n<li>ListenableFutureReturnValueHandler</li>\n<li>ModelAttributeMethodProcessor</li>\n<li>RequestResponseBodyMethodProcessor</li>\n<li>ViewNameMethodReturnValueHandler</li>\n<li>MapMethodProcessor</li>\n<li>ModelAndViewResolverMethodReturnValueHandler</li>\n</ul>\n<p>从中也可以推测出我们可以把哪些类型的值(对象)直接\"丢给\"Spring。</p>\n<p>对于HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler来说，HttpMessageConverter像是两者手中用来实现功能的武器。</p>\n<h2>\"纯\"对象参数接收</h2>\n<p>假设有如下这样的Controller:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@RequestMapping(\"/echoAgain\")\npublic String echo(SimpleModel simpleModel, Model model) {\n    model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\");\n    return \"echo\";\n}\n</code></pre>\n<p>经过测试可以发现，SimpleModel参数既可以接收get请求，也可以接收post请求。那么在这种情况下请求参数是被哪个参数解析器解析的呢，debug发现: ServletModelAttributeMethodProcessor：</p>\n<p>![ServletModelAttributeMethodProcessor]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ServletModelAttributeMethodProcessor.jpg)</p>\n<p>核心的supportsParameter方法由父类ModelAttributeMethodProcessor实现:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean supportsParameter(MethodParameter parameter) {\n    return (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n        (this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n}\n</code></pre>\n<p>可以看出，这里支持带有ModelAttribute注解或者是非基本类型的参数解析，同时annotationNotRequired必须设为false，即ModelAttribute注解不必存在，这里是在ServletModelAttributeMethodProcessor的构造器中进行控制的，<br>\nRequestMappingHandlerAdapter.getDefaultArgumentResolvers部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">resolvers.add(new ServletModelAttributeMethodProcessor(false));\n</code></pre>\n<p>此类的作用是对@ModelAttribute注解标注的参数进行解析，假设我们将Controller方法改写成:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@RequestMapping(\"/echoAgain\")\npublic String echo(@ModelAttribute SimpleModel simpleModel, Model model) {\n    model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\");\n    System.out.println(model.asMap().get(\"simpleModel\"));\n    return \"echo\";\n}\n</code></pre>\n<p>首先，Spring会首先反射生成一个SimpleModel对象，之后将从request中获取的参数尝试设置到SimpleModel对象中去，最后将此对象放置到Model中(本质上就是一个Map)，key就是simpleModel.下面我们来看一下具体的解析过程，整个过程可以分为<br>\n以下三部分:</p>\n<h3>参数对象构造</h3>\n<p>因为SimpleModel是一个对象类型，所以要想将参数注入到其中，第一步必然是先创建一个对象，创建的入口位于ModelAttributeMethodProcessor的resolveArgument方法，相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">//name在这里便是simpleModel\nString name = ModelFactory.getNameForParameter(parameter);\nObject attribute = (mavContainer.containsAttribute(name) ? mavContainer.getModel().get(name) :\n                    createAttribute(name, parameter, binderFactory, webRequest));//反射实例化\n</code></pre>\n<p>ModelAndViewContainer是个什么东西呢，从名字就可以看出就，它是Spring MVC里两个重要概念Model和View的组合体，用来记录在请求响应过程中Model和View的变化，在这里可以简单理解为去Model中检查有没有叫simpleModel的属性已经存在。</p>\n<h3>参数绑定</h3>\n<p>这里使用到了DataBinder接口，按照注释的说明，此接口用以<strong>向执行的对象中设置属性值</strong>，就是这么简单，其继承体系如下图:</p>\n<p>![DataBinder]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DataBinder.jpg)</p>\n<p>WebDataBinderFactory接口用以创建WebDataBinder对象，其继承体系如下图:</p>\n<p>![WebDataBinderFactory]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/WebDataBinderFactory.jpg)</p>\n<p>默认使用的是ServletRequestDataBinderFactory，创建了一个ExtendedServletRequestDataBinder对象:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected ServletRequestDataBinder createBinderInstance(Object target, String objectName, NativeWebRequest request) {\n    return new ExtendedServletRequestDataBinder(target, objectName);\n}\n</code></pre>\n<p>参数绑定的入口位于ModelAttributeMethodProcessor.resolveArgument方法，相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (!mavContainer.isBindingDisabled(name)) {\n    bindRequestParameters(binder, webRequest);\n}\n</code></pre>\n<p>接下来由ServletRequestDataBinder的bind方法完成，核心源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void bind(ServletRequest request) {\n    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);\n    doBind(mpvs);\n}\n</code></pre>\n<p>在ServletRequestParameterPropertyValues构造器中获取了Request中所有的属性对。doBind方法便是调用前面初始化的目标对象的setter方法进行参数设置的过程，不再展开。</p>\n<h3>参数校验</h3>\n<p>将我们的Controller方法改写为下面这种形式便可以启动Spring MVC的参数校验:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@RequestMapping(\"/echoAgain\")\npublic String echo(@Validated SimpleModel simpleModel, Model model) {\n    model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\");\n    System.out.println(model.asMap().get(\"simpleModel\"));\n    return \"echo\";\n}\n</code></pre>\n<p>在这里@Validated注解可以用@Valid(javax)替换，前者是Spring对java校验标准的扩充，增加了校验组的支持。<br>\n为什么参数校验要放到参数绑定后面进行说明呢，因为**@Validated和@valid注解不会影响Spring MVC参数解析的行为，被这两个注解标注的对象仍是由参数绑定一节提到的解析器进行解析。**</p>\n<p>当参数校验绑定之后，Spring MVC会尝试对参数进行校验，如果我们设置了校验注解。ModelAttributeMethodProcessor.resolveArgument方法相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">validateIfApplicable(binder, parameter);\n\nprotected void validateIfApplicable(WebDataBinder binder, MethodParameter methodParam) {\n    Annotation[] annotations = methodParam.getParameterAnnotations();\n    for (Annotation ann : annotations) {\n        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n            binder.validate(validationHints);\n            break;\n        }\n    }\n}\n</code></pre>\n<p>DataBinder.validate:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void validate(Object... validationHints) {\n    for (Validator validator : getValidators()) {\n        if (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator instanceof SmartValidator) {\n            ((SmartValidator) validator).validate(getTarget(), getBindingResult(), validationHints);\n        } else if (validator != null) {\n            validator.validate(getTarget(), getBindingResult());\n        }\n    }\n}\n</code></pre>\n<p>可见，具体的校验交给了<code data-backticks=\"1\">org.springframework.validation.Validator</code>实现，类图:</p>\n<p>![Validator]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Validator.png)</p>\n<p>getValidators方法获取的实际上是DataBinder内部的validators字段:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private final List&lt;Validator&gt; validators = new ArrayList&lt;Validator&gt;();\n</code></pre>\n<p>根据这里的校验器的来源可以分为以下两种情况。</p>\n<h4>JSR校验</h4>\n<p>需要引入hibernate-validator到classpath中，回顾最前面配置解析部分，配置:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;mvc:annotation-driven/&gt;\n</code></pre>\n<p>会利用AnnotationDrivenBeanDefinitionParser进行相关的解析、初始化工作，正是在其parse方法完成了对JSR校验的支持。相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    RuntimeBeanReference validator = getValidator(element, source, parserContext);\n}\n\nprivate RuntimeBeanReference getValidator(Element element, Object source, ParserContext parserContext) {\n    //mvc:annotation-driven配置支持validator属性\n    if (element.hasAttribute(\"validator\")) {\n        return new RuntimeBeanReference(element.getAttribute(\"validator\"));\n    } else if (javaxValidationPresent) {\n        RootBeanDefinition validatorDef = new RootBeanDefinition(\n                \"org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean\");\n        validatorDef.setSource(source);\n        validatorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        String validatorName = parserContext.getReaderContext().registerWithGeneratedName(validatorDef);\n        parserContext.registerComponent(new BeanComponentDefinition(validatorDef, validatorName));\n        return new RuntimeBeanReference(validatorName);\n    } else {\n        return null;\n    }\n}\n</code></pre>\n<p>javaxValidationPresent的定义:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static final boolean javaxValidationPresent =\n    ClassUtils.isPresent(\"javax.validation.Validator\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader());\n</code></pre>\n<p>实现了InitializingBean接口，所以afterPropertiesSet方法是其初始化的入口，具体的校验过程不再展开。<br>\n除此之外还有一个有意思的问题，就是上面提到的校验器是如何进入到DataBinder中去的呢?答案是WebDataBinderFactory创建DataBinder对象时会利用WebBindingInitializer对DataBinder进行初始化，正是在这里<br>\n将容器中存在的校验器设置到DataBinder中，至于WebBindingInitializer又是从哪里来的，不再探究了，否则这细节实在是太麻烦了，意义不大。</p>\n<h4>自定义校验器</h4>\n<p>我们可以实现Spring提供的Validator接口，然后在Controller里边这样设置我们要是用的校验器:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@InitBinder\npublic void initBinder(DataBinder dataBinder) {\n    dataBinder.setValidator(new SimpleModelValidator());\n    //如果有多个可以使用addValidators方法\n}\n</code></pre>\n<p>我们的Controller方法依然可以如此定义:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@RequestMapping(\"/echoAgain\")\npublic String echo(@Validated SimpleModel simpleModel, Model model) {\n    return \"echo\";\n}\n</code></pre>\n<p>如果有错误，会直接返回400.</p>\n<h4>一个有意思的问题</h4>\n<p>如果我们把Controller方法这样定义会怎样?</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@RequestMapping(value = \"/echoAgain\", method = RequestMethod.POST)\npublic String echo(@Validated @RequestBody SimpleModel simpleModel, Model model) {}\n</code></pre>\n<p>答案是@RequestBody注解先于@Validated注解起作用，这样既可以利用@RequestBody注解向Controller传递json串，同时又能够达到校验的目的。从源码的角度来说，这在很大程度上是一个顺序的问题:<br>\nRequestMappingHandlerAdapter.getDefaultArgumentResolvers相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">resolvers.add(new ServletModelAttributeMethodProcessor(false));\nresolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n</code></pre>\n<p>虽然ServletModelAttributeMethodProcessor位于RequestResponseBodyMethodProcessor之前，但构造器参数为false说明了此解析器必须要求参数被@ModelAttribute注解标注，其实在最后还有一个不需要注解的解析器被添加:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">// Catch-all\nresolvers.add(new ServletModelAttributeMethodProcessor(true));\n</code></pre>\n<p>至此，真相大白。</p>\n');
INSERT INTO `tb_article` VALUES (318, 'spring-task', 'http://47.100.57.39/static/uploads/70/48ef0bced6565f565296db75237d27.jpg', 'seaswalker', 'spring-task调度', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [开头](#%E5%BC%80%E5%A4%B4)\n- [定时器](#%E5%AE%9A%E6%97%B6%E5%99%A8)\n  - [用法](#%E7%94%A8%E6%B3%95)\n  - [解析](#%E8%A7%A3%E6%9E%90)\n    - [注册](#%E6%B3%A8%E5%86%8C)\n    - [scheduler](#scheduler)\n    - [scheduled-tasks](#scheduled-tasks)\n  - [调度执行](#%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C)\n    - [scheduler初始化](#scheduler%E5%88%9D%E5%A7%8B%E5%8C%96)\n    - [任务调度](#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6)\n      - [Trigger](#trigger)\n      - [Cron解析](#cron%E8%A7%A3%E6%9E%90)\n      - [调度](#%E8%B0%83%E5%BA%A6)\n  - [总结](#%E6%80%BB%E7%BB%93)\n- [异步执行](#%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C)\n  - [配置](#%E9%85%8D%E7%BD%AE)\n  - [原理](#%E5%8E%9F%E7%90%86)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 开头\n\n从功能上来说，spring-task这个组件主要包括了两个/两种功能:\n\n- 任务的定时调度/执行，对应xml配置的task:scheduler和task:scheduled-tasks标签。\n- 方法异步执行，对应xml配置的task:executor标签。\n\ntask:annotation-driven标签被以上两种功能共有。下面就这两种功能分别进行说明。\n\n# 定时器\n\n## 用法\n\n以XML作为示例，基于注解的也是一样的。\n\n```xml\n<task:scheduler id=\"scheduler\" pool-size=\"3\" />\n<bean id=\"task\" class=\"task.Task\"/>\n<task:scheduled-tasks scheduler=\"scheduler\">\n    <task:scheduled ref=\"task\" method=\"print\" cron=\"0/5 * * * * ?\"/>\n</task:scheduled-tasks>\n```\n\n定义了一个定时任务，每隔5秒执行Task的print方法，Task:\n\n```java\npublic class Task {\n    public void print() {\n        System.out.println(\"print执行\");\n    }\n}\n```\n\n关于cron表达式可以参考:\n\n[深入浅出Spring task定时任务](http://blog.csdn.net/u011116672/article/details/52517247)\n\n## 解析\n\n### 注册\n\n此部分的解析器注册由TaskNamespaceHandler完成:\n\n```java\n@Override\npublic void init() {\n    this.registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());\n    this.registerBeanDefinitionParser(\"executor\", new ExecutorBeanDefinitionParser());\n    this.registerBeanDefinitionParser(\"scheduled-tasks\", new ScheduledTasksBeanDefinitionParser());\n    this.registerBeanDefinitionParser(\"scheduler\", new SchedulerBeanDefinitionParser());\n}\n```\n\n### scheduler\n\nSchedulerBeanDefinitionParser源码:\n\n```java\n@Override\nprotected String getBeanClassName(Element element) {\n    return \"org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\";\n}\n\n@Override\nprotected void doParse(Element element, BeanDefinitionBuilder builder) {\n    String poolSize = element.getAttribute(\"pool-size\");\n    if (StringUtils.hasText(poolSize)) {\n        builder.addPropertyValue(\"poolSize\", poolSize);\n    }\n}\n```\n\n由于SchedulerBeanDefinitionParser是AbstractSingleBeanDefinitionParser的子类，所以Spring将task:scheduler标签解析为一个BeanDefinition。其beanClass为org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler。\n\n### scheduled-tasks\n\n其解析的源码较长，在此不再贴出，解析之后形成的BeanDefinition结构如下图:\n\n![scheduled-tasks结构图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/scheduled-tasks.png)\n\n\n\ntaskScheduler属性即指向task:scheduler标签，如果没有配置，此属性不存在。\n\nSpring将每一个task:scheduled标签解析为一个Task(的子类)，其类图如下:\n\n![Task类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Task.jpg)\n\n很明显可以看出，任务的类型是由cron, fixed-delay, fixed-rate, trigger四个属性决定的，fixed-delay和fixed-rate为IntervalTask。\n\n注意一点: **四种任务集合并不是互斥的**。比如说一个task:scheduled标签同时配置了cron和trigger属性，那么此标签会导致生成两个beanClass分别为CronTask何TriggerTask的BeanDefinition产生，并分别被放到cronTasksList和triggerTasksList中。\n\n从图中可以看出，task:scheduled的method和ref属性也被包装成了一个BeanDefinition, 其beanClass为org.springframework.scheduling.support.ScheduledMethodRunnable.\n\n## 调度执行\n\n入口便是ContextLifecycleScheduledTaskRegistrar，类图:\n\n![ContextLifecycleScheduledTaskRegistrar类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ContextLifecycleScheduledTaskRegistrar.jpg)\n\nContextLifecycleScheduledTaskRegistrar只实现了afterSingletonsInstantiated方法:\n\n```java\n@Override\npublic void afterSingletonsInstantiated() {\n    scheduleTasks();\n}\n```\n\nScheduledTaskRegistrar.scheduleTasks:\n\n```java\nprotected void scheduleTasks() {\n     // shcheduler初始化\n    if (this.taskScheduler == null) {\n        this.localExecutor = Executors.newSingleThreadScheduledExecutor();\n        this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);\n    }\n    if (this.triggerTasks != null) {\n        for (TriggerTask task : this.triggerTasks) {\n            addScheduledTask(scheduleTriggerTask(task));\n        }\n    }\n    if (this.cronTasks != null) {\n        for (CronTask task : this.cronTasks) {\n            addScheduledTask(scheduleCronTask(task));\n        }\n    }\n    if (this.fixedRateTasks != null) {\n        for (IntervalTask task : this.fixedRateTasks) {\n            addScheduledTask(scheduleFixedRateTask(task));\n        }\n    }\n    if (this.fixedDelayTasks != null) {\n        for (IntervalTask task : this.fixedDelayTasks) {\n            addScheduledTask(scheduleFixedDelayTask(task));\n        }\n    }\n}\n```\n\n### scheduler初始化\n\n可见，如果没有配置task:scheduler，那么在这里将会进行其初始化工作。\n\nSpring定义了TaskScheduler接口，独立于jdk之外，这样做的目的在于能够同时支持JDK和quartz。对于默认来说，Spring将真正的逻辑全部委托给jdk的Executor。\n\nTaskScheduler类图:\n\n![TaskScheduler类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/TaskScheduler.jpg)\n\nConcurrentTaskExecutor来自另一个继承体系: TaskExecutor，这和spring-task的另一个重要功能，异步执行，这里暂且不表。\n\n### 任务调度\n\n以喜闻乐见的CronTask为例。ScheduledTaskRegistrar.scheduleCronTask:\n\n```java\npublic ScheduledTask scheduleCronTask(CronTask task) {\n    ScheduledTask scheduledTask = this.unresolvedTasks.remove(task);\n    if (this.taskScheduler != null) {\n        scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger());\n    }\n    return (newTask ? scheduledTask : null);\n}\n```\n\n#### Trigger\n\n可见，Cron也是通过Trigger实现的，在Spring中，Trigger被定义为**决定一个任务的下一次执行时间**。其类图:\n\n![Trigger.jpg]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Trigger.jpg)\n\n那么问题来了，字符串形式的cron表达式是在何时被解析为Trigger的呢?\n\n#### Cron解析\n\nCronTask构造器:\n\n```java\npublic CronTask(Runnable runnable, String expression) {\n    this(runnable, new CronTrigger(expression));\n}\n```\n\nCronTrigger构造器:\n\n```java\npublic CronTrigger(String expression) {\n    this.sequenceGenerator = new CronSequenceGenerator(expression);\n}\n```\n\n答案便在CronSequenceGenerator构造器了:\n\n```java\npublic CronSequenceGenerator(String expression) {\n    this(expression, TimeZone.getDefault());\n}\n\npublic CronSequenceGenerator(String expression, TimeZone timeZone) {\n    this.expression = expression;\n    this.timeZone = timeZone;\n    parse(expression);\n}\n```\n\n具体是如何解析的，不再深入。\n\nConcurrentTaskScheduler.schedule:\n\n```java\n@Override\npublic ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {\n    ErrorHandler errorHandler = (this.errorHandler != null ? this.errorHandler : 			 				TaskUtils.getDefaultErrorHandler(true));\n    return new ReschedulingRunnable(task, trigger, this.scheduledExecutor, errorHandler).schedule();\n}\n```\n\n#### 调度\n\n从上面的源码可以看出，调度是通过ReschedulingRunnable来完成的，其类图:\n\n![ReschedulingRunnable类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ReschedulingRunnable.jpg)\n\nschedule方法:\n\n```java\npublic ScheduledFuture<?> schedule() {\n    synchronized (this.triggerContextMonitor) {\n        this.scheduledExecutionTime = this.trigger.nextExecutionTime(this.triggerContext);\n        if (this.scheduledExecutionTime == null) {\n            return null;\n        }\n        long initialDelay = this.scheduledExecutionTime.getTime() - System.currentTimeMillis();\n        this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS);\n        return this;\n    }\n}\n```\n\n可以看出，这里设置了在下一次执行窗口调用this(ReschedulingRunnable)，从类图可以看出，ReschedulingRunnable本身实现了Runnable接口，其run方法:\n\n```java\n@Override\npublic void run() {\n    Date actualExecutionTime = new Date();\n    super.run();\n    Date completionTime = new Date();\n    synchronized (this.triggerContextMonitor) {\n        this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, completionTime);\n        if (!this.currentFuture.isCancelled()) {\n             //下次调用\n            schedule();\n        }\n    }\n}\n```\n\n对我们自定义逻辑的调用是通过super.run实现的:\n\n```java\n@Override\npublic void run() {\n    this.delegate.run();\n}\n```\n\ndelegate便是前面提到过的ScheduledMethodRunnable，其run方法:\n\n```java\n@Override\npublic void run() {\n    ReflectionUtils.makeAccessible(this.method);\n    this.method.invoke(this.target);\n}\n```\n\n当然这只是针对CronTask的实现，而对于IntervalTask就要简单多了，ScheduledTaskRegistrar.scheduleFixedDelayTask部分源码:\n\n```java\npublic ScheduledTask scheduleFixedDelayTask(IntervalTask task) {\n    if (this.taskScheduler != null) {\n        if (task.getInitialDelay() > 0) {\n            Date startTime = new Date(System.currentTimeMillis() + task.getInitialDelay());\n            scheduledTask.future =\n            this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(),\n                                                      startTime, task.getInterval());\n        } else {\n            scheduledTask.future =\n                    this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), task.getInterval());\n        }\n    }\n    return (newTask ? scheduledTask : null);\n}\n```\n\n## 总结\n\n从上面的说明可以看出，Spring其实将核心逻辑委托给了JDK的Executors.newSingleThreadScheduledExecutor()来实现，那么JDK是如何用一个线程来定时执行多个任务的呢?\n\n# 异步执行\n\n## 配置\n\n必须以注解的方式进行配置，xml:\n\n```xml\n<task:executor id=\"executor\" pool-size=\"3\"/>\n<task:annotation-driven executor=\"executor\"/>\n```\n\n这样在类或方法上加上注解即可:\n\n```java\n@Async(\"executor\")\npublic void print() {\n    System.out.println(\"print执行\");\n}\n```\n\n## 原理\n\n猜测:\n\nSpring会为带有@Async的组件生成代理子类实现对原生组件的替换，代理子类将异步执行的方法包装为Task(Runnable)提交到jdk的线程池即可。\n\n', '', '2', 0, '2020-01-08 17:05:19', '2020-01-08 17:05:19', '2020-01-08 17:02:57', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#%E5%BC%80%E5%A4%B4\">开头</a></li>\n<li><a href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8\">定时器</a>\n<ul>\n<li><a href=\"#%E7%94%A8%E6%B3%95\">用法</a></li>\n<li><a href=\"#%E8%A7%A3%E6%9E%90\">解析</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E5%86%8C\">注册</a></li>\n<li><a href=\"#scheduler\">scheduler</a></li>\n<li><a href=\"#scheduled-tasks\">scheduled-tasks</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C\">调度执行</a>\n<ul>\n<li><a href=\"#scheduler%E5%88%9D%E5%A7%8B%E5%8C%96\">scheduler初始化</a></li>\n<li><a href=\"#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6\">任务调度</a>\n<ul>\n<li><a href=\"#trigger\">Trigger</a></li>\n<li><a href=\"#cron%E8%A7%A3%E6%9E%90\">Cron解析</a></li>\n<li><a href=\"#%E8%B0%83%E5%BA%A6\">调度</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C\">异步执行</a>\n<ul>\n<li><a href=\"#%E9%85%8D%E7%BD%AE\">配置</a></li>\n<li><a href=\"#%E5%8E%9F%E7%90%86\">原理</a></li>\n</ul>\n</li>\n</ul>\n\n<h1>开头</h1>\n<p>从功能上来说，spring-task这个组件主要包括了两个/两种功能:</p>\n<ul>\n<li>任务的定时调度/执行，对应xml配置的task:scheduler和task:scheduled-tasks标签。</li>\n<li>方法异步执行，对应xml配置的task:executor标签。</li>\n</ul>\n<p>task:annotation-driven标签被以上两种功能共有。下面就这两种功能分别进行说明。</p>\n<h1>定时器</h1>\n<h2>用法</h2>\n<p>以XML作为示例，基于注解的也是一样的。</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;task:scheduler id=\"scheduler\" pool-size=\"3\" /&gt;\n&lt;bean id=\"task\" class=\"task.Task\"/&gt;\n&lt;task:scheduled-tasks scheduler=\"scheduler\"&gt;\n    &lt;task:scheduled ref=\"task\" method=\"print\" cron=\"0/5 * * * * ?\"/&gt;\n&lt;/task:scheduled-tasks&gt;\n</code></pre>\n<p>定义了一个定时任务，每隔5秒执行Task的print方法，Task:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public class Task {\n    public void print() {\n        System.out.println(\"print执行\");\n    }\n}\n</code></pre>\n<p>关于cron表达式可以参考:</p>\n<p><a href=\"http://blog.csdn.net/u011116672/article/details/52517247\">深入浅出Spring task定时任务</a></p>\n<h2>解析</h2>\n<h3>注册</h3>\n<p>此部分的解析器注册由TaskNamespaceHandler完成:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void init() {\n    this.registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());\n    this.registerBeanDefinitionParser(\"executor\", new ExecutorBeanDefinitionParser());\n    this.registerBeanDefinitionParser(\"scheduled-tasks\", new ScheduledTasksBeanDefinitionParser());\n    this.registerBeanDefinitionParser(\"scheduler\", new SchedulerBeanDefinitionParser());\n}\n</code></pre>\n<h3>scheduler</h3>\n<p>SchedulerBeanDefinitionParser源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected String getBeanClassName(Element element) {\n    return \"org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\";\n}\n\n@Override\nprotected void doParse(Element element, BeanDefinitionBuilder builder) {\n    String poolSize = element.getAttribute(\"pool-size\");\n    if (StringUtils.hasText(poolSize)) {\n        builder.addPropertyValue(\"poolSize\", poolSize);\n    }\n}\n</code></pre>\n<p>由于SchedulerBeanDefinitionParser是AbstractSingleBeanDefinitionParser的子类，所以Spring将task:scheduler标签解析为一个BeanDefinition。其beanClass为org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler。</p>\n<h3>scheduled-tasks</h3>\n<p>其解析的源码较长，在此不再贴出，解析之后形成的BeanDefinition结构如下图:</p>\n<p>![scheduled-tasks结构图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/scheduled-tasks.png)</p>\n<p>taskScheduler属性即指向task:scheduler标签，如果没有配置，此属性不存在。</p>\n<p>Spring将每一个task:scheduled标签解析为一个Task(的子类)，其类图如下:</p>\n<p>![Task类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Task.jpg)</p>\n<p>很明显可以看出，任务的类型是由cron, fixed-delay, fixed-rate, trigger四个属性决定的，fixed-delay和fixed-rate为IntervalTask。</p>\n<p>注意一点: <strong>四种任务集合并不是互斥的</strong>。比如说一个task:scheduled标签同时配置了cron和trigger属性，那么此标签会导致生成两个beanClass分别为CronTask何TriggerTask的BeanDefinition产生，并分别被放到cronTasksList和triggerTasksList中。</p>\n<p>从图中可以看出，task:scheduled的method和ref属性也被包装成了一个BeanDefinition, 其beanClass为org.springframework.scheduling.support.ScheduledMethodRunnable.</p>\n<h2>调度执行</h2>\n<p>入口便是ContextLifecycleScheduledTaskRegistrar，类图:</p>\n<p>![ContextLifecycleScheduledTaskRegistrar类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ContextLifecycleScheduledTaskRegistrar.jpg)</p>\n<p>ContextLifecycleScheduledTaskRegistrar只实现了afterSingletonsInstantiated方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void afterSingletonsInstantiated() {\n    scheduleTasks();\n}\n</code></pre>\n<p>ScheduledTaskRegistrar.scheduleTasks:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected void scheduleTasks() {\n     // shcheduler初始化\n    if (this.taskScheduler == null) {\n        this.localExecutor = Executors.newSingleThreadScheduledExecutor();\n        this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);\n    }\n    if (this.triggerTasks != null) {\n        for (TriggerTask task : this.triggerTasks) {\n            addScheduledTask(scheduleTriggerTask(task));\n        }\n    }\n    if (this.cronTasks != null) {\n        for (CronTask task : this.cronTasks) {\n            addScheduledTask(scheduleCronTask(task));\n        }\n    }\n    if (this.fixedRateTasks != null) {\n        for (IntervalTask task : this.fixedRateTasks) {\n            addScheduledTask(scheduleFixedRateTask(task));\n        }\n    }\n    if (this.fixedDelayTasks != null) {\n        for (IntervalTask task : this.fixedDelayTasks) {\n            addScheduledTask(scheduleFixedDelayTask(task));\n        }\n    }\n}\n</code></pre>\n<h3>scheduler初始化</h3>\n<p>可见，如果没有配置task:scheduler，那么在这里将会进行其初始化工作。</p>\n<p>Spring定义了TaskScheduler接口，独立于jdk之外，这样做的目的在于能够同时支持JDK和quartz。对于默认来说，Spring将真正的逻辑全部委托给jdk的Executor。</p>\n<p>TaskScheduler类图:</p>\n<p>![TaskScheduler类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/TaskScheduler.jpg)</p>\n<p>ConcurrentTaskExecutor来自另一个继承体系: TaskExecutor，这和spring-task的另一个重要功能，异步执行，这里暂且不表。</p>\n<h3>任务调度</h3>\n<p>以喜闻乐见的CronTask为例。ScheduledTaskRegistrar.scheduleCronTask:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public ScheduledTask scheduleCronTask(CronTask task) {\n    ScheduledTask scheduledTask = this.unresolvedTasks.remove(task);\n    if (this.taskScheduler != null) {\n        scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger());\n    }\n    return (newTask ? scheduledTask : null);\n}\n</code></pre>\n<h4>Trigger</h4>\n<p>可见，Cron也是通过Trigger实现的，在Spring中，Trigger被定义为<strong>决定一个任务的下一次执行时间</strong>。其类图:</p>\n<p>![Trigger.jpg]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Trigger.jpg)</p>\n<p>那么问题来了，字符串形式的cron表达式是在何时被解析为Trigger的呢?</p>\n<h4>Cron解析</h4>\n<p>CronTask构造器:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public CronTask(Runnable runnable, String expression) {\n    this(runnable, new CronTrigger(expression));\n}\n</code></pre>\n<p>CronTrigger构造器:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public CronTrigger(String expression) {\n    this.sequenceGenerator = new CronSequenceGenerator(expression);\n}\n</code></pre>\n<p>答案便在CronSequenceGenerator构造器了:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public CronSequenceGenerator(String expression) {\n    this(expression, TimeZone.getDefault());\n}\n\npublic CronSequenceGenerator(String expression, TimeZone timeZone) {\n    this.expression = expression;\n    this.timeZone = timeZone;\n    parse(expression);\n}\n</code></pre>\n<p>具体是如何解析的，不再深入。</p>\n<p>ConcurrentTaskScheduler.schedule:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger) {\n    ErrorHandler errorHandler = (this.errorHandler != null ? this.errorHandler : 			 				TaskUtils.getDefaultErrorHandler(true));\n    return new ReschedulingRunnable(task, trigger, this.scheduledExecutor, errorHandler).schedule();\n}\n</code></pre>\n<h4>调度</h4>\n<p>从上面的源码可以看出，调度是通过ReschedulingRunnable来完成的，其类图:</p>\n<p>![ReschedulingRunnable类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/ReschedulingRunnable.jpg)</p>\n<p>schedule方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public ScheduledFuture&lt;?&gt; schedule() {\n    synchronized (this.triggerContextMonitor) {\n        this.scheduledExecutionTime = this.trigger.nextExecutionTime(this.triggerContext);\n        if (this.scheduledExecutionTime == null) {\n            return null;\n        }\n        long initialDelay = this.scheduledExecutionTime.getTime() - System.currentTimeMillis();\n        this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS);\n        return this;\n    }\n}\n</code></pre>\n<p>可以看出，这里设置了在下一次执行窗口调用this(ReschedulingRunnable)，从类图可以看出，ReschedulingRunnable本身实现了Runnable接口，其run方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void run() {\n    Date actualExecutionTime = new Date();\n    super.run();\n    Date completionTime = new Date();\n    synchronized (this.triggerContextMonitor) {\n        this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, completionTime);\n        if (!this.currentFuture.isCancelled()) {\n             //下次调用\n            schedule();\n        }\n    }\n}\n</code></pre>\n<p>对我们自定义逻辑的调用是通过super.run实现的:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void run() {\n    this.delegate.run();\n}\n</code></pre>\n<p>delegate便是前面提到过的ScheduledMethodRunnable，其run方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void run() {\n    ReflectionUtils.makeAccessible(this.method);\n    this.method.invoke(this.target);\n}\n</code></pre>\n<p>当然这只是针对CronTask的实现，而对于IntervalTask就要简单多了，ScheduledTaskRegistrar.scheduleFixedDelayTask部分源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public ScheduledTask scheduleFixedDelayTask(IntervalTask task) {\n    if (this.taskScheduler != null) {\n        if (task.getInitialDelay() &gt; 0) {\n            Date startTime = new Date(System.currentTimeMillis() + task.getInitialDelay());\n            scheduledTask.future =\n            this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(),\n                                                      startTime, task.getInterval());\n        } else {\n            scheduledTask.future =\n                    this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), task.getInterval());\n        }\n    }\n    return (newTask ? scheduledTask : null);\n}\n</code></pre>\n<h2>总结</h2>\n<p>从上面的说明可以看出，Spring其实将核心逻辑委托给了JDK的Executors.newSingleThreadScheduledExecutor()来实现，那么JDK是如何用一个线程来定时执行多个任务的呢?</p>\n<h1>异步执行</h1>\n<h2>配置</h2>\n<p>必须以注解的方式进行配置，xml:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;task:executor id=\"executor\" pool-size=\"3\"/&gt;\n&lt;task:annotation-driven executor=\"executor\"/&gt;\n</code></pre>\n<p>这样在类或方法上加上注解即可:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Async(\"executor\")\npublic void print() {\n    System.out.println(\"print执行\");\n}\n</code></pre>\n<h2>原理</h2>\n<p>猜测:</p>\n<p>Spring会为带有@Async的组件生成代理子类实现对原生组件的替换，代理子类将异步执行的方法包装为Task(Runnable)提交到jdk的线程池即可。</p>\n');
INSERT INTO `tb_article` VALUES (319, 'spring-transaction笔记', 'http://47.100.57.39/static/uploads/a3/84b96ecd7e3c5613160e364d2e8727.jpg', 'seaswalker', 'spring-transaction事务', '<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [配置](#%E9%85%8D%E7%BD%AE)\n- [解析](#%E8%A7%A3%E6%9E%90)\n  - [TransactionalEventListener](#transactionaleventlistener)\n  - [主要组件注册](#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C)\n  - [代理类生成](#%E4%BB%A3%E7%90%86%E7%B1%BB%E7%94%9F%E6%88%90)\n    - [Advisor寻找](#advisor%E5%AF%BB%E6%89%BE)\n- [运行](#%E8%BF%90%E8%A1%8C)\n  - [调用链生成](#%E8%B0%83%E7%94%A8%E9%93%BE%E7%94%9F%E6%88%90)\n  - [调用链调用](#%E8%B0%83%E7%94%A8%E9%93%BE%E8%B0%83%E7%94%A8)\n  - [TransactionInterceptor](#transactioninterceptor)\n    - [事务管理器](#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8)\n    - [DataSource](#datasource)\n    - [事务开启](#%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%90%AF)\n      - [是否已存在事务](#%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8%E4%BA%8B%E5%8A%A1)\n      - [事务已存在](#%E4%BA%8B%E5%8A%A1%E5%B7%B2%E5%AD%98%E5%9C%A8)\n        - [PROPAGATION_NEVER](#propagation_never)\n        - [PROPAGATION_NOT_SUPPORTED](#propagation_not_supported)\n          - [事务挂起](#%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7)\n        - [PROPAGATION_REQUIRES_NEW](#propagation_requires_new)\n        - [PROPAGATION_NESTED](#propagation_nested)\n          - [debug环境搭建](#debug%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA)\n          - [事务对象](#%E4%BA%8B%E5%8A%A1%E5%AF%B9%E8%B1%A1)\n          - [Savepoint](#savepoint)\n        - [其它](#%E5%85%B6%E5%AE%83)\n      - [事务创建](#%E4%BA%8B%E5%8A%A1%E5%88%9B%E5%BB%BA)\n    - [事务提交 & 回滚](#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4--%E5%9B%9E%E6%BB%9A)\n- [总结](#%E6%80%BB%E7%BB%93)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# 配置\n\n以最简单的jdbc事务为例:\n\n```xml\n<!-- 数据源以Sping自带为例，每次请求均返回一个新的连接 -->\n<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\" />\n    <property name=\"url\" value=\"${jdbc.url}\" />\n    <property name=\"username\" value=\"${jdbc.username}\" />\n    <property name=\"password\" value=\"${jdbc.password}\" />\n</bean>\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n<tx:annotation-driven transaction-manager=\"transactionManager\"/>\n```\n\n# 解析\n\nTxNamespaceHandler.init:\n\n```java\n@Override\npublic void init() {\n    registerBeanDefinitionParser(\"advice\", new TxAdviceBeanDefinitionParser());\n    registerBeanDefinitionParser(\"annotation-driven\", \n        new AnnotationDrivenBeanDefinitionParser());\n    registerBeanDefinitionParser(\"jta-transaction-manager\", new JtaTransactionManagerBeanDefinitionParser());\n}\n```\n\n明显解析的入口便在AnnotationDrivenBeanDefinitionParser.parse:\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    registerTransactionalEventListenerFactory(parserContext);\n    String mode = element.getAttribute(\"mode\");\n    if (\"aspectj\".equals(mode)) {\n        // mode=\"aspectj\"\n        registerTransactionAspect(element, parserContext);\n    } else {\n        // mode=\"proxy\"\n        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);\n    }\n    return null;\n}\n```\n\n下面分部分进行说明。\n\n##  TransactionalEventListener\n\n第一部分用于向Spring容器注册TransactionalEventListener工厂，TransactionalEventListener是Spring4.2引入的新特性，允许我们自定义监听器监听事务的提交或其它动作。\n\n## 主要组件注册\n\n即configureAutoProxyCreator方法，此方法的最终作用便是在Spring容器中加入这样的bean结构:\n\nBeanFactoryTransactionAttributeSourceAdvisor->TransactionInterceptor->AnnotationTransactionAttributeSource\n\n其中AnnotationTransactionAttributeSource用于解析@Transactional注解的相关属性。\n\n## 代理类生成\n\n与aop模块类似，入口位于configureAutoProxyCreator里注册的bean: InfrastructureAdvisorAutoProxyCreator，其类图:\n\n![InfrastructureAdvisorAutoProxyCreator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/InfrastructureAdvisorAutoProxyCreator.jpg)\n\n此类的特殊之处从其名字上可以体现: **只考虑Spring内部使用的基础设施Advisor**。\n\n为类创建代理的入口位于AbstractAutoProxyCreator.postProcessAfterInitialization:\n\n```java\n@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n```\n\nwrapIfNecessary核心逻辑:\n\n```java\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    // Create proxy if we have advice.\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        Object proxy = createProxy(\n            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n}\n```\n\n### Advisor寻找\n\ngetAdvicesAndAdvisorsForBean用于去容器中寻找适合当前bean的Advisor，其最终调用AbstractAdvisorAutoProxyCreator.findEligibleAdvisors:\n\n```java\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        //按照@Ordered排序\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n\n这个方法在spring-aop中已经详细说明过了，这里再强调一下具体的查找逻辑:\n\n- 首先去容器找出所有实现了Advisor接口的bean，对应findCandidateAdvisors方法.\n- 逐一判断Advisor是否适用于当前bean，对应findAdvisorsThatCanApply方法，判断逻辑为:\n  - 如果Advisor是IntroductionAdvisor，那么判断其ClassFilter是否可以匹配bean的类.\n  - 如果Advisor是PointcutAdvisor，那么首先进行ClassFilter匹配，如果匹配失败，那么再获得Advisor的MethodMatcher对象，如果MethodMatcher可以匹配任意方法，那么返回true，否则反射获取给定bean的所有方法逐一进行匹配，只要有一个匹配成功，即返回true.\n  - 其它情况，直接返回true.\n\n对于spring事务来说，我们有唯一的Advisor: BeanFactoryTransactionAttributeSourceAdvisor,其类图:\n\n![BeanFactoryTransactionAttributeSourceAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanFactoryTransactionAttributeSourceAdvisor.jpg)\n\n可以看出，BeanFactoryTransactionAttributeSourceAdvisor其实是一个PointcutAdvisor，所以**是否可以匹配取决于其Pointcut**。此Advisor的pointcut是一个TransactionAttributeSourcePointcut对象，类图:\n\n![TransactionAttributeSourcePointcut类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/TransactionAttributeSourcePointcut.jpg)\n\n**Pointcut的核心在于其ClassFilter和MethodMatcher**。\n\nClassFilter:\n\n位于StaticMethodMatcherPointcut:\n\n```java\nprivate ClassFilter classFilter = ClassFilter.TRUE;\n```\n\n即: 类检查全部通过。\n\nMethodMatcher:\n\nTransactionAttributeSourcePointcut.matches:\n\n```java\n@Override\npublic boolean matches(Method method, Class<?> targetClass) {\n    //如果已经是事务代理，那么不应该再次代理\n    if (TransactionalProxy.class.isAssignableFrom(targetClass)) {\n        return false;\n    }\n    TransactionAttributeSource tas = getTransactionAttributeSource();\n    return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);\n}\n```\n\ngetTransactionAttribute方法使用了缓存的思想，但其核心逻辑位于AbstractFallbackTransactionAttributeSource.computeTransactionAttribute:\n\n```java\nprotected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {\n    // Don\'t allow no-public methods as required.\n    if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n        return null;\n    }\n    // Ignore CGLIB subclasses - introspect the actual user class.\n    Class<?> userClass = ClassUtils.getUserClass(targetClass);\n    // The method may be on an interface, but we need attributes from the target class.\n    // If the target class is null, the method will be unchanged.\n    Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass);\n    // If we are dealing with method with generic parameters, find the original method.\n    specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n    // First try is the method in the target class.\n    TransactionAttribute txAtt = findTransactionAttribute(specificMethod);\n    if (txAtt != null) {\n        return txAtt;\n    }\n    // Second try is the transaction attribute on the target class.\n    txAtt = findTransactionAttribute(specificMethod.getDeclaringClass());\n    if (txAtt != null && ClassUtils.isUserLevelMethod(method)) {\n        return txAtt;\n    }\n    if (specificMethod != method) {\n        // Fallback is to look at the original method.\n        txAtt = findTransactionAttribute(method);\n        if (txAtt != null) {\n            return txAtt;\n        }\n        // Last fallback is the class of the original method.\n        txAtt = findTransactionAttribute(method.getDeclaringClass());\n        if (txAtt != null && ClassUtils.isUserLevelMethod(method)) {\n            return txAtt;\n        }\n    }\n    return null;\n}\n```\n\n很明显可以看出，**首先去方法上查找是否有相应的事务注解(比如@Transactional)，如果没有，那么再去类上查找**。\n\n# 运行\n\n以JDK动态代理为例，JdkDynamicAopProxy.invoke简略版源码:\n\n```java\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n    if (chain.isEmpty()) {.\n        //没有可用的拦截器，直接调用原方法\n        Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n        retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n    } else {\n        // We need to create a method invocation...\n        invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n        // Proceed to the joinpoint through the interceptor chain.\n        Object retVal = invocation.proceed();\n    }\n}\n```\n\n## 调用链生成\n\n即getInterceptorsAndDynamicInterceptionAdvice方法，其原理是:\n\n**遍历所有使用的 Advisor，获得其Advice，将Advice转为MethodInterceptor**。那么是如何转的呢?\n\n根据Spring的定义，Advice可以是一个MethodInterceptor，也可以是类似于Aspectj的before, after通知。转换由DefaultAdvisorAdapterRegistry.getInterceptors完成:\n\n```java\n@Override\npublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {\n    List<MethodInterceptor> interceptors = new ArrayList<MethodInterceptor>(3);\n    Advice advice = advisor.getAdvice();\n    if (advice instanceof MethodInterceptor) {\n        interceptors.add((MethodInterceptor) advice);\n    }\n    for (AdvisorAdapter adapter : this.adapters) {\n        if (adapter.supportsAdvice(advice)) {\n            interceptors.add(adapter.getInterceptor(advisor));\n        }\n    }\n    if (interceptors.isEmpty()) {\n        throw new UnknownAdviceTypeException(advisor.getAdvice());\n    }\n    return interceptors.toArray(new MethodInterceptor[interceptors.size()]);\n}\n```\n\nAdvisorAdapter接口用以支持用户自定义的Advice类型，并将自定义的类型转为拦截器。默认adapters含有MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter和ThrowsAdviceAdapter三种类型，用以分别支持MethodBeforeAdvice、AfterReturningAdvice和ThrowsAdvice。\n\n**对于我们的BeanFactoryTransactionAttributeSourceAdvisor来说，有且只有一个拦截器: TransactionInterceptor**.\n\n## 调用链调用\n\nReflectiveMethodInvocation.proceed:\n\n```java\n@Override\npublic Object proceed() throws Throwable {\n    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n        //拦截器执行完毕，调用原本的方法\n        return invokeJoinpoint();\n    }\n    Object interceptorOrInterceptionAdvice =\n            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n        InterceptorAndDynamicMethodMatcher dm =\n                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n            return dm.interceptor.invoke(this);\n        } else {\n            // Dynamic matching failed.\n            return proceed();\n        }\n    } else {\n        //调用拦截器的invoke方法\n        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n    }\n}\n```\n\n可以看出，这其实是一个**逐个调用拦截器的invoke方法，最终调用原本方法(被代理方法)的过程**。所以，事务添加的核心逻辑(入口)在TransactionInterceptor的invoke方法。\n\n## TransactionInterceptor\n\ninvoke方法:\n\n```java\n@Override\npublic Object invoke(final MethodInvocation invocation) throws Throwable {\n    Class<?> targetClass = (invocation.getThis() != null ? \n             AopUtils.getTargetClass(invocation.getThis()) : null);\n    // Adapt to TransactionAspectSupport\'s invokeWithinTransaction...\n    return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {\n        @Override\n        public Object proceedWithInvocation() throws Throwable {\n            //事务执行完毕后调用链继续向下执行\n            return invocation.proceed();\n        }\n    });\n}\n```\n\ninvokeWithinTransaction简略版源码(仅保留PlatformTransactionManager部分):\n\n```java\nprotected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation){\n    // If the transaction attribute is null, the method is non-transactional.\n    final TransactionAttribute txAttr = getTransactionAttributeSource()\n        .getTransactionAttribute(method, targetClass);\n    final PlatformTransactionManager tm = determineTransactionManager(txAttr);\n    //得到方法名\n    final String joinpointIdentification = methodIdentification(method, targetClass);\n    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\n        // Standard transaction demarcation with getTransaction and commit/rollback calls.\n        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\n        Object retVal = null;\n        try {\n            // This is an around advice: Invoke the next interceptor in the chain.\n            // This will normally result in a target object being invoked.\n            retVal = invocation.proceedWithInvocation();\n        } catch (Throwable ex) {\n            // target invocation exception\n            completeTransactionAfterThrowing(txInfo, ex);\n            throw ex;\n        } finally {\n            cleanupTransactionInfo(txInfo);\n        }\n        commitTransactionAfterReturning(txInfo);\n        return retVal;\n    }\n}\n```\n\n### 事务管理器\n\ndetermineTransactionManager方法用以确定使用的事务管理器:\n\n```java\nprotected PlatformTransactionManager determineTransactionManager(TransactionAttribute txAttr) {\n    //如果没有事务属性，那么仅从缓存中查找，找不到返回null\n    if (txAttr == null || this.beanFactory == null) {\n        return getTransactionManager();\n    }\n    String qualifier = txAttr.getQualifier();\n    //如果@Transactional注解配置了transactionManager或value属性(用以决定使用哪个事务管理器):\n    //首先查找缓存，找不到再去容器中按名称寻找\n    if (StringUtils.hasText(qualifier)) {\n        return determineQualifiedTransactionManager(qualifier);\n    } else if (StringUtils.hasText(this.transactionManagerBeanName)) {\n        return determineQualifiedTransactionManager(this.transactionManagerBeanName);\n    } else {\n        //去容器中按类型(Class)查找\n        PlatformTransactionManager defaultTransactionManager = getTransactionManager();\n        if (defaultTransactionManager == null) {\n            defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class);\n            this.transactionManagerCache.putIfAbsent(\n                    DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);\n        }\n        return defaultTransactionManager;\n    }\n}\n```\n\n对于我们使用的DataSourceTransactionManager，类图:\n\n![DataSourceTransactionManager]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DataSourceTransactionManager.jpg)\n\nafterPropertiesSet方法只是对dataSource进行了检查。\n\n### DataSource\n\nDriverManagerDataSource类图:\n\n![DriverManagerDataSource类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DriverManagerDataSource.jpg)\n\n其中CommonDataSource、Wrapper、DataSource均位于javax.sql包下。\n\n### 事务开启\n\ninvocation.proceedWithInvocation()便是我们的逻辑，而createTransactionIfNecessary便是在逻辑执行前开启事务。\n\nTransactionAspectSupport.createTransactionIfNecessary:\n\n```java\nprotected TransactionInfo createTransactionIfNecessary(\n    PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {\n    // If no name specified, apply method identification as transaction name.\n    if (txAttr != null && txAttr.getName() == null) {\n        txAttr = new DelegatingTransactionAttribute(txAttr) {\n            @Override\n            public String getName() {\n                return joinpointIdentification;\n            }\n        };\n    }\n    TransactionStatus status = null;\n    if (txAttr != null) {\n        if (tm != null) {\n            status = tm.getTransaction(txAttr);\n        }\n    }\n    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\n}\n```\n\n此部分的核心逻辑在getTransaction和prepareTransactionInfo方法，源码较长，下面依然按部分整理。\n\n#### 是否已存在事务\n\n目的在于支撑事务的传播性。\n\n源码位于DataSourceTransactionManager.doGetTransaction，核心逻辑在TransactionSynchronizationManager.doGetResource:\n\n```java\nprivate static Object doGetResource(Object actualKey) {\n    Map<Object, Object> map = resources.get();\n    if (map == null) {\n        return null;\n    }\n    Object value = map.get(actualKey);\n    // Transparently remove ResourceHolder that was marked as void...\n    if (value instanceof ResourceHolder && ((ResourceHolder) value).isVoid()) {\n        map.remove(actualKey);\n        // Remove entire ThreadLocal if empty...\n        if (map.isEmpty()) {\n            resources.remove();\n        }\n        value = null;\n    }\n    return value;\n}\n```\n\nactualKey实际上是DataSource对象，resources是一个ThreadLocal对象，其声明源码:\n\n```java\nprivate static final ThreadLocal<Map<Object, Object>> resources =\n            new NamedThreadLocal<Map<Object, Object>>(\"Transactional resources\");\n```\n\n从这里可以得出结论:\n\n**是否存在事务指的是在当前线程、当前数据源(DataSource)中是否存在处于活动状态的事务**。\n\n#### 事务已存在\n\n如果检测到已存在事务，那么就要考虑事务的传播特性(行为).此部分源码位于AbstractPlatformTransactionManager.handleExistingTransaction，下面按照不同的传播特性展开。\n\n##### PROPAGATION_NEVER\n\n即当前方法需要在非事务的环境下执行，如果有事务存在，那么抛出异常。相关源码:\n\n```java\nif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\n    throw new IllegalTransactionStateException(\n        \"Existing transaction found for transaction marked with propagation \'never\'\");\n}\n```\n\n##### PROPAGATION_NOT_SUPPORTED\n\n与前者的区别在于，如果有事务存在，那么将事务挂起，而不是抛出异常。\n\n```java\nif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n    Object suspendedResources = suspend(transaction);\n    boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n    return prepareTransactionStatus(\n        definition, null, false, newSynchronization, debugEnabled, suspendedResources);\n}\n```\n\n###### 事务挂起\n\n此部分的核心在于suspend方法，最终调用TransactionSynchronizationManager.doUnbindResource:\n\n```java\nprivate static Object doUnbindResource(Object actualKey) {\n    Map<Object, Object> map = resources.get();\n    if (map == null) {\n        return null;\n    }\n    Object value = map.remove(actualKey);\n    // Remove entire ThreadLocal if empty...\n    if (map.isEmpty()) {\n        resources.remove();\n    }\n    // Transparently suppress a ResourceHolder that was marked as void...\n    if (value instanceof ResourceHolder && ((ResourceHolder) value).isVoid()) {\n        value = null;\n    }\n    return value;\n}\n```\n\n可以看出，**所谓的事务挂起其实就是一个移除当前线程、数据源活动事务对象的过程**。\n\n同时注意getTransaction方法返回的是一个TransactionStatus对象，**被挂起的事务的各种状态都被保存在此对象中**。\n\n那么挂起这个操作到底是如何实现(起作用)的呢?\n\nDataSourceTransactionManager.doSuspend:\n\n```java\n@Override\nprotected Object doSuspend(Object transaction) {\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n    txObject.setConnectionHolder(null);\n    ConnectionHolder conHolder = (ConnectionHolder)\n            TransactionSynchronizationManager.unbindResource(this.dataSource);\n    return conHolder;\n}\n```\n\n其实玄机就在于将ConnectionHolder设为null这一行，因为**一个ConnectionHolder对象就代表了一个数据库连接，将ConnectionHolder设为null就意味着我们下次要使用连接时，将重新从连接池获取，而新的连接的自动提交是为true的**。\n\n##### PROPAGATION_REQUIRES_NEW\n\n```java\nif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n    SuspendedResourcesHolder suspendedResources = suspend(transaction);\n    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n    DefaultTransactionStatus status = newTransactionStatus(\n            definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n    doBegin(transaction, definition);\n    prepareSynchronization(status, definition);\n    return status;\n}\n```\n\n可以看出，这其实是一个**挂起当前活动事务并创建新事务的过程**，doBegin方法是事务开启的核心，将在后面进行说明。\n\n##### PROPAGATION_NESTED\n\n其意义:\n\n> PROPAGATION_NESTED 开始一个 \"嵌套的\" 事务,  它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. \n\n摘自: [解惑 spring 嵌套事务](http://www.iteye.com/topic/35907)\n\n核心源码(忽略JTA部分):\n\n```java\nif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n    if (useSavepointForNestedTransaction()) {\n        // Create savepoint within existing Spring-managed transaction,\n        // through the SavepointManager API implemented by TransactionStatus.\n        // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\n        DefaultTransactionStatus status =\n            prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);\n        status.createAndHoldSavepoint();\n        return status;\n    }\n}\n```\n\n关键在于如何创建SavePoint, AbstractTransactionStatus.createAndHoldSavepoint:\n\n```java\npublic void createAndHoldSavepoint() throws TransactionException {\n    setSavepoint(getSavepointManager().createSavepoint());\n}\n```\n\nDefaultTransactionStatus.getSavepointManager:\n\n```java\n@Override\nprotected SavepointManager getSavepointManager() {\n    if (!isTransactionSavepointManager()) {\n        throw new NestedTransactionNotSupportedException(\n            \"Transaction object [\" + getTransaction() + \"] does not support savepoints\");\n    }\n    return (SavepointManager) getTransaction();\n}\n```\n\n可以看出，SavepointManager实际上从Transaction强转而来，Transaction在Spring都是用Object引用的，那么这到底是个什么东西?\n\n###### debug环境搭建\n\n- 安装Mysql数据库(或其它支持jdbc)并正确配置数据库连接.\n\n- 定义两个bean，代表我们的业务逻辑:\n\n  - TransactionBean:\n\n    ```java\n    @Component\n    public class TransactionBean {\n        private NestedBean nestedBean;\n        public NestedBean getNestedBean() {\n            return nestedBean;\n        }\n        public void setNestedBean(NestedBean nestedBean) {\n            this.nestedBean = nestedBean;\n        }\n      \n        @Transactional(propagation = Propagation.REQUIRED)\n        public void process() {\n            System.out.println(\"事务执行\");\n            nestedBean.nest();\n        }\n    }\n    ```\n\n  - NestedBean:\n\n    ```java\n    @Component\n    public class NestedBean {\n        @Transactional(propagation = Propagation.NESTED)\n        public void nest() {\n            System.out.println(\"嵌套事务\");\n        }\n    }\n    ```\n\n- 配置文件:\n\n  ```xml\n  <bean id=\"nestedBean\" class=\"base.transaction.NestedBean\" />\n  <bean class=\"base.transaction.TransactionBean\">\n    <property name=\"nestedBean\" ref=\"nestedBean\" />\n  </bean>\n  ```\n\n- 入口:\n\n  ```java\n  public static void main(String[] args) {\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n      TransactionBean bean = context.getBean(TransactionBean.class);\n      bean.process();\n  }\n  ```\n\n这样将断点打在合适的位置便可以得到事务对象究竟是什么。\n\n注意:\n\n**nest方法必须在一个单独的业务bean中**，否则对nest的调用并不会导致事务获取的触发。这是由JDK动态代理的实现机制决定的，**调用当前类的方法并不会触发代理逻辑(InvocationHandler)**。\n\n这一点可以运行demo:test.proxy.JDKProxy看出。\n\n运行debug可以发现，**对于DataSourceTransactionManager，事务对象其实是其内部类DataSourceTransactionObject**.\n\n###### 事务对象\n\n DataSourceTransactionObject的类图如下:\n\n![DataSourceTransactionObject类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DataSourceTransactionObject.jpg)\n\n###### Savepoint\n\n位于java.sql包下，对于Mysql来说，由Mysql驱动提供实现，类图:\n\n![Savepoint类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Savepoint.jpg)\n\n下面来看一下Savepoint到底是如何被创建的。\n\nJdbcTransactionObjectSupport.createSavepoint简略版源码:\n\n```java\n@Override\npublic Object createSavepoint() throws TransactionException {\n    ConnectionHolder conHolder = getConnectionHolderForSavepoint();\n    return conHolder.createSavepoint();\n}\n```\n\nConnectionHolder.createSavepoint:\n\n```java\npublic Savepoint createSavepoint() throws SQLException {\n    this.savepointCounter++;\n    return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);\n}\n```\n\n我们可以得出这样的结论:\n\n**Savepoint由java SQL标准定义，具体实现由数据库完成**。从mysql的客户端可以直接执行命令`savepoint xx`可以看出这一点。 \n\n##### 其它\n\n略。\n\n#### 事务创建\n\n如果之前不存在事务，那么就需要创建了，核心逻辑位于DataSourceTransactionManager.doBegin:\n\n```java\n@Override\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\n    //此时，txObject不为null，只是其核心的ConnectHolder属性为null\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n    Connection con = null;\n    if (txObject.getConnectionHolder() == null ||\n            txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n        Connection newCon = this.dataSource.getConnection();\n        //获得连接，可以看出ConnectionHolder是对Connection的包装\n        txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n    }\n    txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n    con = txObject.getConnectionHolder().getConnection();\n    //设置是否只读和隔离级别\n    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n    txObject.setPreviousIsolationLevel(previousIsolationLevel);\n    // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n    // so we don\'t want to do it unnecessarily (for example if we\'ve explicitly\n    // configured the connection pool to set it already).\n    if (con.getAutoCommit()) {\n        txObject.setMustRestoreAutoCommit(true);\n        con.setAutoCommit(false);\n    }\n    txObject.getConnectionHolder().setTransactionActive(true);\n    int timeout = determineTimeout(definition);\n    if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n        txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n    }\n    // Bind the session holder to the thread.\n    if (txObject.isNewConnectionHolder()) {\n        TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());\n    }\n}\n```\n\n到这里便可以得出结论:\n\n**Spring事务的开启实际上是将数据库的自动提交设为false**。\n\n### 事务提交 & 回滚\n\n其实就是对jdbc相应方法的封装，不再展开。\n\n# 总结\n\n事务的本质其实是对数据库自动提交的关闭与开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。\n\n\n\n\n\n', '', '2', 0, '2020-01-08 17:05:22', '2020-01-08 17:05:22', '2020-01-08 17:04:14', '\n\n<p><strong>Table of Contents</strong>  <em>generated with <a href=\"https://github.com/thlorenz/doctoc\">DocToc</a></em></p>\n<ul>\n<li><a href=\"#%E9%85%8D%E7%BD%AE\">配置</a></li>\n<li><a href=\"#%E8%A7%A3%E6%9E%90\">解析</a>\n<ul>\n<li><a href=\"#transactionaleventlistener\">TransactionalEventListener</a></li>\n<li><a href=\"#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C\">主要组件注册</a></li>\n<li><a href=\"#%E4%BB%A3%E7%90%86%E7%B1%BB%E7%94%9F%E6%88%90\">代理类生成</a>\n<ul>\n<li><a href=\"#advisor%E5%AF%BB%E6%89%BE\">Advisor寻找</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C\">运行</a>\n<ul>\n<li><a href=\"#%E8%B0%83%E7%94%A8%E9%93%BE%E7%94%9F%E6%88%90\">调用链生成</a></li>\n<li><a href=\"#%E8%B0%83%E7%94%A8%E9%93%BE%E8%B0%83%E7%94%A8\">调用链调用</a></li>\n<li><a href=\"#transactioninterceptor\">TransactionInterceptor</a>\n<ul>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8\">事务管理器</a></li>\n<li><a href=\"#datasource\">DataSource</a></li>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%90%AF\">事务开启</a>\n<ul>\n<li><a href=\"#%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AD%98%E5%9C%A8%E4%BA%8B%E5%8A%A1\">是否已存在事务</a></li>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E5%B7%B2%E5%AD%98%E5%9C%A8\">事务已存在</a>\n<ul>\n<li><a href=\"#propagation_never\">PROPAGATION_NEVER</a></li>\n<li><a href=\"#propagation_not_supported\">PROPAGATION_NOT_SUPPORTED</a>\n<ul>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7\">事务挂起</a></li>\n</ul>\n</li>\n<li><a href=\"#propagation_requires_new\">PROPAGATION_REQUIRES_NEW</a></li>\n<li><a href=\"#propagation_nested\">PROPAGATION_NESTED</a>\n<ul>\n<li><a href=\"#debug%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\">debug环境搭建</a></li>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E5%AF%B9%E8%B1%A1\">事务对象</a></li>\n<li><a href=\"#savepoint\">Savepoint</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E5%88%9B%E5%BB%BA\">事务创建</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4--%E5%9B%9E%E6%BB%9A\">事务提交 &amp; 回滚</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n\n<h1>配置</h1>\n<p>以最简单的jdbc事务为例:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;!-- 数据源以Sping自带为例，每次请求均返回一个新的连接 --&gt;\n&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;\n    &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\" /&gt;\n    &lt;property name=\"url\" value=\"${jdbc.url}\" /&gt;\n    &lt;property name=\"username\" value=\"${jdbc.username}\" /&gt;\n    &lt;property name=\"password\" value=\"${jdbc.password}\" /&gt;\n&lt;/bean&gt;\n&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n&lt;/bean&gt;\n&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt;\n</code></pre>\n<h1>解析</h1>\n<p>TxNamespaceHandler.init:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic void init() {\n    registerBeanDefinitionParser(\"advice\", new TxAdviceBeanDefinitionParser());\n    registerBeanDefinitionParser(\"annotation-driven\", \n        new AnnotationDrivenBeanDefinitionParser());\n    registerBeanDefinitionParser(\"jta-transaction-manager\", new JtaTransactionManagerBeanDefinitionParser());\n}\n</code></pre>\n<p>明显解析的入口便在AnnotationDrivenBeanDefinitionParser.parse:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    registerTransactionalEventListenerFactory(parserContext);\n    String mode = element.getAttribute(\"mode\");\n    if (\"aspectj\".equals(mode)) {\n        // mode=\"aspectj\"\n        registerTransactionAspect(element, parserContext);\n    } else {\n        // mode=\"proxy\"\n        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);\n    }\n    return null;\n}\n</code></pre>\n<p>下面分部分进行说明。</p>\n<h2>TransactionalEventListener</h2>\n<p>第一部分用于向Spring容器注册TransactionalEventListener工厂，TransactionalEventListener是Spring4.2引入的新特性，允许我们自定义监听器监听事务的提交或其它动作。</p>\n<h2>主要组件注册</h2>\n<p>即configureAutoProxyCreator方法，此方法的最终作用便是在Spring容器中加入这样的bean结构:</p>\n<p>BeanFactoryTransactionAttributeSourceAdvisor-&gt;TransactionInterceptor-&gt;AnnotationTransactionAttributeSource</p>\n<p>其中AnnotationTransactionAttributeSource用于解析@Transactional注解的相关属性。</p>\n<h2>代理类生成</h2>\n<p>与aop模块类似，入口位于configureAutoProxyCreator里注册的bean: InfrastructureAdvisorAutoProxyCreator，其类图:</p>\n<p>![InfrastructureAdvisorAutoProxyCreator类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/InfrastructureAdvisorAutoProxyCreator.jpg)</p>\n<p>此类的特殊之处从其名字上可以体现: <strong>只考虑Spring内部使用的基础设施Advisor</strong>。</p>\n<p>为类创建代理的入口位于AbstractAutoProxyCreator.postProcessAfterInitialization:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n</code></pre>\n<p>wrapIfNecessary核心逻辑:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    // Create proxy if we have advice.\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        Object proxy = createProxy(\n            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n}\n</code></pre>\n<h3>Advisor寻找</h3>\n<p>getAdvicesAndAdvisorsForBean用于去容器中寻找适合当前bean的Advisor，其最终调用AbstractAdvisorAutoProxyCreator.findEligibleAdvisors:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {\n    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\n    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        //按照@Ordered排序\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n</code></pre>\n<p>这个方法在spring-aop中已经详细说明过了，这里再强调一下具体的查找逻辑:</p>\n<ul>\n<li>首先去容器找出所有实现了Advisor接口的bean，对应findCandidateAdvisors方法.</li>\n<li>逐一判断Advisor是否适用于当前bean，对应findAdvisorsThatCanApply方法，判断逻辑为:\n<ul>\n<li>如果Advisor是IntroductionAdvisor，那么判断其ClassFilter是否可以匹配bean的类.</li>\n<li>如果Advisor是PointcutAdvisor，那么首先进行ClassFilter匹配，如果匹配失败，那么再获得Advisor的MethodMatcher对象，如果MethodMatcher可以匹配任意方法，那么返回true，否则反射获取给定bean的所有方法逐一进行匹配，只要有一个匹配成功，即返回true.</li>\n<li>其它情况，直接返回true.</li>\n</ul>\n</li>\n</ul>\n<p>对于spring事务来说，我们有唯一的Advisor: BeanFactoryTransactionAttributeSourceAdvisor,其类图:</p>\n<p>![BeanFactoryTransactionAttributeSourceAdvisor类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/BeanFactoryTransactionAttributeSourceAdvisor.jpg)</p>\n<p>可以看出，BeanFactoryTransactionAttributeSourceAdvisor其实是一个PointcutAdvisor，所以<strong>是否可以匹配取决于其Pointcut</strong>。此Advisor的pointcut是一个TransactionAttributeSourcePointcut对象，类图:</p>\n<p>![TransactionAttributeSourcePointcut类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/TransactionAttributeSourcePointcut.jpg)</p>\n<p><strong>Pointcut的核心在于其ClassFilter和MethodMatcher</strong>。</p>\n<p>ClassFilter:</p>\n<p>位于StaticMethodMatcherPointcut:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private ClassFilter classFilter = ClassFilter.TRUE;\n</code></pre>\n<p>即: 类检查全部通过。</p>\n<p>MethodMatcher:</p>\n<p>TransactionAttributeSourcePointcut.matches:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic boolean matches(Method method, Class&lt;?&gt; targetClass) {\n    //如果已经是事务代理，那么不应该再次代理\n    if (TransactionalProxy.class.isAssignableFrom(targetClass)) {\n        return false;\n    }\n    TransactionAttributeSource tas = getTransactionAttributeSource();\n    return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);\n}\n</code></pre>\n<p>getTransactionAttribute方法使用了缓存的思想，但其核心逻辑位于AbstractFallbackTransactionAttributeSource.computeTransactionAttribute:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected TransactionAttribute computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass) {\n    // Don\'t allow no-public methods as required.\n    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {\n        return null;\n    }\n    // Ignore CGLIB subclasses - introspect the actual user class.\n    Class&lt;?&gt; userClass = ClassUtils.getUserClass(targetClass);\n    // The method may be on an interface, but we need attributes from the target class.\n    // If the target class is null, the method will be unchanged.\n    Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass);\n    // If we are dealing with method with generic parameters, find the original method.\n    specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n    // First try is the method in the target class.\n    TransactionAttribute txAtt = findTransactionAttribute(specificMethod);\n    if (txAtt != null) {\n        return txAtt;\n    }\n    // Second try is the transaction attribute on the target class.\n    txAtt = findTransactionAttribute(specificMethod.getDeclaringClass());\n    if (txAtt != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {\n        return txAtt;\n    }\n    if (specificMethod != method) {\n        // Fallback is to look at the original method.\n        txAtt = findTransactionAttribute(method);\n        if (txAtt != null) {\n            return txAtt;\n        }\n        // Last fallback is the class of the original method.\n        txAtt = findTransactionAttribute(method.getDeclaringClass());\n        if (txAtt != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {\n            return txAtt;\n        }\n    }\n    return null;\n}\n</code></pre>\n<p>很明显可以看出，<strong>首先去方法上查找是否有相应的事务注解(比如@Transactional)，如果没有，那么再去类上查找</strong>。</p>\n<h1>运行</h1>\n<p>以JDK动态代理为例，JdkDynamicAopProxy.invoke简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n    if (chain.isEmpty()) {.\n        //没有可用的拦截器，直接调用原方法\n        Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n        retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n    } else {\n        // We need to create a method invocation...\n        invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n        // Proceed to the joinpoint through the interceptor chain.\n        Object retVal = invocation.proceed();\n    }\n}\n</code></pre>\n<h2>调用链生成</h2>\n<p>即getInterceptorsAndDynamicInterceptionAdvice方法，其原理是:</p>\n<p><strong>遍历所有使用的 Advisor，获得其Advice，将Advice转为MethodInterceptor</strong>。那么是如何转的呢?</p>\n<p>根据Spring的定义，Advice可以是一个MethodInterceptor，也可以是类似于Aspectj的before, after通知。转换由DefaultAdvisorAdapterRegistry.getInterceptors完成:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {\n    List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3);\n    Advice advice = advisor.getAdvice();\n    if (advice instanceof MethodInterceptor) {\n        interceptors.add((MethodInterceptor) advice);\n    }\n    for (AdvisorAdapter adapter : this.adapters) {\n        if (adapter.supportsAdvice(advice)) {\n            interceptors.add(adapter.getInterceptor(advisor));\n        }\n    }\n    if (interceptors.isEmpty()) {\n        throw new UnknownAdviceTypeException(advisor.getAdvice());\n    }\n    return interceptors.toArray(new MethodInterceptor[interceptors.size()]);\n}\n</code></pre>\n<p>AdvisorAdapter接口用以支持用户自定义的Advice类型，并将自定义的类型转为拦截器。默认adapters含有MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter和ThrowsAdviceAdapter三种类型，用以分别支持MethodBeforeAdvice、AfterReturningAdvice和ThrowsAdvice。</p>\n<p><strong>对于我们的BeanFactoryTransactionAttributeSourceAdvisor来说，有且只有一个拦截器: TransactionInterceptor</strong>.</p>\n<h2>调用链调用</h2>\n<p>ReflectiveMethodInvocation.proceed:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object proceed() throws Throwable {\n    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n        //拦截器执行完毕，调用原本的方法\n        return invokeJoinpoint();\n    }\n    Object interceptorOrInterceptionAdvice =\n            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n        InterceptorAndDynamicMethodMatcher dm =\n                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n            return dm.interceptor.invoke(this);\n        } else {\n            // Dynamic matching failed.\n            return proceed();\n        }\n    } else {\n        //调用拦截器的invoke方法\n        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n    }\n}\n</code></pre>\n<p>可以看出，这其实是一个<strong>逐个调用拦截器的invoke方法，最终调用原本方法(被代理方法)的过程</strong>。所以，事务添加的核心逻辑(入口)在TransactionInterceptor的invoke方法。</p>\n<h2>TransactionInterceptor</h2>\n<p>invoke方法:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object invoke(final MethodInvocation invocation) throws Throwable {\n    Class&lt;?&gt; targetClass = (invocation.getThis() != null ? \n             AopUtils.getTargetClass(invocation.getThis()) : null);\n    // Adapt to TransactionAspectSupport\'s invokeWithinTransaction...\n    return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {\n        @Override\n        public Object proceedWithInvocation() throws Throwable {\n            //事务执行完毕后调用链继续向下执行\n            return invocation.proceed();\n        }\n    });\n}\n</code></pre>\n<p>invokeWithinTransaction简略版源码(仅保留PlatformTransactionManager部分):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation){\n    // If the transaction attribute is null, the method is non-transactional.\n    final TransactionAttribute txAttr = getTransactionAttributeSource()\n        .getTransactionAttribute(method, targetClass);\n    final PlatformTransactionManager tm = determineTransactionManager(txAttr);\n    //得到方法名\n    final String joinpointIdentification = methodIdentification(method, targetClass);\n    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\n        // Standard transaction demarcation with getTransaction and commit/rollback calls.\n        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\n        Object retVal = null;\n        try {\n            // This is an around advice: Invoke the next interceptor in the chain.\n            // This will normally result in a target object being invoked.\n            retVal = invocation.proceedWithInvocation();\n        } catch (Throwable ex) {\n            // target invocation exception\n            completeTransactionAfterThrowing(txInfo, ex);\n            throw ex;\n        } finally {\n            cleanupTransactionInfo(txInfo);\n        }\n        commitTransactionAfterReturning(txInfo);\n        return retVal;\n    }\n}\n</code></pre>\n<h3>事务管理器</h3>\n<p>determineTransactionManager方法用以确定使用的事务管理器:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected PlatformTransactionManager determineTransactionManager(TransactionAttribute txAttr) {\n    //如果没有事务属性，那么仅从缓存中查找，找不到返回null\n    if (txAttr == null || this.beanFactory == null) {\n        return getTransactionManager();\n    }\n    String qualifier = txAttr.getQualifier();\n    //如果@Transactional注解配置了transactionManager或value属性(用以决定使用哪个事务管理器):\n    //首先查找缓存，找不到再去容器中按名称寻找\n    if (StringUtils.hasText(qualifier)) {\n        return determineQualifiedTransactionManager(qualifier);\n    } else if (StringUtils.hasText(this.transactionManagerBeanName)) {\n        return determineQualifiedTransactionManager(this.transactionManagerBeanName);\n    } else {\n        //去容器中按类型(Class)查找\n        PlatformTransactionManager defaultTransactionManager = getTransactionManager();\n        if (defaultTransactionManager == null) {\n            defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class);\n            this.transactionManagerCache.putIfAbsent(\n                    DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);\n        }\n        return defaultTransactionManager;\n    }\n}\n</code></pre>\n<p>对于我们使用的DataSourceTransactionManager，类图:</p>\n<p>![DataSourceTransactionManager]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DataSourceTransactionManager.jpg)</p>\n<p>afterPropertiesSet方法只是对dataSource进行了检查。</p>\n<h3>DataSource</h3>\n<p>DriverManagerDataSource类图:</p>\n<p>![DriverManagerDataSource类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DriverManagerDataSource.jpg)</p>\n<p>其中CommonDataSource、Wrapper、DataSource均位于javax.sql包下。</p>\n<h3>事务开启</h3>\n<p>invocation.proceedWithInvocation()便是我们的逻辑，而createTransactionIfNecessary便是在逻辑执行前开启事务。</p>\n<p>TransactionAspectSupport.createTransactionIfNecessary:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">protected TransactionInfo createTransactionIfNecessary(\n    PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {\n    // If no name specified, apply method identification as transaction name.\n    if (txAttr != null &amp;&amp; txAttr.getName() == null) {\n        txAttr = new DelegatingTransactionAttribute(txAttr) {\n            @Override\n            public String getName() {\n                return joinpointIdentification;\n            }\n        };\n    }\n    TransactionStatus status = null;\n    if (txAttr != null) {\n        if (tm != null) {\n            status = tm.getTransaction(txAttr);\n        }\n    }\n    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\n}\n</code></pre>\n<p>此部分的核心逻辑在getTransaction和prepareTransactionInfo方法，源码较长，下面依然按部分整理。</p>\n<h4>是否已存在事务</h4>\n<p>目的在于支撑事务的传播性。</p>\n<p>源码位于DataSourceTransactionManager.doGetTransaction，核心逻辑在TransactionSynchronizationManager.doGetResource:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static Object doGetResource(Object actualKey) {\n    Map&lt;Object, Object&gt; map = resources.get();\n    if (map == null) {\n        return null;\n    }\n    Object value = map.get(actualKey);\n    // Transparently remove ResourceHolder that was marked as void...\n    if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) {\n        map.remove(actualKey);\n        // Remove entire ThreadLocal if empty...\n        if (map.isEmpty()) {\n            resources.remove();\n        }\n        value = null;\n    }\n    return value;\n}\n</code></pre>\n<p>actualKey实际上是DataSource对象，resources是一个ThreadLocal对象，其声明源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =\n            new NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(\"Transactional resources\");\n</code></pre>\n<p>从这里可以得出结论:</p>\n<p><strong>是否存在事务指的是在当前线程、当前数据源(DataSource)中是否存在处于活动状态的事务</strong>。</p>\n<h4>事务已存在</h4>\n<p>如果检测到已存在事务，那么就要考虑事务的传播特性(行为).此部分源码位于AbstractPlatformTransactionManager.handleExistingTransaction，下面按照不同的传播特性展开。</p>\n<h5>PROPAGATION_NEVER</h5>\n<p>即当前方法需要在非事务的环境下执行，如果有事务存在，那么抛出异常。相关源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\n    throw new IllegalTransactionStateException(\n        \"Existing transaction found for transaction marked with propagation \'never\'\");\n}\n</code></pre>\n<h5>PROPAGATION_NOT_SUPPORTED</h5>\n<p>与前者的区别在于，如果有事务存在，那么将事务挂起，而不是抛出异常。</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n    Object suspendedResources = suspend(transaction);\n    boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n    return prepareTransactionStatus(\n        definition, null, false, newSynchronization, debugEnabled, suspendedResources);\n}\n</code></pre>\n<h6>事务挂起</h6>\n<p>此部分的核心在于suspend方法，最终调用TransactionSynchronizationManager.doUnbindResource:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">private static Object doUnbindResource(Object actualKey) {\n    Map&lt;Object, Object&gt; map = resources.get();\n    if (map == null) {\n        return null;\n    }\n    Object value = map.remove(actualKey);\n    // Remove entire ThreadLocal if empty...\n    if (map.isEmpty()) {\n        resources.remove();\n    }\n    // Transparently suppress a ResourceHolder that was marked as void...\n    if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) {\n        value = null;\n    }\n    return value;\n}\n</code></pre>\n<p>可以看出，<strong>所谓的事务挂起其实就是一个移除当前线程、数据源活动事务对象的过程</strong>。</p>\n<p>同时注意getTransaction方法返回的是一个TransactionStatus对象，<strong>被挂起的事务的各种状态都被保存在此对象中</strong>。</p>\n<p>那么挂起这个操作到底是如何实现(起作用)的呢?</p>\n<p>DataSourceTransactionManager.doSuspend:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected Object doSuspend(Object transaction) {\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n    txObject.setConnectionHolder(null);\n    ConnectionHolder conHolder = (ConnectionHolder)\n            TransactionSynchronizationManager.unbindResource(this.dataSource);\n    return conHolder;\n}\n</code></pre>\n<p>其实玄机就在于将ConnectionHolder设为null这一行，因为<strong>一个ConnectionHolder对象就代表了一个数据库连接，将ConnectionHolder设为null就意味着我们下次要使用连接时，将重新从连接池获取，而新的连接的自动提交是为true的</strong>。</p>\n<h5>PROPAGATION_REQUIRES_NEW</h5>\n<pre><code data-language=\"java\" class=\"lang-java\">if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n    SuspendedResourcesHolder suspendedResources = suspend(transaction);\n    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n    DefaultTransactionStatus status = newTransactionStatus(\n            definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n    doBegin(transaction, definition);\n    prepareSynchronization(status, definition);\n    return status;\n}\n</code></pre>\n<p>可以看出，这其实是一个<strong>挂起当前活动事务并创建新事务的过程</strong>，doBegin方法是事务开启的核心，将在后面进行说明。</p>\n<h5>PROPAGATION_NESTED</h5>\n<p>其意义:</p>\n<blockquote>\n<p>PROPAGATION_NESTED 开始一个 \"嵌套的\" 事务,&nbsp; 它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时,&nbsp; 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分, 只有外部事务结束后它才会被提交.</p>\n</blockquote>\n<p>摘自: <a href=\"http://www.iteye.com/topic/35907\">解惑 spring 嵌套事务</a></p>\n<p>核心源码(忽略JTA部分):</p>\n<pre><code data-language=\"java\" class=\"lang-java\">if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n    if (useSavepointForNestedTransaction()) {\n        // Create savepoint within existing Spring-managed transaction,\n        // through the SavepointManager API implemented by TransactionStatus.\n        // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\n        DefaultTransactionStatus status =\n            prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);\n        status.createAndHoldSavepoint();\n        return status;\n    }\n}\n</code></pre>\n<p>关键在于如何创建SavePoint, AbstractTransactionStatus.createAndHoldSavepoint:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public void createAndHoldSavepoint() throws TransactionException {\n    setSavepoint(getSavepointManager().createSavepoint());\n}\n</code></pre>\n<p>DefaultTransactionStatus.getSavepointManager:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected SavepointManager getSavepointManager() {\n    if (!isTransactionSavepointManager()) {\n        throw new NestedTransactionNotSupportedException(\n            \"Transaction object [\" + getTransaction() + \"] does not support savepoints\");\n    }\n    return (SavepointManager) getTransaction();\n}\n</code></pre>\n<p>可以看出，SavepointManager实际上从Transaction强转而来，Transaction在Spring都是用Object引用的，那么这到底是个什么东西?</p>\n<h6>debug环境搭建</h6>\n<ul>\n<li>\n<p>安装Mysql数据库(或其它支持jdbc)并正确配置数据库连接.</p>\n</li>\n<li>\n<p>定义两个bean，代表我们的业务逻辑:</p>\n<ul>\n<li>\n<p>TransactionBean:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Component\npublic class TransactionBean {\n    private NestedBean nestedBean;\n    public NestedBean getNestedBean() {\n        return nestedBean;\n    }\n    public void setNestedBean(NestedBean nestedBean) {\n        this.nestedBean = nestedBean;\n    }\n  \n    @Transactional(propagation = Propagation.REQUIRED)\n    public void process() {\n        System.out.println(\"事务执行\");\n        nestedBean.nest();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>NestedBean:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Component\npublic class NestedBean {\n    @Transactional(propagation = Propagation.NESTED)\n    public void nest() {\n        System.out.println(\"嵌套事务\");\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>配置文件:</p>\n<pre><code data-language=\"xml\" class=\"lang-xml\">&lt;bean id=\"nestedBean\" class=\"base.transaction.NestedBean\" /&gt;\n&lt;bean class=\"base.transaction.TransactionBean\"&gt;\n  &lt;property name=\"nestedBean\" ref=\"nestedBean\" /&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n<li>\n<p>入口:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public static void main(String[] args) {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\");\n    TransactionBean bean = context.getBean(TransactionBean.class);\n    bean.process();\n}\n</code></pre>\n</li>\n</ul>\n<p>这样将断点打在合适的位置便可以得到事务对象究竟是什么。</p>\n<p>注意:</p>\n<p><strong>nest方法必须在一个单独的业务bean中</strong>，否则对nest的调用并不会导致事务获取的触发。这是由JDK动态代理的实现机制决定的，<strong>调用当前类的方法并不会触发代理逻辑(InvocationHandler)</strong>。</p>\n<p>这一点可以运行demo:test.proxy.JDKProxy看出。</p>\n<p>运行debug可以发现，<strong>对于DataSourceTransactionManager，事务对象其实是其内部类DataSourceTransactionObject</strong>.</p>\n<h6>事务对象</h6>\n<p>DataSourceTransactionObject的类图如下:</p>\n<p>![DataSourceTransactionObject类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/DataSourceTransactionObject.jpg)</p>\n<h6>Savepoint</h6>\n<p>位于java.sql包下，对于Mysql来说，由Mysql驱动提供实现，类图:</p>\n<p>![Savepoint类图]((https://raw.githubusercontent.com/seaswalker/spring-analysis/master/note/images/Savepoint.jpg)</p>\n<p>下面来看一下Savepoint到底是如何被创建的。</p>\n<p>JdbcTransactionObjectSupport.createSavepoint简略版源码:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\npublic Object createSavepoint() throws TransactionException {\n    ConnectionHolder conHolder = getConnectionHolderForSavepoint();\n    return conHolder.createSavepoint();\n}\n</code></pre>\n<p>ConnectionHolder.createSavepoint:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">public Savepoint createSavepoint() throws SQLException {\n    this.savepointCounter++;\n    return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);\n}\n</code></pre>\n<p>我们可以得出这样的结论:</p>\n<p><strong>Savepoint由java SQL标准定义，具体实现由数据库完成</strong>。从mysql的客户端可以直接执行命令<code data-backticks=\"1\">savepoint xx</code>可以看出这一点。</p>\n<h5>其它</h5>\n<p>略。</p>\n<h4>事务创建</h4>\n<p>如果之前不存在事务，那么就需要创建了，核心逻辑位于DataSourceTransactionManager.doBegin:</p>\n<pre><code data-language=\"java\" class=\"lang-java\">@Override\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\n    //此时，txObject不为null，只是其核心的ConnectHolder属性为null\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n    Connection con = null;\n    if (txObject.getConnectionHolder() == null ||\n            txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n        Connection newCon = this.dataSource.getConnection();\n        //获得连接，可以看出ConnectionHolder是对Connection的包装\n        txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n    }\n    txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n    con = txObject.getConnectionHolder().getConnection();\n    //设置是否只读和隔离级别\n    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n    txObject.setPreviousIsolationLevel(previousIsolationLevel);\n    // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n    // so we don\'t want to do it unnecessarily (for example if we\'ve explicitly\n    // configured the connection pool to set it already).\n    if (con.getAutoCommit()) {\n        txObject.setMustRestoreAutoCommit(true);\n        con.setAutoCommit(false);\n    }\n    txObject.getConnectionHolder().setTransactionActive(true);\n    int timeout = determineTimeout(definition);\n    if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n        txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n    }\n    // Bind the session holder to the thread.\n    if (txObject.isNewConnectionHolder()) {\n        TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());\n    }\n}\n</code></pre>\n<p>到这里便可以得出结论:</p>\n<p><strong>Spring事务的开启实际上是将数据库的自动提交设为false</strong>。</p>\n<h3>事务提交 &amp; 回滚</h3>\n<p>其实就是对jdbc相应方法的封装，不再展开。</p>\n<h1>总结</h1>\n<p>事务的本质其实是对数据库自动提交的关闭与开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。</p>\n');

-- ----------------------------
-- Table structure for tb_article_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_category`;
CREATE TABLE `tb_article_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `category_id` bigint(20) NOT NULL COMMENT '分类ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 139 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文章&&分类关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_category
-- ----------------------------
INSERT INTO `tb_article_category` VALUES (39, 278, 55);
INSERT INTO `tb_article_category` VALUES (40, 279, 55);
INSERT INTO `tb_article_category` VALUES (41, 280, 55);
INSERT INTO `tb_article_category` VALUES (42, 281, 55);
INSERT INTO `tb_article_category` VALUES (43, 282, 55);
INSERT INTO `tb_article_category` VALUES (44, 283, 55);
INSERT INTO `tb_article_category` VALUES (45, 284, 55);
INSERT INTO `tb_article_category` VALUES (46, 285, 55);
INSERT INTO `tb_article_category` VALUES (47, 286, 55);
INSERT INTO `tb_article_category` VALUES (48, 287, 55);
INSERT INTO `tb_article_category` VALUES (50, 288, 55);
INSERT INTO `tb_article_category` VALUES (76, 291, 55);
INSERT INTO `tb_article_category` VALUES (77, 292, 55);
INSERT INTO `tb_article_category` VALUES (78, 293, 55);
INSERT INTO `tb_article_category` VALUES (79, 294, 55);
INSERT INTO `tb_article_category` VALUES (80, 295, 55);
INSERT INTO `tb_article_category` VALUES (87, 302, 55);
INSERT INTO `tb_article_category` VALUES (97, 289, 55);
INSERT INTO `tb_article_category` VALUES (98, 290, 55);
INSERT INTO `tb_article_category` VALUES (99, 308, 55);
INSERT INTO `tb_article_category` VALUES (100, 311, 55);
INSERT INTO `tb_article_category` VALUES (102, 303, 55);
INSERT INTO `tb_article_category` VALUES (103, 300, 55);
INSERT INTO `tb_article_category` VALUES (104, 298, 55);
INSERT INTO `tb_article_category` VALUES (105, 299, 55);
INSERT INTO `tb_article_category` VALUES (106, 296, 55);
INSERT INTO `tb_article_category` VALUES (107, 301, 55);
INSERT INTO `tb_article_category` VALUES (109, 306, 55);
INSERT INTO `tb_article_category` VALUES (110, 307, 55);
INSERT INTO `tb_article_category` VALUES (111, 304, 55);
INSERT INTO `tb_article_category` VALUES (112, 305, 55);
INSERT INTO `tb_article_category` VALUES (113, 310, 55);
INSERT INTO `tb_article_category` VALUES (114, 309, 55);
INSERT INTO `tb_article_category` VALUES (123, 313, 64);
INSERT INTO `tb_article_category` VALUES (124, 314, 64);
INSERT INTO `tb_article_category` VALUES (125, 315, 64);
INSERT INTO `tb_article_category` VALUES (126, 316, 64);
INSERT INTO `tb_article_category` VALUES (127, 317, 64);
INSERT INTO `tb_article_category` VALUES (128, 318, 64);
INSERT INTO `tb_article_category` VALUES (129, 319, 64);
INSERT INTO `tb_article_category` VALUES (130, 312, 64);
INSERT INTO `tb_article_category` VALUES (131, 297, 55);
INSERT INTO `tb_article_category` VALUES (134, 273, 55);
INSERT INTO `tb_article_category` VALUES (135, 274, 55);
INSERT INTO `tb_article_category` VALUES (136, 275, 55);
INSERT INTO `tb_article_category` VALUES (137, 276, 55);
INSERT INTO `tb_article_category` VALUES (138, 277, 55);

-- ----------------------------
-- Table structure for tb_article_tags
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_tags`;
CREATE TABLE `tb_article_tags`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `tags_id` bigint(20) NOT NULL COMMENT '标签ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 32 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文章&&标签关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_tags
-- ----------------------------
INSERT INTO `tb_article_tags` VALUES (8, 288, 59);
INSERT INTO `tb_article_tags` VALUES (11, 290, 60);
INSERT INTO `tb_article_tags` VALUES (21, 313, 62);
INSERT INTO `tb_article_tags` VALUES (22, 314, 63);
INSERT INTO `tb_article_tags` VALUES (23, 315, 64);
INSERT INTO `tb_article_tags` VALUES (24, 316, 65);
INSERT INTO `tb_article_tags` VALUES (25, 317, 66);
INSERT INTO `tb_article_tags` VALUES (26, 318, 67);
INSERT INTO `tb_article_tags` VALUES (27, 319, 68);
INSERT INTO `tb_article_tags` VALUES (28, 312, 61);
INSERT INTO `tb_article_tags` VALUES (31, 273, 58);

-- ----------------------------
-- Table structure for tb_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_category`;
CREATE TABLE `tb_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类名称',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `tb_category_name_uindex`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 65 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '分类表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_category
-- ----------------------------
INSERT INTO `tb_category` VALUES (63, 'Go');
INSERT INTO `tb_category` VALUES (56, 'Java');
INSERT INTO `tb_category` VALUES (59, 'JS');
INSERT INTO `tb_category` VALUES (57, 'Kotlin');
INSERT INTO `tb_category` VALUES (58, 'PHP');
INSERT INTO `tb_category` VALUES (64, 'Spring');
INSERT INTO `tb_category` VALUES (55, 'UI/UE');
INSERT INTO `tb_category` VALUES (61, '编译原理');
INSERT INTO `tb_category` VALUES (62, '计算机组成原理');
INSERT INTO `tb_category` VALUES (60, '计算机网络');

-- ----------------------------
-- Table structure for tb_comments
-- ----------------------------
DROP TABLE IF EXISTS `tb_comments`;
CREATE TABLE `tb_comments`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `p_id` bigint(20) NULL DEFAULT 0 COMMENT '父级ID，给哪个留言进行回复',
  `c_id` bigint(20) NULL DEFAULT 0 COMMENT '子级ID，给哪个留言下的回复进行评论',
  `article_title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标题',
  `article_id` bigint(20) NULL DEFAULT NULL COMMENT '文章ID',
  `author` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '留言人',
  `author_id` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '给谁留言',
  `email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '留言邮箱',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '留言内容',
  `time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '留言时间',
  `url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '链接',
  `state` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '正常' COMMENT '状态',
  `sort` bigint(20) NULL DEFAULT 0 COMMENT '分类：0默认文章详情页，1友链页，2关于我页',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 52 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '评论表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_comments
-- ----------------------------
INSERT INTO `tb_comments` VALUES (30, 0, 0, 'A-simple-story', 273, 'Aaron', '', '', '测试留言接口^-^', '2020-01-06 22:30:07', 'http://47.100.57.39/static/icons/12.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (31, 30, 0, 'A-simple-story', 273, 'Abdieso  ', '@Aaron', '', '测试留言回复接口^-^', '2020-01-06 22:36:20', 'http://47.100.57.39/static/icons/2.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (32, 0, 0, 'A-simple-story', 273, 'Dagobert ', '', '', '测试留言接口', '2020-01-06 23:00:44', 'http://47.100.57.39/static/icons/5.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (33, 0, 0, 'A-simple-story', 273, 'Dahana ', '', '', '测试留言接口', '2020-01-06 23:02:38', 'http://47.100.57.39/static/icons/17.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (34, 0, 0, 'A-simple-story', 273, 'Edmond ', '', '', '测试留言接口^-^\n\n', '2020-01-06 23:07:33', 'http://47.100.57.39/static/icons/2.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (35, 0, 0, 'A-simple-story', 273, 'Eberhard ', '', '', '测试留言接口^-^', '2020-01-06 23:08:39', 'http://47.100.57.39/static/icons/25.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (36, 0, 0, 'A-simple-story', 273, 'Edison ', '', '', '测试留言接口^-^\n\n', '2020-01-06 23:08:53', 'http://47.100.57.39/static/icons/29.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (37, 36, 0, 'A-simple-story', 273, 'Edison ', '@Edison ', '', '我回复我自己 ===', '2020-01-06 23:09:43', 'http://47.100.57.39/static/icons/29.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (38, 0, 0, 'A-simple-story', 273, 'Faraji ', '', '', '测试分页', '2020-01-06 23:11:36', 'http://47.100.57.39/static/icons/12.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (40, 0, 0, 'describe-the-user-experience', 280, 'xian', '', '', 'it\'s awesome !', '2020-01-07 13:53:33', 'http://47.100.57.39/static/icons/24.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (41, 0, 0, 'Features', 274, 'VeScarecrow', '', '', 'make china great again!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', '2020-01-07 22:06:54', 'http://47.100.57.39/static/icons/8.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (42, 41, 0, 'Features', 274, 'jhon', '@VeScarecrow', '', 'yuo are absulete right!', '2020-01-07 22:07:53', 'http://47.100.57.39/static/icons/7.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (43, 41, 42, 'Features', 274, 'alita', '@jhon', '', 'wow !!!   you can realy dance!!!!!!!!!!!!!!!!!!!!!!', '2020-01-07 22:08:39', 'http://47.100.57.39/static/icons/12.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (44, 0, 0, 'Features', 274, 'haha', '', '', 'hahahahahhahahahahahahhahahh', '2020-01-07 22:10:00', 'http://47.100.57.39/static/icons/24.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (45, 44, 0, 'Features', 274, 'fahfaskfjshf', '@haha', '', 'dfaksdflskjfkasljflksdjflsdfasdfashlsdjfjdkuilf9qf', '2020-01-07 22:10:13', 'http://47.100.57.39/static/icons/5.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (46, 0, 0, 'Features', 274, 'asdfafdsdfas', '@haha', '', 'kajhdfksdfhksdfjkhsdfhaskjf', '2020-01-07 22:10:22', 'http://47.100.57.39/static/icons/5.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (47, 0, 0, 'Features', 274, 'sdfasdjllksk', '@haha', '', 'falkfklasjfkls,mvnxv,zf0ejfiodf', '2020-01-07 22:10:38', 'http://47.100.57.39/static/icons/24.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (48, 0, 0, 'Features', 274, 'adf', '@haha', '', 'da;dlfkjadsfkjadkfj', '2020-01-07 22:10:54', 'http://47.100.57.39/static/icons/25.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (49, 0, 0, 'Features', 274, 'asdfasdf', '@haha', '', 'dsfasdfsdfsd', '2020-01-07 22:11:03', 'http://47.100.57.39/static/icons/11.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (50, 0, 0, 'Features', 274, 'asdf', '@haha', '', 'asdf', '2020-01-07 22:11:06', 'http://47.100.57.39/static/icons/22.png', '正常', 0);
INSERT INTO `tb_comments` VALUES (51, 0, 0, 'Spring源码分析', 312, 'xian', '', '', 'good!', '2020-01-08 17:06:23', 'http://47.100.57.39/static/icons/9.png', '正常', 0);

-- ----------------------------
-- Table structure for tb_links
-- ----------------------------
DROP TABLE IF EXISTS `tb_links`;
CREATE TABLE `tb_links`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '连接名称',
  `url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '连接URL',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '友链表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_links
-- ----------------------------
INSERT INTO `tb_links` VALUES (1, 'JaJian', 'https://www.cnblogs.com/JaJian/');
INSERT INTO `tb_links` VALUES (2, 'mrbird', 'https://mrbird.cc/');

-- ----------------------------
-- Table structure for tb_tags
-- ----------------------------
DROP TABLE IF EXISTS `tb_tags`;
CREATE TABLE `tb_tags`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签名称',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `tb_tags_name_uindex`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 69 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '标签表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_tags
-- ----------------------------
INSERT INTO `tb_tags` VALUES (59, 'apple');
INSERT INTO `tb_tags` VALUES (62, 'guava-cache');
INSERT INTO `tb_tags` VALUES (60, 'sara');
INSERT INTO `tb_tags` VALUES (63, 'spring-aop');
INSERT INTO `tb_tags` VALUES (64, 'spring-boot');
INSERT INTO `tb_tags` VALUES (65, 'spring-context');
INSERT INTO `tb_tags` VALUES (61, 'spring-core');
INSERT INTO `tb_tags` VALUES (66, 'spring-mvc');
INSERT INTO `tb_tags` VALUES (67, 'spring-task');
INSERT INTO `tb_tags` VALUES (68, 'spring-transaction');
INSERT INTO `tb_tags` VALUES (58, '简约至上：交互式设计四策略');

-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `username` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名',
  `nickname` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '昵称',
  `password` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `salt` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '盐值',
  `email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `avatar` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `tb_user_username_uindex`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '标签表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES (1, 'Xian', 'Xian', '123456', '123456', 'x', 'http://47.100.57.39/static/icons/3.png');

SET FOREIGN_KEY_CHECKS = 1;
